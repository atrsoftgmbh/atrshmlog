
;; Function uint64_t atrshmlog_get_tsc_par_x86_64_gnu() (null)
;; enabled by -tree-original


{
  uint32_t hi;
  uint32_t lo;

    uint32_t hi;
    uint32_t lo;
  <<cleanup_point __asm__ __volatile__("rdtscp":"=a" lo, "=d" hi:)>>;
  return <retval> = (uint64_t) hi << 32 | (uint64_t) lo;
}


;; Function uint64_t atrshmlog_get_tsc_fence_x86_64_gnu() (null)
;; enabled by -tree-original


{
  uint32_t hi;
  uint32_t lo;

    uint32_t hi;
    uint32_t lo;
  <<cleanup_point __asm__ __volatile__("lfence"::)>>;
  <<cleanup_point __asm__ __volatile__("rdtsc":"=a" lo, "=d" hi:)>>;
  return <retval> = (uint64_t) hi << 32 | (uint64_t) lo;
}


;; Function uint64_t atrshmlog_get_tsc_x86_64_gnu() (null)
;; enabled by -tree-original


{
  uint32_t hi;
  uint32_t lo;

    uint32_t hi;
    uint32_t lo;
  <<cleanup_point __asm__ __volatile__("rdtsc":"=a" lo, "=d" hi:)>>;
  return <retval> = (uint64_t) hi << 32 | (uint64_t) lo;
}


;; Function uint64_t atrshmlog_get_tsc_null_x86_64_gnu() (null)
;; enabled by -tree-original


return <retval> = 0;


;; Function atrshmlog_time_t atrshmlog_get_clicktime() (null)
;; enabled by -tree-original


if (<<cleanup_point (int) atrshmlog_clock_id == 3>>)
  {
    <<cleanup_point return <retval> = atrshmlog_get_tsc_par_x86_64_gnu ()>>;
  }
if (<<cleanup_point (int) atrshmlog_clock_id == 2>>)
  {
    <<cleanup_point return <retval> = atrshmlog_get_tsc_fence_x86_64_gnu ()>>;
  }
if (<<cleanup_point (int) atrshmlog_clock_id == 1>>)
  {
    <<cleanup_point return <retval> = atrshmlog_get_tsc_x86_64_gnu ()>>;
  }
<<cleanup_point return <retval> = atrshmlog_get_tsc_null_x86_64_gnu ()>>;


;; Function wint_t btowc(int) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  <<cleanup_point return <retval> = __builtin_constant_p (__c) == 0 || (unsigned int) __c > 127 ? __btowc_alias (__c) : (wint_t) __c>>
   >>>;


;; Function int wctob(wint_t) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  <<cleanup_point return <retval> = __builtin_constant_p (__wc) == 0 || __wc > 127 ? __wctob_alias (__wc) : (int) __wc>>
   >>>;


;; Function size_t mbrlen(const char*, size_t, mbstate_t*) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  <<cleanup_point return <retval> = __ps != 0B ? mbrtowc (0B, __s, __n, __ps) : __mbrlen (__s, __n, 0B)>>
   >>>;


;; Function std::exception::exception() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct exception *) this)->_vptr.exception = &_ZTVSt9exception + 16) >>>>>;
  }
   >>>;


;; Function std::bad_exception::bad_exception() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::exception::exception (&((struct bad_exception *) this)->D.3345) >>>>>;
    try
      {
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct bad_exception *) this)->D.3345._vptr.exception = &_ZTVSt13bad_exception + 16) >>>>>;
      }
    catch
      {
        std::exception::~exception (&((struct bad_exception *) this)->D.3345);
      }
  }
   >>>;


;; Function std::__exception_ptr::exception_ptr::exception_ptr(std::nullptr_t) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct exception_ptr *) this)->_M_exception_object = 0B) >>>>>;
  }
   >>>;


;; Function std::__exception_ptr::exception_ptr::exception_ptr(std::__exception_ptr::exception_ptr&&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct exception_ptr *) this)->_M_exception_object = __o->_M_exception_object) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__o->_M_exception_object = 0B) >>>>>;
  }
   >>>;


;; Function std::__exception_ptr::exception_ptr& std::__exception_ptr::exception_ptr::operator=(std::__exception_ptr::exception_ptr&&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__exception_ptr::exception_ptr::swap (&TARGET_EXPR <D.3465, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.3465
  (struct exception_ptr *) <<< Unknown tree: void_cst >>>
  (struct exception_ptr &) (struct exception_ptr *) NON_LVALUE_EXPR <__o> >>>>, (struct exception_ptr &) (struct exception_ptr *) this) >>>>>;
  return <retval> = (struct exception_ptr &) (struct exception_ptr *) this;
   >>>;


;; Function std::__exception_ptr::exception_ptr::operator bool() const (null)
;; enabled by -tree-original


return <retval> = (void *) ((const struct exception_ptr *) this)->_M_exception_object != 0B;


;; Function void std::__exception_ptr::swap(std::__exception_ptr::exception_ptr&, std::__exception_ptr::exception_ptr&) (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::__exception_ptr::exception_ptr::swap ((struct exception_ptr *) __lhs, (struct exception_ptr &) (struct exception_ptr *) __rhs) >>>>>;


;; Function std::nested_exception::nested_exception() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct nested_exception *) this)->_vptr.nested_exception = &_ZTVSt16nested_exception + 16) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct nested_exception *) this)->_M_ptr = TARGET_EXPR <D.3540, <<< Unknown tree: aggr_init_expr
  3
  current_exception
  D.3540 >>>>) >>>>>;
    try
      {
        
      }
    catch
      {
        std::__exception_ptr::exception_ptr::~exception_ptr (&((struct nested_exception *) this)->_M_ptr);
      }
  }
   >>>;


;; Function void std::nested_exception::rethrow_nested() const (null)
;; enabled by -tree-original


if (<<cleanup_point std::__exception_ptr::exception_ptr::operator bool (&((const struct nested_exception *) this)->_M_ptr)>>)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::rethrow_exception (&TARGET_EXPR <D.3545, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.3545
  (struct exception_ptr *) <<< Unknown tree: void_cst >>>
  (const struct exception_ptr &) &((const struct nested_exception *) this)->_M_ptr >>>>) >>>>>;
  }
<<cleanup_point <<< Unknown tree: expr_stmt
  std::terminate () >>>>>;


;; Function std::__exception_ptr::exception_ptr std::nested_exception::nested_ptr() const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return *<retval> = TARGET_EXPR <D.3547, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.3547
  (struct exception_ptr *) <<< Unknown tree: void_cst >>>
  (const struct exception_ptr &) &((const struct nested_exception *) this)->_M_ptr >>>>>>
   >>>;


;; Function bool __gnu_cxx::__is_null_pointer(std::nullptr_t) (null)
;; enabled by -tree-original


return <retval> = 1;


;; Function constexpr __gnu_cxx::__ops::_Iter_less_iter __gnu_cxx::__ops::__iter_less_iter() (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = TARGET_EXPR <D.8547, {}>>>;


;; Function __gnu_cxx::__ops::_Iter_less_val __gnu_cxx::__ops::__iter_less_val() (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = TARGET_EXPR <D.8594, {}>>>;


;; Function __gnu_cxx::__ops::_Iter_less_val __gnu_cxx::__ops::__iter_comp_val(__gnu_cxx::__ops::_Iter_less_iter) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = TARGET_EXPR <D.8607, {}>>>;


;; Function __gnu_cxx::__ops::_Val_less_iter __gnu_cxx::__ops::__val_less_iter() (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = TARGET_EXPR <D.8645, {}>>>;


;; Function __gnu_cxx::__ops::_Val_less_iter __gnu_cxx::__ops::__val_comp_iter(__gnu_cxx::__ops::_Iter_less_iter) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = TARGET_EXPR <D.8658, {}>>>;


;; Function __gnu_cxx::__ops::_Iter_equal_to_iter __gnu_cxx::__ops::__iter_equal_to_iter() (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = TARGET_EXPR <D.8696, {}>>>;


;; Function __gnu_cxx::__ops::_Iter_equal_to_val __gnu_cxx::__ops::__iter_equal_to_val() (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = TARGET_EXPR <D.8743, {}>>>;


;; Function __gnu_cxx::__ops::_Iter_equal_to_val __gnu_cxx::__ops::__iter_comp_val(__gnu_cxx::__ops::_Iter_equal_to_iter) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = TARGET_EXPR <D.8756, {}>>>;


;; Function constexpr int std::__lg(int) (null)
;; enabled by -tree-original


return <retval> = (int) (((unsigned int) 4 * 8 - (unsigned int) __builtin_clz ((unsigned int) __n)) + 4294967295);


;; Function constexpr unsigned int std::__lg(unsigned int) (null)
;; enabled by -tree-original


return <retval> = ((unsigned int) 4 * 8 - (unsigned int) __builtin_clz (__n)) + 4294967295;


;; Function constexpr long int std::__lg(long int) (null)
;; enabled by -tree-original


return <retval> = (long int) ((8 * 8 - (long unsigned int) __builtin_clzl ((long unsigned int) __n)) + 18446744073709551615);


;; Function constexpr long unsigned int std::__lg(long unsigned int) (null)
;; enabled by -tree-original


return <retval> = (8 * 8 - (long unsigned int) __builtin_clzl (__n)) + 18446744073709551615;


;; Function constexpr long long int std::__lg(long long int) (null)
;; enabled by -tree-original


return <retval> = (long long int) ((8 * 8 - (long unsigned int) __builtin_clzll ((long long unsigned int) __n)) + 18446744073709551615);


;; Function constexpr long long unsigned int std::__lg(long long unsigned int) (null)
;; enabled by -tree-original


return <retval> = (long long unsigned int) ((8 * 8 - (long unsigned int) __builtin_clzll (__n)) + 18446744073709551615);


;; Function static void std::char_traits<char>::assign(std::char_traits<char>::char_type&, const char_type&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__c1 = (char_type) *__c2) >>>>>
   >>>;


;; Function static constexpr bool std::char_traits<char>::eq(const char_type&, const char_type&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (signed char) *__c1 == (signed char) *__c2
   >>>;


;; Function static constexpr bool std::char_traits<char>::lt(const char_type&, const char_type&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (unsigned char) *__c1 < (unsigned char) *__c2
   >>>;


;; Function static int std::char_traits<char>::compare(const char_type*, const char_type*, std::size_t) (null)
;; enabled by -tree-original


if (__n == 0)
  {
    return <retval> = 0;
  }
return <retval> = __builtin_memcmp ((const void *) __s1, (const void *) __s2, __n);


;; Function static std::size_t std::char_traits<char>::length(const char_type*) (null)
;; enabled by -tree-original


return <retval> = __builtin_strlen (__s);


;; Function static const char_type* std::char_traits<char>::find(const char_type*, std::size_t, const char_type&) (null)
;; enabled by -tree-original


if (__n == 0)
  {
    return <retval> = 0B;
  }
return <retval> = (const char_type *) __builtin_memchr ((const void *) __s, (int) *__a, __n);


;; Function static std::char_traits<char>::char_type* std::char_traits<char>::move(std::char_traits<char>::char_type*, const char_type*, std::size_t) (null)
;; enabled by -tree-original


if (__n == 0)
  {
    return <retval> = __s1;
  }
<<cleanup_point return <retval> = (char_type *) __builtin_memmove ((void *) __s1, (const void *) __s2, __n)>>;


;; Function static std::char_traits<char>::char_type* std::char_traits<char>::copy(std::char_traits<char>::char_type*, const char_type*, std::size_t) (null)
;; enabled by -tree-original


if (__n == 0)
  {
    return <retval> = __s1;
  }
<<cleanup_point return <retval> = (char_type *) __builtin_memcpy ((void *) __s1, (const void *) __s2, __n)>>;


;; Function static std::char_traits<char>::char_type* std::char_traits<char>::assign(std::char_traits<char>::char_type*, std::size_t, std::char_traits<char>::char_type) (null)
;; enabled by -tree-original


if (__n == 0)
  {
    return <retval> = __s;
  }
<<cleanup_point return <retval> = (char_type *) __builtin_memset ((void *) __s, (int) __a, __n)>>;


;; Function static constexpr std::char_traits<char>::char_type std::char_traits<char>::to_char_type(const int_type&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (char_type) *__c
   >>>;


;; Function static constexpr std::char_traits<char>::int_type std::char_traits<char>::to_int_type(const char_type&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (int_type) (unsigned char) *__c
   >>>;


;; Function static constexpr bool std::char_traits<char>::eq_int_type(const int_type&, const int_type&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (int) *__c1 == (int) *__c2
   >>>;


;; Function static constexpr std::char_traits<char>::int_type std::char_traits<char>::eof() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = -1
   >>>;


;; Function static constexpr std::char_traits<char>::int_type std::char_traits<char>::not_eof(const int_type&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (int) *__c != std::char_traits<char>::eof () ? (int_type) *__c : 0>>
   >>>;


;; Function static void std::char_traits<wchar_t>::assign(std::char_traits<wchar_t>::char_type&, const char_type&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__c1 = (char_type) *__c2) >>>>>
   >>>;


;; Function static constexpr bool std::char_traits<wchar_t>::eq(const char_type&, const char_type&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (int) *__c1 == (int) *__c2
   >>>;


;; Function static constexpr bool std::char_traits<wchar_t>::lt(const char_type&, const char_type&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (int) *__c1 < (int) *__c2
   >>>;


;; Function static int std::char_traits<wchar_t>::compare(const char_type*, const char_type*, std::size_t) (null)
;; enabled by -tree-original


if (__n == 0)
  {
    return <retval> = 0;
  }
return <retval> = wmemcmp (__s1, __s2, __n);


;; Function static std::size_t std::char_traits<wchar_t>::length(const char_type*) (null)
;; enabled by -tree-original


return <retval> = wcslen (__s);


;; Function static const char_type* std::char_traits<wchar_t>::find(const char_type*, std::size_t, const char_type&) (null)
;; enabled by -tree-original


if (__n == 0)
  {
    return <retval> = 0B;
  }
return <retval> = (const char_type *) wmemchr (__s, (char_type) *__a, __n);


;; Function static std::char_traits<wchar_t>::char_type* std::char_traits<wchar_t>::move(std::char_traits<wchar_t>::char_type*, const char_type*, std::size_t) (null)
;; enabled by -tree-original


if (__n == 0)
  {
    return <retval> = __s1;
  }
<<cleanup_point return <retval> = (char_type *) wmemmove (__s1, __s2, __n)>>;


;; Function static std::char_traits<wchar_t>::char_type* std::char_traits<wchar_t>::copy(std::char_traits<wchar_t>::char_type*, const char_type*, std::size_t) (null)
;; enabled by -tree-original


if (__n == 0)
  {
    return <retval> = __s1;
  }
<<cleanup_point return <retval> = (char_type *) wmemcpy (__s1, __s2, __n)>>;


;; Function static std::char_traits<wchar_t>::char_type* std::char_traits<wchar_t>::assign(std::char_traits<wchar_t>::char_type*, std::size_t, std::char_traits<wchar_t>::char_type) (null)
;; enabled by -tree-original


if (__n == 0)
  {
    return <retval> = __s;
  }
<<cleanup_point return <retval> = (char_type *) wmemset (__s, __a, __n)>>;


;; Function static constexpr std::char_traits<wchar_t>::char_type std::char_traits<wchar_t>::to_char_type(const int_type&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (char_type) *__c
   >>>;


;; Function static constexpr std::char_traits<wchar_t>::int_type std::char_traits<wchar_t>::to_int_type(const char_type&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (int_type) *__c
   >>>;


;; Function static constexpr bool std::char_traits<wchar_t>::eq_int_type(const int_type&, const int_type&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (unsigned int) *__c1 == (unsigned int) *__c2
   >>>;


;; Function static constexpr std::char_traits<wchar_t>::int_type std::char_traits<wchar_t>::eof() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 4294967295
   >>>;


;; Function static constexpr std::char_traits<wchar_t>::int_type std::char_traits<wchar_t>::not_eof(const int_type&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::char_traits<wchar_t>::eq_int_type ((const int_type &) (const int_type *) __c, (const int_type &) &TARGET_EXPR <D.10076, std::char_traits<wchar_t>::eof ()>) ? 0 : (int_type) *__c>>
   >>>;


;; Function static void std::char_traits<char16_t>::assign(std::char_traits<char16_t>::char_type&, const char_type&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__c1 = (char_type) *__c2) >>>>>
   >>>;


;; Function static constexpr bool std::char_traits<char16_t>::eq(const char_type&, const char_type&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = *__c1 == *__c2
   >>>;


;; Function static constexpr bool std::char_traits<char16_t>::lt(const char_type&, const char_type&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = *__c1 < *__c2
   >>>;


;; Function static int std::char_traits<char16_t>::compare(const char_type*, const char_type*, std::size_t) (null)
;; enabled by -tree-original


{
  {
    size_t __i = 0;

    <<cleanup_point     size_t __i = 0;>>;
    while (1)
      {
        if (__i >= __n) goto <D.10162>;
        if (<<cleanup_point std::char_traits<char16_t>::lt ((const char_type &) (__s1 + (sizetype) (__i * 2)), (const char_type &) (__s2 + (sizetype) (__i * 2)))>>)
          {
            return <retval> = -1;
          }
        else
          {
            if (<<cleanup_point std::char_traits<char16_t>::lt ((const char_type &) (__s2 + (sizetype) (__i * 2)), (const char_type &) (__s1 + (sizetype) (__i * 2)))>>)
              {
                return <retval> = 1;
              }
          }
        <<cleanup_point (void)  ++__i>>;
      }
    <D.10162>:;
  }
  return <retval> = 0;
}


;; Function static std::size_t std::char_traits<char16_t>::length(const char_type*) (null)
;; enabled by -tree-original


{
  size_t __i = 0;

  <<cleanup_point   size_t __i = 0;>>;
  while (1)
    {
      if (<<cleanup_point !std::char_traits<char16_t>::eq ((const char_type &) (__s + (sizetype) (__i * 2)), (const char_type &) &TARGET_EXPR <D.10166, 0>)>>) (void) 0; else goto <D.10167>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void)  ++__i >>>>>;
    }
  <D.10167>:;
  return <retval> = __i;
}


;; Function static const char_type* std::char_traits<char16_t>::find(const char_type*, std::size_t, const char_type&) (null)
;; enabled by -tree-original


{
  {
    size_t __i = 0;

    <<cleanup_point     size_t __i = 0;>>;
    while (1)
      {
        if (__i >= __n) goto <D.10171>;
        if (<<cleanup_point std::char_traits<char16_t>::eq ((const char_type &) (__s + (sizetype) (__i * 2)), (const char_type &) (const char_type *) __a)>>)
          {
            return <retval> = __s + (sizetype) (__i * 2);
          }
        <<cleanup_point (void)  ++__i>>;
      }
    <D.10171>:;
  }
  return <retval> = 0B;
}


;; Function static std::char_traits<char16_t>::char_type* std::char_traits<char16_t>::move(std::char_traits<char16_t>::char_type*, const char_type*, std::size_t) (null)
;; enabled by -tree-original


if (__n == 0)
  {
    return <retval> = __s1;
  }
<<cleanup_point return <retval> = (char_type *) __builtin_memmove ((void *) __s1, (const void *) __s2, 2 * __n)>>;


;; Function static std::char_traits<char16_t>::char_type* std::char_traits<char16_t>::copy(std::char_traits<char16_t>::char_type*, const char_type*, std::size_t) (null)
;; enabled by -tree-original


if (__n == 0)
  {
    return <retval> = __s1;
  }
<<cleanup_point return <retval> = (char_type *) __builtin_memcpy ((void *) __s1, (const void *) __s2, 2 * __n)>>;


;; Function static std::char_traits<char16_t>::char_type* std::char_traits<char16_t>::assign(std::char_traits<char16_t>::char_type*, std::size_t, std::char_traits<char16_t>::char_type) (null)
;; enabled by -tree-original


{
  {
    size_t __i = 0;

    <<cleanup_point     size_t __i = 0;>>;
    while (1)
      {
        if (__i >= __n) goto <D.10177>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  std::char_traits<char16_t>::assign ((char_type &) (__s + (sizetype) (__i * 2)), (const char_type &) (const char_type *) &__a) >>>>>;
        <<cleanup_point (void)  ++__i>>;
      }
    <D.10177>:;
  }
  return <retval> = __s;
}


;; Function static constexpr std::char_traits<char16_t>::char_type std::char_traits<char16_t>::to_char_type(const int_type&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (char_type) *__c
   >>>;


;; Function static constexpr std::char_traits<char16_t>::int_type std::char_traits<char16_t>::to_int_type(const char_type&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (int_type) *__c
   >>>;


;; Function static constexpr bool std::char_traits<char16_t>::eq_int_type(const int_type&, const int_type&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (short unsigned int) *__c1 == (short unsigned int) *__c2
   >>>;


;; Function static constexpr std::char_traits<char16_t>::int_type std::char_traits<char16_t>::eof() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 65535
   >>>;


;; Function static constexpr std::char_traits<char16_t>::int_type std::char_traits<char16_t>::not_eof(const int_type&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::char_traits<char16_t>::eq_int_type ((const int_type &) (const int_type *) __c, (const int_type &) &TARGET_EXPR <D.10184, std::char_traits<char16_t>::eof ()>) ? 0 : (int_type) *__c>>
   >>>;


;; Function static void std::char_traits<char32_t>::assign(std::char_traits<char32_t>::char_type&, const char_type&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__c1 = (char_type) *__c2) >>>>>
   >>>;


;; Function static constexpr bool std::char_traits<char32_t>::eq(const char_type&, const char_type&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (unsigned int) *__c1 == (unsigned int) *__c2
   >>>;


;; Function static constexpr bool std::char_traits<char32_t>::lt(const char_type&, const char_type&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (unsigned int) *__c1 < (unsigned int) *__c2
   >>>;


;; Function static int std::char_traits<char32_t>::compare(const char_type*, const char_type*, std::size_t) (null)
;; enabled by -tree-original


{
  {
    size_t __i = 0;

    <<cleanup_point     size_t __i = 0;>>;
    while (1)
      {
        if (__i >= __n) goto <D.10248>;
        if (<<cleanup_point std::char_traits<char32_t>::lt ((const char_type &) (__s1 + (sizetype) (__i * 4)), (const char_type &) (__s2 + (sizetype) (__i * 4)))>>)
          {
            return <retval> = -1;
          }
        else
          {
            if (<<cleanup_point std::char_traits<char32_t>::lt ((const char_type &) (__s2 + (sizetype) (__i * 4)), (const char_type &) (__s1 + (sizetype) (__i * 4)))>>)
              {
                return <retval> = 1;
              }
          }
        <<cleanup_point (void)  ++__i>>;
      }
    <D.10248>:;
  }
  return <retval> = 0;
}


;; Function static std::size_t std::char_traits<char32_t>::length(const char_type*) (null)
;; enabled by -tree-original


{
  size_t __i = 0;

  <<cleanup_point   size_t __i = 0;>>;
  while (1)
    {
      if (<<cleanup_point !std::char_traits<char32_t>::eq ((const char_type &) (__s + (sizetype) (__i * 4)), (const char_type &) &TARGET_EXPR <D.10252, 0>)>>) (void) 0; else goto <D.10253>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void)  ++__i >>>>>;
    }
  <D.10253>:;
  return <retval> = __i;
}


;; Function static const char_type* std::char_traits<char32_t>::find(const char_type*, std::size_t, const char_type&) (null)
;; enabled by -tree-original


{
  {
    size_t __i = 0;

    <<cleanup_point     size_t __i = 0;>>;
    while (1)
      {
        if (__i >= __n) goto <D.10257>;
        if (<<cleanup_point std::char_traits<char32_t>::eq ((const char_type &) (__s + (sizetype) (__i * 4)), (const char_type &) (const char_type *) __a)>>)
          {
            return <retval> = __s + (sizetype) (__i * 4);
          }
        <<cleanup_point (void)  ++__i>>;
      }
    <D.10257>:;
  }
  return <retval> = 0B;
}


;; Function static std::char_traits<char32_t>::char_type* std::char_traits<char32_t>::move(std::char_traits<char32_t>::char_type*, const char_type*, std::size_t) (null)
;; enabled by -tree-original


if (__n == 0)
  {
    return <retval> = __s1;
  }
<<cleanup_point return <retval> = (char_type *) __builtin_memmove ((void *) __s1, (const void *) __s2, 4 * __n)>>;


;; Function static std::char_traits<char32_t>::char_type* std::char_traits<char32_t>::copy(std::char_traits<char32_t>::char_type*, const char_type*, std::size_t) (null)
;; enabled by -tree-original


if (__n == 0)
  {
    return <retval> = __s1;
  }
<<cleanup_point return <retval> = (char_type *) __builtin_memcpy ((void *) __s1, (const void *) __s2, 4 * __n)>>;


;; Function static std::char_traits<char32_t>::char_type* std::char_traits<char32_t>::assign(std::char_traits<char32_t>::char_type*, std::size_t, std::char_traits<char32_t>::char_type) (null)
;; enabled by -tree-original


{
  {
    size_t __i = 0;

    <<cleanup_point     size_t __i = 0;>>;
    while (1)
      {
        if (__i >= __n) goto <D.10263>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  std::char_traits<char32_t>::assign ((char_type &) (__s + (sizetype) (__i * 4)), (const char_type &) (const char_type *) &__a) >>>>>;
        <<cleanup_point (void)  ++__i>>;
      }
    <D.10263>:;
  }
  return <retval> = __s;
}


;; Function static constexpr std::char_traits<char32_t>::char_type std::char_traits<char32_t>::to_char_type(const int_type&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (char_type) *__c
   >>>;


;; Function static constexpr std::char_traits<char32_t>::int_type std::char_traits<char32_t>::to_int_type(const char_type&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (int_type) *__c
   >>>;


;; Function static constexpr bool std::char_traits<char32_t>::eq_int_type(const int_type&, const int_type&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (unsigned int) *__c1 == (unsigned int) *__c2
   >>>;


;; Function static constexpr std::char_traits<char32_t>::int_type std::char_traits<char32_t>::eof() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 4294967295
   >>>;


;; Function static constexpr std::char_traits<char32_t>::int_type std::char_traits<char32_t>::not_eof(const int_type&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::char_traits<char32_t>::eq_int_type ((const int_type &) (const int_type *) __c, (const int_type &) &TARGET_EXPR <D.10270, std::char_traits<char32_t>::eof ()>) ? 0 : (int_type) *__c>>
   >>>;


;; Function int std::__convert_from_v(__locale_struct* const&, char*, int, const char*, ...) (null)
;; enabled by -tree-original


{
  struct __locale_struct * __old;
  struct  __args[1];
  const int __ret;

    struct __locale_struct * __old;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__old = __gnu_cxx::__uselocale ((struct __locale_struct *) *__cloc)) >>>>>;
    struct  __args[1];
  <<cleanup_point <<< Unknown tree: expr_stmt
  __builtin_va_start ((struct  *) &__args, __fmt) >>>>>;
    const int __ret;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__ret = __builtin_vsnprintf (__out, (long unsigned int) __size, __fmt, (struct  *) &__args)) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  __builtin_va_end ((struct  *) &__args) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) __gnu_cxx::__uselocale (__old) >>>>>;
  return <retval> = (int) __ret;
}


;; Function unsigned int __bswap_32(unsigned int) (null)
;; enabled by -tree-original


return <retval> = __builtin_bswap32 (__bsx);


;; Function __uint64_t __bswap_64(__uint64_t) (null)
;; enabled by -tree-original


return <retval> = __builtin_bswap64 (__bsx);


;; Function __pthread_cleanup_class::__pthread_cleanup_class(void (*)(void*), void*) (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __pthread_cleanup_class *) this)->__cancel_routine = __fct) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __pthread_cleanup_class *) this)->__cancel_arg = __arg) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __pthread_cleanup_class *) this)->__do_it = 1) >>>>>;
}


;; Function __pthread_cleanup_class::~__pthread_cleanup_class() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    try
      {
        if (((struct __pthread_cleanup_class *) this)->__do_it != 0)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  ((struct __pthread_cleanup_class *) this)->__cancel_routine (((struct __pthread_cleanup_class *) this)->__cancel_arg) >>>>>;
          }
      }
    finally
      {
        *(struct 
        {
          void (*<Tcd>) (void *) __cancel_routine;
          void * __cancel_arg;
          int __do_it;
          int __cancel_type;
        } &) this = {CLOBBER};
      }
  }
  <D.11249>:;
   >>>;


;; Function void __pthread_cleanup_class::__setdoit(int) (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __pthread_cleanup_class *) this)->__do_it = __newval) >>>>>;


;; Function void __pthread_cleanup_class::__defer() (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) pthread_setcanceltype (0, &((struct __pthread_cleanup_class *) this)->__cancel_type) >>>>>;


;; Function void __pthread_cleanup_class::__restore() const (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) pthread_setcanceltype ((int) ((const struct __pthread_cleanup_class *) this)->__cancel_type, 0B) >>>>>;


;; Function int pthread_equal(pthread_t, pthread_t) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  return <retval> = __thread1 == __thread2
   >>>;


;; Function int __gthread_active_p() (null)
;; enabled by -tree-original


{
  static void * const __gthread_active_ptr = (void *) __gthrw___pthread_key_create;

  <<cleanup_point   static void * const __gthread_active_ptr = (void *) __gthrw___pthread_key_create;>>;
  return <retval> = (void *) __gthread_active_ptr != 0B;
}


;; Function int __gthread_create(__gthread_t*, void* (*)(void*), void*) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gthrw_pthread_create (__threadid, 0B, __func, __args)>>;


;; Function int __gthread_join(__gthread_t, void**) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gthrw_pthread_join (__threadid, __value_ptr)>>;


;; Function int __gthread_detach(__gthread_t) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gthrw_pthread_detach (__threadid)>>;


;; Function int __gthread_equal(__gthread_t, __gthread_t) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gthrw_pthread_equal (__t1, __t2)>>;


;; Function __gthread_t __gthread_self() (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gthrw_pthread_self ()>>;


;; Function int __gthread_yield() (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gthrw_sched_yield ()>>;


;; Function int __gthread_once(__gthread_once_t*, void (*)()) (null)
;; enabled by -tree-original


if (<<cleanup_point __gthread_active_p () != 0>>)
  {
    <<cleanup_point return <retval> = __gthrw_pthread_once (__once, __func)>>;
  }
else
  {
    return <retval> = -1;
  }


;; Function int __gthread_key_create(__gthread_key_t*, void (*)(void*)) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gthrw_pthread_key_create (__key, __dtor)>>;


;; Function int __gthread_key_delete(__gthread_key_t) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gthrw_pthread_key_delete (__key)>>;


;; Function void* __gthread_getspecific(__gthread_key_t) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gthrw_pthread_getspecific (__key)>>;


;; Function int __gthread_setspecific(__gthread_key_t, const void*) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gthrw_pthread_setspecific (__key, __ptr)>>;


;; Function void __gthread_mutex_init_function(__gthread_mutex_t*) (null)
;; enabled by -tree-original


if (<<cleanup_point __gthread_active_p () != 0>>)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) __gthrw_pthread_mutex_init (__mutex, 0B) >>>>>;
  }


;; Function int __gthread_mutex_destroy(__gthread_mutex_t*) (null)
;; enabled by -tree-original


if (<<cleanup_point __gthread_active_p () != 0>>)
  {
    <<cleanup_point return <retval> = __gthrw_pthread_mutex_destroy (__mutex)>>;
  }
else
  {
    return <retval> = 0;
  }


;; Function int __gthread_mutex_lock(__gthread_mutex_t*) (null)
;; enabled by -tree-original


if (<<cleanup_point __gthread_active_p () != 0>>)
  {
    <<cleanup_point return <retval> = __gthrw_pthread_mutex_lock (__mutex)>>;
  }
else
  {
    return <retval> = 0;
  }


;; Function int __gthread_mutex_trylock(__gthread_mutex_t*) (null)
;; enabled by -tree-original


if (<<cleanup_point __gthread_active_p () != 0>>)
  {
    <<cleanup_point return <retval> = __gthrw_pthread_mutex_trylock (__mutex)>>;
  }
else
  {
    return <retval> = 0;
  }


;; Function int __gthread_mutex_timedlock(__gthread_mutex_t*, const __gthread_time_t*) (null)
;; enabled by -tree-original


if (<<cleanup_point __gthread_active_p () != 0>>)
  {
    <<cleanup_point return <retval> = __gthrw_pthread_mutex_timedlock (__mutex, __abs_timeout)>>;
  }
else
  {
    return <retval> = 0;
  }


;; Function int __gthread_mutex_unlock(__gthread_mutex_t*) (null)
;; enabled by -tree-original


if (<<cleanup_point __gthread_active_p () != 0>>)
  {
    <<cleanup_point return <retval> = __gthrw_pthread_mutex_unlock (__mutex)>>;
  }
else
  {
    return <retval> = 0;
  }


;; Function int __gthread_recursive_mutex_lock(__gthread_recursive_mutex_t*) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gthread_mutex_lock (__mutex)>>;


;; Function int __gthread_recursive_mutex_trylock(__gthread_recursive_mutex_t*) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gthread_mutex_trylock (__mutex)>>;


;; Function int __gthread_recursive_mutex_timedlock(__gthread_recursive_mutex_t*, const __gthread_time_t*) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gthread_mutex_timedlock (__mutex, __abs_timeout)>>;


;; Function int __gthread_recursive_mutex_unlock(__gthread_recursive_mutex_t*) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gthread_mutex_unlock (__mutex)>>;


;; Function int __gthread_recursive_mutex_destroy(__gthread_recursive_mutex_t*) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gthread_mutex_destroy (__mutex)>>;


;; Function int __gthread_cond_broadcast(__gthread_cond_t*) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gthrw_pthread_cond_broadcast (__cond)>>;


;; Function int __gthread_cond_signal(__gthread_cond_t*) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gthrw_pthread_cond_signal (__cond)>>;


;; Function int __gthread_cond_wait(__gthread_cond_t*, __gthread_mutex_t*) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gthrw_pthread_cond_wait (__cond, __mutex)>>;


;; Function int __gthread_cond_timedwait(__gthread_cond_t*, __gthread_mutex_t*, const __gthread_time_t*) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gthrw_pthread_cond_timedwait (__cond, __mutex, __abs_timeout)>>;


;; Function int __gthread_cond_wait_recursive(__gthread_cond_t*, __gthread_recursive_mutex_t*) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gthread_cond_wait (__cond, __mutex)>>;


;; Function int __gthread_cond_destroy(__gthread_cond_t*) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gthrw_pthread_cond_destroy (__cond)>>;


;; Function _Atomic_word __gnu_cxx::__exchange_and_add(volatile _Atomic_word*, int) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (int) __atomic_fetch_add_4 ((volatile void *) __mem, (unsigned int) __val, 4)>>;


;; Function void __gnu_cxx::__atomic_add(volatile _Atomic_word*, int) (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (int) __atomic_fetch_add_4 ((volatile void *) __mem, (unsigned int) __val, 4) >>>>>;


;; Function _Atomic_word __gnu_cxx::__exchange_and_add_single(_Atomic_word*, int) (null)
;; enabled by -tree-original


{
  _Atomic_word __result = *__mem;

    _Atomic_word __result = *__mem;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__mem = *__mem + __val) >>>>>;
  return <retval> = __result;
}


;; Function void __gnu_cxx::__atomic_add_single(_Atomic_word*, int) (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__mem = *__mem + __val) >>>>>;


;; Function _Atomic_word __gnu_cxx::__exchange_and_add_dispatch(_Atomic_word*, int) (null)
;; enabled by -tree-original


if (<<cleanup_point __gthread_active_p () != 0>>)
  {
    <<cleanup_point return <retval> = __gnu_cxx::__exchange_and_add ((volatile _Atomic_word *) __mem, __val)>>;
  }
else
  {
    <<cleanup_point return <retval> = __gnu_cxx::__exchange_and_add_single (__mem, __val)>>;
  }


;; Function void __gnu_cxx::__atomic_add_dispatch(_Atomic_word*, int) (null)
;; enabled by -tree-original


if (<<cleanup_point __gthread_active_p () != 0>>)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::__atomic_add ((volatile _Atomic_word *) __mem, __val) >>>>>;
  }
else
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::__atomic_add_single (__mem, __val) >>>>>;
  }


;; Function std::bad_alloc::bad_alloc() (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::exception::exception (&((struct bad_alloc *) this)->D.11672) >>>>>;
    try
      {
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct bad_alloc *) this)->D.11672._vptr.exception = &_ZTVSt9bad_alloc + 16) >>>>>;
      }
    catch
      {
        std::exception::~exception (&((struct bad_alloc *) this)->D.11672);
      }
  }
   >>>;


;; Function std::bad_array_new_length::bad_array_new_length() (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::bad_alloc::bad_alloc (&((struct bad_array_new_length *) this)->D.11701) >>>>>;
    try
      {
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct bad_array_new_length *) this)->D.11701.D.11672._vptr.exception = &_ZTVSt20bad_array_new_length + 16) >>>>>;
      }
    catch
      {
        std::bad_alloc::~bad_alloc (&((struct bad_array_new_length *) this)->D.11701);
      }
  }
   >>>;


;; Function void* operator new(std::size_t, void*) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = __p
   >>>;


;; Function void* operator new [](std::size_t, void*) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = __p
   >>>;


;; Function void operator delete(void*, void*) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  
   >>>;


;; Function void operator delete [](void*, void*) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  
   >>>;


;; Function int atoi(const char*) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  <<cleanup_point return <retval> = (int) strtol (__nptr, 0B, 10)>>
   >>>;


;; Function long int atol(const char*) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  <<cleanup_point return <retval> = strtol (__nptr, 0B, 10)>>
   >>>;


;; Function long long int atoll(const char*) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  <<cleanup_point return <retval> = strtoll (__nptr, 0B, 10)>>
   >>>;


;; Function unsigned int gnu_dev_major(long long unsigned int) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  return <retval> = (unsigned int) (__dev >> 8) & 4095 | (unsigned int) (__dev >> 32) & 4294963200
   >>>;


;; Function unsigned int gnu_dev_minor(long long unsigned int) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  return <retval> = (unsigned int) __dev & 255 | (unsigned int) (__dev >> 12) & 4294967040
   >>>;


;; Function long long unsigned int gnu_dev_makedev(unsigned int, unsigned int) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  return <retval> = ((long long unsigned int) (__minor & 255 | (__major & 4095) << 8) | ((long long unsigned int) __minor & 4294967040) << 12) | ((long long unsigned int) __major & 4294963200) << 32
   >>>;


;; Function void* bsearch(const void*, const void*, size_t, size_t, __compar_fn_t) (null)
;; enabled by -tree-original


{
  size_t __l;
  size_t __u;
  size_t __idx;
  const void * __p;
  int __comparison;

    size_t __l;
    size_t __u;
    size_t __idx;
    const void * __p;
    int __comparison;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__l = 0) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__u = __nmemb) >>>>>;
  while (1)
    {
      if (__l >= __u) goto <D.16380>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__idx = (__l + __u) / 2) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__p = __base + (sizetype) (__idx * __size)) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__comparison = __compar (__key, __p)) >>>>>;
      if (__comparison < 0)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__u = __idx) >>>>>;
        }
      else
        {
          if (__comparison > 0)
            {
              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__l = __idx + 1) >>>>>;
            }
          else
            {
              return <retval> = (void *) __p;
            }
        }
    }
  <D.16380>:;
  return <retval> = 0B;
}


;; Function double atof(const char*) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  <<cleanup_point return <retval> = strtod (__nptr, 0B)>>
   >>>;


;; Function long int std::abs(long int) (null)
;; enabled by -tree-original


return <retval> = ABS_EXPR <__i>;


;; Function ldiv_t std::div(long int, long int) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = TARGET_EXPR <D.16548, ldiv (__i, __j)>>>;


;; Function long long int std::abs(long long int) (null)
;; enabled by -tree-original


return <retval> = ABS_EXPR <__x>;


;; Function lldiv_t __gnu_cxx::div(long long int, long long int) (null)
;; enabled by -tree-original


{
  struct lldiv_t __q;

    struct lldiv_t __q;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__q.quot = __n / __d) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__q.rem = __n % __d) >>>>>;
  <<cleanup_point return <retval> = TARGET_EXPR <D.16626, __q>>>;
}


;; Function int vprintf(const char*, __va_list_tag*) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = vfprintf (stdout, __fmt, __arg)>>;


;; Function int getchar() (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = _IO_getc (stdin)>>;


;; Function int fgetc_unlocked(FILE*) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __builtin_expect ((*(struct FILE * &) &__fp)->_IO_read_ptr >= (*(struct FILE * &) &__fp)->_IO_read_end, 0) != 0 ? __uflow (__fp) : (int) *(unsigned char *) (*(struct FILE * &) &__fp)->_IO_read_ptr++ >>;


;; Function int getc_unlocked(FILE*) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __builtin_expect ((*(struct FILE * &) &__fp)->_IO_read_ptr >= (*(struct FILE * &) &__fp)->_IO_read_end, 0) != 0 ? __uflow (__fp) : (int) *(unsigned char *) (*(struct FILE * &) &__fp)->_IO_read_ptr++ >>;


;; Function int getchar_unlocked() (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __builtin_expect ((*(struct _IO_FILE * &) &stdin)->_IO_read_ptr >= (*(struct _IO_FILE * &) &stdin)->_IO_read_end, 0) != 0 ? __uflow (stdin) : (int) *(unsigned char *) (*(struct _IO_FILE * &) &stdin)->_IO_read_ptr++ >>;


;; Function int putchar(int) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = _IO_putc (__c, stdout)>>;


;; Function int fputc_unlocked(int, FILE*) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __builtin_expect ((*(struct FILE * &) &__stream)->_IO_write_ptr >= (*(struct FILE * &) &__stream)->_IO_write_end, 0) != 0 ? __overflow (__stream, *(int &) &__c & 255) : (int) (unsigned char) (*(*(struct FILE * &) &__stream)->_IO_write_ptr++  = (char) *(int &) &__c)>>;


;; Function int putc_unlocked(int, FILE*) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __builtin_expect ((*(struct FILE * &) &__stream)->_IO_write_ptr >= (*(struct FILE * &) &__stream)->_IO_write_end, 0) != 0 ? __overflow (__stream, *(int &) &__c & 255) : (int) (unsigned char) (*(*(struct FILE * &) &__stream)->_IO_write_ptr++  = (char) *(int &) &__c)>>;


;; Function int putchar_unlocked(int) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __builtin_expect ((*(struct _IO_FILE * &) &stdout)->_IO_write_ptr >= (*(struct _IO_FILE * &) &stdout)->_IO_write_end, 0) != 0 ? __overflow (stdout, *(int &) &__c & 255) : (int) (unsigned char) (*(*(struct _IO_FILE * &) &stdout)->_IO_write_ptr++  = (char) *(int &) &__c)>>;


;; Function __ssize_t getline(char**, size_t*, FILE*) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __getdelim (__lineptr, __n, 10, __stream)>>;


;; Function int feof_unlocked(FILE*) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  return <retval> = ((*(struct FILE * &) &__stream)->_flags & 16) != 0
   >>>;


;; Function int ferror_unlocked(FILE*) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  return <retval> = ((*(struct FILE * &) &__stream)->_flags & 32) != 0
   >>>;


;; Function int std::__cxx11::stoi(const string&, std::size_t*, int) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gnu_cxx::__stoa<long int, int, char, int> (strtol, (const char *) "stoi", std::__cxx11::basic_string<char>::c_str ((const struct string *) __str), __idx, __base)>>;


;; Function long int std::__cxx11::stol(const string&, std::size_t*, int) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gnu_cxx::__stoa<long int, long int, char, int> (strtol, (const char *) "stol", std::__cxx11::basic_string<char>::c_str ((const struct string *) __str), __idx, __base)>>;


;; Function long unsigned int std::__cxx11::stoul(const string&, std::size_t*, int) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gnu_cxx::__stoa<long unsigned int, long unsigned int, char, int> (strtoul, (const char *) "stoul", std::__cxx11::basic_string<char>::c_str ((const struct string *) __str), __idx, __base)>>;


;; Function long long int std::__cxx11::stoll(const string&, std::size_t*, int) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gnu_cxx::__stoa<long long int, long long int, char, int> (strtoll, (const char *) "stoll", std::__cxx11::basic_string<char>::c_str ((const struct string *) __str), __idx, __base)>>;


;; Function long long unsigned int std::__cxx11::stoull(const string&, std::size_t*, int) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gnu_cxx::__stoa<long long unsigned int, long long unsigned int, char, int> (strtoull, (const char *) "stoull", std::__cxx11::basic_string<char>::c_str ((const struct string *) __str), __idx, __base)>>;


;; Function float std::__cxx11::stof(const string&, std::size_t*) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gnu_cxx::__stoa<float, float, char> (strtof, (const char *) "stof", std::__cxx11::basic_string<char>::c_str ((const struct string *) __str), __idx)>>;


;; Function double std::__cxx11::stod(const string&, std::size_t*) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gnu_cxx::__stoa<double, double, char> (strtod, (const char *) "stod", std::__cxx11::basic_string<char>::c_str ((const struct string *) __str), __idx)>>;


;; Function long double std::__cxx11::stold(const string&, std::size_t*) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gnu_cxx::__stoa<long double, long double, char> (strtold, (const char *) "stold", std::__cxx11::basic_string<char>::c_str ((const struct string *) __str), __idx)>>;


;; Function std::__cxx11::string std::__cxx11::to_string(int) (null)
;; enabled by -tree-original


<<cleanup_point return *<retval> = TARGET_EXPR <D.18413, <<< Unknown tree: aggr_init_expr
  7
  __to_xstring
  D.18413
  vsnprintf
  4 * 4
  (const char *) "%d"
  __val >>>>>>;


;; Function std::__cxx11::string std::__cxx11::to_string(unsigned int) (null)
;; enabled by -tree-original


<<cleanup_point return *<retval> = TARGET_EXPR <D.18479, <<< Unknown tree: aggr_init_expr
  7
  __to_xstring
  D.18479
  vsnprintf
  4 * 4
  (const char *) "%u"
  __val >>>>>>;


;; Function std::__cxx11::string std::__cxx11::to_string(long int) (null)
;; enabled by -tree-original


<<cleanup_point return *<retval> = TARGET_EXPR <D.18483, <<< Unknown tree: aggr_init_expr
  7
  __to_xstring
  D.18483
  vsnprintf
  8 * 4
  (const char *) "%ld"
  __val >>>>>>;


;; Function std::__cxx11::string std::__cxx11::to_string(long unsigned int) (null)
;; enabled by -tree-original


<<cleanup_point return *<retval> = TARGET_EXPR <D.18487, <<< Unknown tree: aggr_init_expr
  7
  __to_xstring
  D.18487
  vsnprintf
  8 * 4
  (const char *) "%lu"
  __val >>>>>>;


;; Function std::__cxx11::string std::__cxx11::to_string(long long int) (null)
;; enabled by -tree-original


<<cleanup_point return *<retval> = TARGET_EXPR <D.18491, <<< Unknown tree: aggr_init_expr
  7
  __to_xstring
  D.18491
  vsnprintf
  8 * 4
  (const char *) "%lld"
  __val >>>>>>;


;; Function std::__cxx11::string std::__cxx11::to_string(long long unsigned int) (null)
;; enabled by -tree-original


<<cleanup_point return *<retval> = TARGET_EXPR <D.18495, <<< Unknown tree: aggr_init_expr
  7
  __to_xstring
  D.18495
  vsnprintf
  8 * 4
  (const char *) "%llu"
  __val >>>>>>;


;; Function std::__cxx11::string std::__cxx11::to_string(float) (null)
;; enabled by -tree-original


{
  const int __n = 58;

  <<cleanup_point   const int __n = 58;>>;
  <<cleanup_point return *<retval> = TARGET_EXPR <D.18526, <<< Unknown tree: aggr_init_expr
  7
  __to_xstring
  D.18526
  vsnprintf
  58
  (const char *) "%f"
  (double) __val >>>>>>;
}


;; Function std::__cxx11::string std::__cxx11::to_string(double) (null)
;; enabled by -tree-original


{
  const int __n = 328;

  <<cleanup_point   const int __n = 328;>>;
  <<cleanup_point return *<retval> = TARGET_EXPR <D.18557, <<< Unknown tree: aggr_init_expr
  7
  __to_xstring
  D.18557
  vsnprintf
  328
  (const char *) "%f"
  __val >>>>>>;
}


;; Function std::__cxx11::string std::__cxx11::to_string(long double) (null)
;; enabled by -tree-original


{
  const int __n = 4952;

  <<cleanup_point   const int __n = 4952;>>;
  <<cleanup_point return *<retval> = TARGET_EXPR <D.18588, <<< Unknown tree: aggr_init_expr
  7
  __to_xstring
  D.18588
  vsnprintf
  4952
  (const char *) "%Lf"
  __val >>>>>>;
}


;; Function int std::__cxx11::stoi(const wstring&, std::size_t*, int) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gnu_cxx::__stoa<long int, int, wchar_t, int> (wcstol, (const char *) "stoi", std::__cxx11::basic_string<wchar_t>::c_str ((const struct wstring *) __str), __idx, __base)>>;


;; Function long int std::__cxx11::stol(const wstring&, std::size_t*, int) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gnu_cxx::__stoa<long int, long int, wchar_t, int> (wcstol, (const char *) "stol", std::__cxx11::basic_string<wchar_t>::c_str ((const struct wstring *) __str), __idx, __base)>>;


;; Function long unsigned int std::__cxx11::stoul(const wstring&, std::size_t*, int) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gnu_cxx::__stoa<long unsigned int, long unsigned int, wchar_t, int> (wcstoul, (const char *) "stoul", std::__cxx11::basic_string<wchar_t>::c_str ((const struct wstring *) __str), __idx, __base)>>;


;; Function long long int std::__cxx11::stoll(const wstring&, std::size_t*, int) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gnu_cxx::__stoa<long long int, long long int, wchar_t, int> (wcstoll, (const char *) "stoll", std::__cxx11::basic_string<wchar_t>::c_str ((const struct wstring *) __str), __idx, __base)>>;


;; Function long long unsigned int std::__cxx11::stoull(const wstring&, std::size_t*, int) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gnu_cxx::__stoa<long long unsigned int, long long unsigned int, wchar_t, int> (wcstoull, (const char *) "stoull", std::__cxx11::basic_string<wchar_t>::c_str ((const struct wstring *) __str), __idx, __base)>>;


;; Function float std::__cxx11::stof(const wstring&, std::size_t*) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gnu_cxx::__stoa<float, float, wchar_t> (wcstof, (const char *) "stof", std::__cxx11::basic_string<wchar_t>::c_str ((const struct wstring *) __str), __idx)>>;


;; Function double std::__cxx11::stod(const wstring&, std::size_t*) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gnu_cxx::__stoa<double, double, wchar_t> (wcstod, (const char *) "stod", std::__cxx11::basic_string<wchar_t>::c_str ((const struct wstring *) __str), __idx)>>;


;; Function long double std::__cxx11::stold(const wstring&, std::size_t*) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gnu_cxx::__stoa<long double, long double, wchar_t> (wcstold, (const char *) "stold", std::__cxx11::basic_string<wchar_t>::c_str ((const struct wstring *) __str), __idx)>>;


;; Function std::__cxx11::wstring std::__cxx11::to_wstring(int) (null)
;; enabled by -tree-original


<<cleanup_point return *<retval> = TARGET_EXPR <D.19782, <<< Unknown tree: aggr_init_expr
  7
  __to_xstring
  D.19782
  vswprintf
  4 * 4
  (const wchar_t *) "%"
  __val >>>>>>;


;; Function std::__cxx11::wstring std::__cxx11::to_wstring(unsigned int) (null)
;; enabled by -tree-original


<<cleanup_point return *<retval> = TARGET_EXPR <D.19848, <<< Unknown tree: aggr_init_expr
  7
  __to_xstring
  D.19848
  vswprintf
  4 * 4
  (const wchar_t *) "%"
  __val >>>>>>;


;; Function std::__cxx11::wstring std::__cxx11::to_wstring(long int) (null)
;; enabled by -tree-original


<<cleanup_point return *<retval> = TARGET_EXPR <D.19852, <<< Unknown tree: aggr_init_expr
  7
  __to_xstring
  D.19852
  vswprintf
  8 * 4
  (const wchar_t *) "%"
  __val >>>>>>;


;; Function std::__cxx11::wstring std::__cxx11::to_wstring(long unsigned int) (null)
;; enabled by -tree-original


<<cleanup_point return *<retval> = TARGET_EXPR <D.19856, <<< Unknown tree: aggr_init_expr
  7
  __to_xstring
  D.19856
  vswprintf
  8 * 4
  (const wchar_t *) "%"
  __val >>>>>>;


;; Function std::__cxx11::wstring std::__cxx11::to_wstring(long long int) (null)
;; enabled by -tree-original


<<cleanup_point return *<retval> = TARGET_EXPR <D.19860, <<< Unknown tree: aggr_init_expr
  7
  __to_xstring
  D.19860
  vswprintf
  8 * 4
  (const wchar_t *) "%"
  __val >>>>>>;


;; Function std::__cxx11::wstring std::__cxx11::to_wstring(long long unsigned int) (null)
;; enabled by -tree-original


<<cleanup_point return *<retval> = TARGET_EXPR <D.19864, <<< Unknown tree: aggr_init_expr
  7
  __to_xstring
  D.19864
  vswprintf
  8 * 4
  (const wchar_t *) "%"
  __val >>>>>>;


;; Function std::__cxx11::wstring std::__cxx11::to_wstring(float) (null)
;; enabled by -tree-original


{
  const int __n = 58;

  <<cleanup_point   const int __n = 58;>>;
  <<cleanup_point return *<retval> = TARGET_EXPR <D.19869, <<< Unknown tree: aggr_init_expr
  7
  __to_xstring
  D.19869
  vswprintf
  58
  (const wchar_t *) "%"
  (double) __val >>>>>>;
}


;; Function std::__cxx11::wstring std::__cxx11::to_wstring(double) (null)
;; enabled by -tree-original


{
  const int __n = 328;

  <<cleanup_point   const int __n = 328;>>;
  <<cleanup_point return *<retval> = TARGET_EXPR <D.19874, <<< Unknown tree: aggr_init_expr
  7
  __to_xstring
  D.19874
  vswprintf
  328
  (const wchar_t *) "%"
  __val >>>>>>;
}


;; Function std::__cxx11::wstring std::__cxx11::to_wstring(long double) (null)
;; enabled by -tree-original


{
  const int __n = 4952;

  <<cleanup_point   const int __n = 4952;>>;
  <<cleanup_point return *<retval> = TARGET_EXPR <D.19879, <<< Unknown tree: aggr_init_expr
  7
  __to_xstring
  D.19879
  vswprintf
  4952
  (const wchar_t *) "%"
  __val >>>>>>;
}


;; Function std::size_t std::hash<bool>::operator()(bool) const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (size_t) __val
   >>>;


;; Function std::size_t std::hash<char>::operator()(char) const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (size_t) __val
   >>>;


;; Function std::size_t std::hash<signed char>::operator()(signed char) const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (size_t) __val
   >>>;


;; Function std::size_t std::hash<unsigned char>::operator()(unsigned char) const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (size_t) __val
   >>>;


;; Function std::size_t std::hash<wchar_t>::operator()(wchar_t) const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (size_t) __val
   >>>;


;; Function std::size_t std::hash<char16_t>::operator()(char16_t) const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (size_t) __val
   >>>;


;; Function std::size_t std::hash<char32_t>::operator()(char32_t) const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (size_t) __val
   >>>;


;; Function std::size_t std::hash<short int>::operator()(short int) const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (size_t) __val
   >>>;


;; Function std::size_t std::hash<int>::operator()(int) const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (size_t) __val
   >>>;


;; Function std::size_t std::hash<long int>::operator()(long int) const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (size_t) __val
   >>>;


;; Function std::size_t std::hash<long long int>::operator()(long long int) const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (size_t) __val
   >>>;


;; Function std::size_t std::hash<short unsigned int>::operator()(short unsigned int) const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (size_t) __val
   >>>;


;; Function std::size_t std::hash<unsigned int>::operator()(unsigned int) const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (size_t) __val
   >>>;


;; Function std::size_t std::hash<long unsigned int>::operator()(long unsigned int) const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = __val
   >>>;


;; Function std::size_t std::hash<long long unsigned int>::operator()(long long unsigned int) const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (size_t) __val
   >>>;


;; Function static std::size_t std::_Hash_impl::hash(const void*, std::size_t, std::size_t) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = std::_Hash_bytes (__ptr, __clength, __seed)>>;


;; Function static std::size_t std::_Fnv_hash_impl::hash(const void*, std::size_t, std::size_t) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = std::_Fnv_hash_bytes (__ptr, __clength, __seed)>>;


;; Function std::size_t std::hash<float>::operator()(float) const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = __val != 0.0 ? std::_Hash_impl::hash<float> ((const float &) (const float *) &__val) : 0>>
   >>>;


;; Function std::size_t std::hash<double>::operator()(double) const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = __val != 0.0 ? std::_Hash_impl::hash<double> ((const double &) (const double *) &__val) : 0>>
   >>>;


;; Function std::size_t std::hash<std::__cxx11::basic_string<char> >::operator()(const string&) const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::_Hash_impl::hash ((const void *) std::__cxx11::basic_string<char>::data ((const struct string *) __s), std::__cxx11::basic_string<char>::length ((const struct string *) __s), 3339675911)>>
   >>>;


;; Function std::size_t std::hash<std::__cxx11::basic_string<wchar_t> >::operator()(const wstring&) const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::_Hash_impl::hash ((const void *) std::__cxx11::basic_string<wchar_t>::data ((const struct wstring *) __s), std::__cxx11::basic_string<wchar_t>::length ((const struct wstring *) __s) * 4, 3339675911)>>
   >>>;


;; Function std::size_t std::hash<std::__cxx11::basic_string<char16_t> >::operator()(const u16string&) const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::_Hash_impl::hash ((const void *) std::__cxx11::basic_string<char16_t>::data ((const struct u16string *) __s), std::__cxx11::basic_string<char16_t>::length ((const struct u16string *) __s) * 2, 3339675911)>>
   >>>;


;; Function std::size_t std::hash<std::__cxx11::basic_string<char32_t> >::operator()(const u32string&) const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::_Hash_impl::hash ((const void *) std::__cxx11::basic_string<char32_t>::data ((const struct u32string *) __s), std::__cxx11::basic_string<char32_t>::length ((const struct u32string *) __s) * 4, 3339675911)>>
   >>>;


;; Function std::__cxx11::basic_string<char> std::literals::string_literals::operator""s(const char*, std::size_t) (null)
;; enabled by -tree-original


<<cleanup_point return *<retval> = TARGET_EXPR <D.22764, <<< Unknown tree: aggr_init_expr
  7
  __comp_ctor 
  D.22764
  (struct basic_string *) <<< Unknown tree: void_cst >>>
  __str
  __len
  (const struct allocator &) (const struct allocator *) &TARGET_EXPR <D.22763, <<< Unknown tree: aggr_init_expr
  4
  __comp_ctor 
  D.22763
  (struct allocator *) <<< Unknown tree: void_cst >>> >>>> >>>>>>;


;; Function std::__cxx11::basic_string<wchar_t> std::literals::string_literals::operator""s(const wchar_t*, std::size_t) (null)
;; enabled by -tree-original


<<cleanup_point return *<retval> = TARGET_EXPR <D.22771, <<< Unknown tree: aggr_init_expr
  7
  __comp_ctor 
  D.22771
  (struct basic_string *) <<< Unknown tree: void_cst >>>
  __str
  __len
  (const struct allocator &) (const struct allocator *) &TARGET_EXPR <D.22770, <<< Unknown tree: aggr_init_expr
  4
  __comp_ctor 
  D.22770
  (struct allocator *) <<< Unknown tree: void_cst >>> >>>> >>>>>>;


;; Function std::__cxx11::basic_string<char16_t> std::literals::string_literals::operator""s(const char16_t*, std::size_t) (null)
;; enabled by -tree-original


<<cleanup_point return *<retval> = TARGET_EXPR <D.22831, <<< Unknown tree: aggr_init_expr
  7
  __comp_ctor 
  D.22831
  (struct basic_string *) <<< Unknown tree: void_cst >>>
  __str
  __len
  (const struct allocator &) (const struct allocator *) &TARGET_EXPR <D.22830, <<< Unknown tree: aggr_init_expr
  4
  __comp_ctor 
  D.22830
  (struct allocator *) <<< Unknown tree: void_cst >>> >>>> >>>>>>;


;; Function std::__cxx11::basic_string<char32_t> std::literals::string_literals::operator""s(const char32_t*, std::size_t) (null)
;; enabled by -tree-original


<<cleanup_point return *<retval> = TARGET_EXPR <D.22900, <<< Unknown tree: aggr_init_expr
  7
  __comp_ctor 
  D.22900
  (struct basic_string *) <<< Unknown tree: void_cst >>>
  __str
  __len
  (const struct allocator &) (const struct allocator *) &TARGET_EXPR <D.22899, <<< Unknown tree: aggr_init_expr
  4
  __comp_ctor 
  D.22899
  (struct allocator *) <<< Unknown tree: void_cst >>> >>>> >>>>>>;


;; Function std::locale::locale(const string&) (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::locale::locale (this, std::__cxx11::basic_string<char>::c_str ((const struct string *) __s)) >>>>>;
  try
    {
      
    }
  catch
    {
      std::locale::~locale (this);
    }
}


;; Function std::locale::locale(const std::locale&, const string&, std::locale::category) (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::locale::locale (this, (const struct locale &) (const struct locale *) __base, std::__cxx11::basic_string<char>::c_str ((const struct string *) __s), __cat) >>>>>;
  try
    {
      
    }
  catch
    {
      std::locale::~locale (this);
    }
}


;; Function bool std::locale::operator!=(const std::locale&) const (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  <<cleanup_point return <retval> = !std::locale::operator== (this, (const struct locale &) (const struct locale *) __other)>>
   >>>;


;; Function std::locale::facet::facet(std::size_t) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct facet *) this)->_vptr.facet = &_ZTVNSt6locale5facetE + 16) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct facet *) this)->_M_refcount = __refs != 0 ? 1 : 0) >>>>>;
  }
   >>>;


;; Function void std::locale::facet::_M_add_reference() const (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::__atomic_add_dispatch (&((const struct facet *) this)->_M_refcount, 1) >>>>>
   >>>;


;; Function void std::locale::facet::_M_remove_reference() const (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  if (<<cleanup_point __gnu_cxx::__exchange_and_add_dispatch (&((const struct facet *) this)->_M_refcount, -1) == 1>>)
    {
      <<< Unknown tree: try_block
  <<cleanup_point <<< Unknown tree: expr_stmt
  if ((struct facet *) this != 0B)
    {
      OBJ_TYPE_REF(*(((struct facet *) this)->_vptr.facet + 8);(struct facet)(struct facet *) this->1) ((struct facet *) this);
    }
  else
    {
      <<< Unknown tree: void_cst >>>
    } >>>>>
  <<< Unknown tree: handler
  
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) __cxa_begin_catch (__builtin_eh_pointer (0)) >>>>>;
    }
  finally
    {
      __cxa_end_catch ();
    } >>> >>>;
    }
   >>>;


;; Function std::locale::id::id() (null)
;; enabled by -tree-original


{
  
}


;; Function void std::locale::_Impl::_M_add_reference() (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::__atomic_add_dispatch (&((struct _Impl *) this)->_M_refcount, 1) >>>>>
   >>>;


;; Function void std::locale::_Impl::_M_remove_reference() (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  if (<<cleanup_point __gnu_cxx::__exchange_and_add_dispatch (&((struct _Impl *) this)->_M_refcount, -1) == 1>>)
    {
      <<< Unknown tree: try_block
  <<cleanup_point <<< Unknown tree: expr_stmt
  if ((struct _Impl *) this != 0B)
    {
      std::locale::_Impl::~_Impl (this);, operator delete ((void *) this, 40);;
    }
  else
    {
      <<< Unknown tree: void_cst >>>
    } >>>>>
  <<< Unknown tree: handler
  
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) __cxa_begin_catch (__builtin_eh_pointer (0)) >>>>>;
    }
  finally
    {
      __cxa_end_catch ();
    } >>> >>>;
    }
   >>>;


;; Function bool std::locale::_Impl::_M_check_same_name() (null)
;; enabled by -tree-original


{
  bool __ret = 1;

  <<cleanup_point   bool __ret = 1;>>;
  {
    if (*(((struct _Impl *) this)->_M_names + 8) != 0B)
      {
        {
          {
            size_t __i = 0;

            <<cleanup_point             size_t __i = 0;>>;
            while (1)
              {
                if (__i > 10 || !__ret) goto <D.23902>;
                <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__ret = __builtin_strcmp ((const char *) *(((struct _Impl *) this)->_M_names + (sizetype) (__i * 8)), (const char *) *(((struct _Impl *) this)->_M_names + ((sizetype) __i + 1) * 8)) == 0) >>>>>;
                <<cleanup_point (void)  ++__i>>;
              }
            <D.23902>:;
          }
        }
      }
  }
  return <retval> = __ret;
}


;; Function constexpr bool std::less<_Tp>::operator()(const _Tp&, const _Tp&) const [with _Tp = const std::_V2::error_category*] (null)
;; enabled by -tree-original


return <retval> = (const struct error_category *) *__x < (const struct error_category *) *__y;


;; Function bool std::_V2::error_category::operator<(const std::_V2::error_category&) const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::less<const std::_V2::error_category*>::operator() (&TARGET_EXPR <D.25073, {}>, (const struct error_category * const &) &TARGET_EXPR <D.25083, (const struct error_category *) this>, (const struct error_category * const &) &TARGET_EXPR <D.25084, (const struct error_category *) __other>)>>
   >>>;


;; Function bool std::_V2::error_category::operator==(const std::_V2::error_category&) const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (const struct error_category *) this == (const struct error_category *) __other
   >>>;


;; Function bool std::_V2::error_category::operator!=(const std::_V2::error_category&) const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (const struct error_category *) this != (const struct error_category *) __other
   >>>;


;; Function std::error_code::error_code() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct error_code *) this)->_M_value = 0) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct error_code *) this)->_M_cat = (const struct error_category *) std::_V2::system_category ()) >>>>>;
  }
   >>>;


;; Function std::error_code::error_code(int, const std::_V2::error_category&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct error_code *) this)->_M_value = __v) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct error_code *) this)->_M_cat = (const struct error_category *) __cat) >>>>>;
  }
   >>>;


;; Function void std::error_code::assign(int, const std::_V2::error_category&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct error_code *) this)->_M_value = __v) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct error_code *) this)->_M_cat = (const struct error_category *) __cat) >>>>>;
   >>>;


;; Function void std::error_code::clear() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::error_code::assign (this, 0, (const struct error_category &) (const struct error_category *) std::_V2::system_category ()) >>>>>
   >>>;


;; Function int std::error_code::value() const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (int) ((const struct error_code *) this)->_M_value
   >>>;


;; Function const std::_V2::error_category& std::error_code::category() const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (const struct error_category &) (const struct error_category *) ((const struct error_code *) this)->_M_cat
   >>>;


;; Function std::__cxx11::string std::error_code::message() const (null)
;; enabled by -tree-original


<<cleanup_point return *<retval> = TARGET_EXPR <D.25169, <<< Unknown tree: aggr_init_expr
  5
  OBJ_TYPE_REF(*((SAVE_EXPR <(const struct error_category *) std::error_code::category (this)>)->_vptr.error_category + 32);(const struct error_category)SAVE_EXPR <(const struct error_category *) std::error_code::category (this)>->4)
  D.25169
  SAVE_EXPR <(const struct error_category *) std::error_code::category (this)>
  std::error_code::value (this) >>>>>>;


;; Function std::error_code::operator bool() const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (int) ((const struct error_code *) this)->_M_value != 0
   >>>;


;; Function std::error_code std::make_error_code(std::errc) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = TARGET_EXPR <D.25192, <<< Unknown tree: aggr_init_expr
  6
  __comp_ctor 
  D.25192
  (struct error_code *) <<< Unknown tree: void_cst >>>
  (int) __e
  (const struct error_category &) (const struct error_category *) std::_V2::generic_category () >>>>;, D.25192>>
   >>>;


;; Function bool std::operator<(const std::error_code&, const std::error_code&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::_V2::error_category::operator< ((const struct error_category *) std::error_code::category ((const struct error_code *) __lhs), (const struct error_category &) (const struct error_category *) std::error_code::category ((const struct error_code *) __rhs)) || std::_V2::error_category::operator== ((const struct error_category *) std::error_code::category ((const struct error_code *) __lhs), (const struct error_category &) (const struct error_category *) std::error_code::category ((const struct error_code *) __rhs)) && std::error_code::value ((const struct error_code *) __lhs) < std::error_code::value ((const struct error_code *) __rhs)>>
   >>>;


;; Function std::error_condition::error_condition() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct error_condition *) this)->_M_value = 0) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct error_condition *) this)->_M_cat = (const struct error_category *) std::_V2::generic_category ()) >>>>>;
  }
   >>>;


;; Function std::error_condition::error_condition(int, const std::_V2::error_category&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct error_condition *) this)->_M_value = __v) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct error_condition *) this)->_M_cat = (const struct error_category *) __cat) >>>>>;
  }
   >>>;


;; Function void std::error_condition::assign(int, const std::_V2::error_category&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct error_condition *) this)->_M_value = __v) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct error_condition *) this)->_M_cat = (const struct error_category *) __cat) >>>>>;
   >>>;


;; Function void std::error_condition::clear() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::error_condition::assign (this, 0, (const struct error_category &) (const struct error_category *) std::_V2::generic_category ()) >>>>>
   >>>;


;; Function int std::error_condition::value() const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (int) ((const struct error_condition *) this)->_M_value
   >>>;


;; Function const std::_V2::error_category& std::error_condition::category() const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (const struct error_category &) (const struct error_category *) ((const struct error_condition *) this)->_M_cat
   >>>;


;; Function std::__cxx11::string std::error_condition::message() const (null)
;; enabled by -tree-original


<<cleanup_point return *<retval> = TARGET_EXPR <D.25295, <<< Unknown tree: aggr_init_expr
  5
  OBJ_TYPE_REF(*((SAVE_EXPR <(const struct error_category *) std::error_condition::category (this)>)->_vptr.error_category + 32);(const struct error_category)SAVE_EXPR <(const struct error_category *) std::error_condition::category (this)>->4)
  D.25295
  SAVE_EXPR <(const struct error_category *) std::error_condition::category (this)>
  std::error_condition::value (this) >>>>>>;


;; Function std::error_condition::operator bool() const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (int) ((const struct error_condition *) this)->_M_value != 0
   >>>;


;; Function std::error_condition std::make_error_condition(std::errc) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = TARGET_EXPR <D.25318, <<< Unknown tree: aggr_init_expr
  6
  __comp_ctor 
  D.25318
  (struct error_condition *) <<< Unknown tree: void_cst >>>
  (int) __e
  (const struct error_category &) (const struct error_category *) std::_V2::generic_category () >>>>;, D.25318>>
   >>>;


;; Function bool std::operator<(const std::error_condition&, const std::error_condition&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::_V2::error_category::operator< ((const struct error_category *) std::error_condition::category ((const struct error_condition *) __lhs), (const struct error_category &) (const struct error_category *) std::error_condition::category ((const struct error_condition *) __rhs)) || std::_V2::error_category::operator== ((const struct error_category *) std::error_condition::category ((const struct error_condition *) __lhs), (const struct error_category &) (const struct error_category *) std::error_condition::category ((const struct error_condition *) __rhs)) && std::error_condition::value ((const struct error_condition *) __lhs) < std::error_condition::value ((const struct error_condition *) __rhs)>>
   >>>;


;; Function bool std::operator==(const std::error_code&, const std::error_code&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::_V2::error_category::operator== ((const struct error_category *) std::error_code::category ((const struct error_code *) __lhs), (const struct error_category &) (const struct error_category *) std::error_code::category ((const struct error_code *) __rhs)) && std::error_code::value ((const struct error_code *) __lhs) == std::error_code::value ((const struct error_code *) __rhs)>>
   >>>;


;; Function bool std::operator==(const std::error_code&, const std::error_condition&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = OBJ_TYPE_REF(*((SAVE_EXPR <(const struct error_category *) std::error_code::category ((const struct error_code *) __lhs)>)->_vptr.error_category + 48);(const struct error_category)SAVE_EXPR <(const struct error_category *) std::error_code::category ((const struct error_code *) __lhs)>->6) (SAVE_EXPR <(const struct error_category *) std::error_code::category ((const struct error_code *) __lhs)>, std::error_code::value ((const struct error_code *) __lhs), (const struct error_condition &) (const struct error_condition *) __rhs) || OBJ_TYPE_REF(*((SAVE_EXPR <(const struct error_category *) std::error_condition::category ((const struct error_condition *) __rhs)>)->_vptr.error_category + 56);(const struct error_category)SAVE_EXPR <(const struct error_category *) std::error_condition::category ((const struct error_condition *) __rhs)>->7) (SAVE_EXPR <(const struct error_category *) std::error_condition::category ((const struct error_condition *) __rhs)>, (const struct error_code &) (const struct error_code *) __lhs, std::error_condition::value ((const struct error_condition *) __rhs))>>
   >>>;


;; Function bool std::operator==(const std::error_condition&, const std::error_code&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = OBJ_TYPE_REF(*((SAVE_EXPR <(const struct error_category *) std::error_code::category ((const struct error_code *) __rhs)>)->_vptr.error_category + 48);(const struct error_category)SAVE_EXPR <(const struct error_category *) std::error_code::category ((const struct error_code *) __rhs)>->6) (SAVE_EXPR <(const struct error_category *) std::error_code::category ((const struct error_code *) __rhs)>, std::error_code::value ((const struct error_code *) __rhs), (const struct error_condition &) (const struct error_condition *) __lhs) || OBJ_TYPE_REF(*((SAVE_EXPR <(const struct error_category *) std::error_condition::category ((const struct error_condition *) __lhs)>)->_vptr.error_category + 56);(const struct error_category)SAVE_EXPR <(const struct error_category *) std::error_condition::category ((const struct error_condition *) __lhs)>->7) (SAVE_EXPR <(const struct error_category *) std::error_condition::category ((const struct error_condition *) __lhs)>, (const struct error_code &) (const struct error_code *) __rhs, std::error_condition::value ((const struct error_condition *) __lhs))>>
   >>>;


;; Function bool std::operator==(const std::error_condition&, const std::error_condition&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::_V2::error_category::operator== ((const struct error_category *) std::error_condition::category ((const struct error_condition *) __lhs), (const struct error_category &) (const struct error_category *) std::error_condition::category ((const struct error_condition *) __rhs)) && std::error_condition::value ((const struct error_condition *) __lhs) == std::error_condition::value ((const struct error_condition *) __rhs)>>
   >>>;


;; Function bool std::operator!=(const std::error_code&, const std::error_code&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = !std::operator== ((const struct error_code &) (const struct error_code *) __lhs, (const struct error_code &) (const struct error_code *) __rhs)>>
   >>>;


;; Function bool std::operator!=(const std::error_code&, const std::error_condition&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = !std::operator== ((const struct error_code &) (const struct error_code *) __lhs, (const struct error_condition &) (const struct error_condition *) __rhs)>>
   >>>;


;; Function bool std::operator!=(const std::error_condition&, const std::error_code&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = !std::operator== ((const struct error_condition &) (const struct error_condition *) __lhs, (const struct error_code &) (const struct error_code *) __rhs)>>
   >>>;


;; Function bool std::operator!=(const std::error_condition&, const std::error_condition&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = !std::operator== ((const struct error_condition &) (const struct error_condition *) __lhs, (const struct error_condition &) (const struct error_condition *) __rhs)>>
   >>>;


;; Function std::system_error::system_error(std::error_code) (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::runtime_error::runtime_error (&((struct system_error *) this)->D.25465, (const struct string &) (const struct string *) &TARGET_EXPR <D.25472, <<< Unknown tree: aggr_init_expr
  4
  message
  D.25472
  &__ec >>>>) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct system_error *) this)->D.25465.D.24808._vptr.exception = &_ZTVSt12system_error + 16) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct system_error *) this)->_M_code = __ec) >>>>>;
    }
  catch
    {
      std::runtime_error::~runtime_error (&((struct system_error *) this)->D.25465);
    }
}


;; Function std::system_error::system_error(std::error_code, const string&) (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::runtime_error::runtime_error (&((struct system_error *) this)->D.25465, (const struct string &) (const struct string *) &TARGET_EXPR <D.25494, <<< Unknown tree: aggr_init_expr
  5
  operator+
  D.25494
  (struct basic_string &) &TARGET_EXPR <D.25480, <<< Unknown tree: aggr_init_expr
  5
  operator+
  D.25480
  (const struct basic_string &) (const struct string *) __what
  (const char *) ": " >>>>
  (struct basic_string &) &TARGET_EXPR <D.25481, <<< Unknown tree: aggr_init_expr
  4
  message
  D.25481
  &__ec >>>> >>>>) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct system_error *) this)->D.25465.D.24808._vptr.exception = &_ZTVSt12system_error + 16) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct system_error *) this)->_M_code = __ec) >>>>>;
    }
  catch
    {
      std::runtime_error::~runtime_error (&((struct system_error *) this)->D.25465);
    }
}


;; Function std::system_error::system_error(std::error_code, const char*) (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::runtime_error::runtime_error (&((struct system_error *) this)->D.25465, (const struct string &) (const struct string *) &TARGET_EXPR <D.25509, <<< Unknown tree: aggr_init_expr
  5
  operator+
  D.25509
  __what
  (struct basic_string &) &TARGET_EXPR <D.25508, <<< Unknown tree: aggr_init_expr
  5
  operator+
  D.25508
  (const char *) ": "
  (struct basic_string &) &TARGET_EXPR <D.25501, <<< Unknown tree: aggr_init_expr
  4
  message
  D.25501
  &__ec >>>> >>>> >>>>) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct system_error *) this)->D.25465.D.24808._vptr.exception = &_ZTVSt12system_error + 16) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct system_error *) this)->_M_code = __ec) >>>>>;
    }
  catch
    {
      std::runtime_error::~runtime_error (&((struct system_error *) this)->D.25465);
    }
}


;; Function std::system_error::system_error(int, const std::_V2::error_category&, const char*) (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::system_error::system_error (this, TARGET_EXPR <D.25516, <<< Unknown tree: aggr_init_expr
  6
  __comp_ctor 
  D.25516
  (struct error_code *) <<< Unknown tree: void_cst >>>
  __v
  (const struct error_category &) (const struct error_category *) __ecat >>>>, __what) >>>>>;
  try
    {
      
    }
  catch
    {
      std::system_error::~system_error (this);
    }
}


;; Function std::system_error::system_error(int, const std::_V2::error_category&) (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::runtime_error::runtime_error (&((struct system_error *) this)->D.25465, (const struct string &) (const struct string *) &TARGET_EXPR <D.25531, <<< Unknown tree: aggr_init_expr
  4
  message
  D.25531
  &TARGET_EXPR <D.25530, <<< Unknown tree: aggr_init_expr
  6
  __comp_ctor 
  D.25530
  (struct error_code *) <<< Unknown tree: void_cst >>>
  __v
  (const struct error_category &) (const struct error_category *) __ecat >>>> >>>>) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct system_error *) this)->D.25465.D.24808._vptr.exception = &_ZTVSt12system_error + 16) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::error_code::error_code (&((struct system_error *) this)->_M_code, __v, (const struct error_category &) (const struct error_category *) __ecat) >>>>>;
    }
  catch
    {
      std::runtime_error::~runtime_error (&((struct system_error *) this)->D.25465);
    }
}


;; Function std::system_error::system_error(int, const std::_V2::error_category&, const string&) (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::runtime_error::runtime_error (&((struct system_error *) this)->D.25465, (const struct string &) (const struct string *) &TARGET_EXPR <D.25540, <<< Unknown tree: aggr_init_expr
  5
  operator+
  D.25540
  (struct basic_string &) &TARGET_EXPR <D.25537, <<< Unknown tree: aggr_init_expr
  5
  operator+
  D.25537
  (const struct basic_string &) (const struct string *) __what
  (const char *) ": " >>>>
  (struct basic_string &) &TARGET_EXPR <D.25539, <<< Unknown tree: aggr_init_expr
  4
  message
  D.25539
  &TARGET_EXPR <D.25538, <<< Unknown tree: aggr_init_expr
  6
  __comp_ctor 
  D.25538
  (struct error_code *) <<< Unknown tree: void_cst >>>
  __v
  (const struct error_category &) (const struct error_category *) __ecat >>>> >>>> >>>>) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct system_error *) this)->D.25465.D.24808._vptr.exception = &_ZTVSt12system_error + 16) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::error_code::error_code (&((struct system_error *) this)->_M_code, __v, (const struct error_category &) (const struct error_category *) __ecat) >>>>>;
    }
  catch
    {
      std::runtime_error::~runtime_error (&((struct system_error *) this)->D.25465);
    }
}


;; Function const std::error_code& std::system_error::code() const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (const struct error_code &) &((const struct system_error *) this)->_M_code
   >>>;


;; Function std::size_t std::hash<std::error_code>::operator()(const std::error_code&) const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    const size_t __tmp;

        const size_t __tmp;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__tmp = std::_Hash_impl::hash<int> ((const int &) &__e->_M_value)) >>>>>;
    <<cleanup_point return <retval> = std::_Hash_impl::__hash_combine<const std::_V2::error_category*> ((const struct error_category * const &) &__e->_M_cat, (size_t) __tmp)>>;
  }
   >>>;


;; Function constexpr std::_Ios_Fmtflags std::operator&(std::_Ios_Fmtflags, std::_Ios_Fmtflags) (null)
;; enabled by -tree-original


return <retval> = (_Ios_Fmtflags) ((int) __a & (int) __b);


;; Function constexpr std::_Ios_Fmtflags std::operator|(std::_Ios_Fmtflags, std::_Ios_Fmtflags) (null)
;; enabled by -tree-original


return <retval> = (_Ios_Fmtflags) ((int) __a | (int) __b);


;; Function constexpr std::_Ios_Fmtflags std::operator^(std::_Ios_Fmtflags, std::_Ios_Fmtflags) (null)
;; enabled by -tree-original


return <retval> = (_Ios_Fmtflags) ((int) __a ^ (int) __b);


;; Function constexpr std::_Ios_Fmtflags std::operator~(std::_Ios_Fmtflags) (null)
;; enabled by -tree-original


return <retval> = ~__a;


;; Function const std::_Ios_Fmtflags& std::operator|=(std::_Ios_Fmtflags&, std::_Ios_Fmtflags) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (const _Ios_Fmtflags &) (*__a = std::operator| (*__a, __b);, (const _Ios_Fmtflags *) __a;)>>;


;; Function const std::_Ios_Fmtflags& std::operator&=(std::_Ios_Fmtflags&, std::_Ios_Fmtflags) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (const _Ios_Fmtflags &) (*__a = std::operator& (*__a, __b);, (const _Ios_Fmtflags *) __a;)>>;


;; Function const std::_Ios_Fmtflags& std::operator^=(std::_Ios_Fmtflags&, std::_Ios_Fmtflags) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (const _Ios_Fmtflags &) (*__a = std::operator^ (*__a, __b);, (const _Ios_Fmtflags *) __a;)>>;


;; Function constexpr std::_Ios_Openmode std::operator&(std::_Ios_Openmode, std::_Ios_Openmode) (null)
;; enabled by -tree-original


return <retval> = (_Ios_Openmode) ((int) __a & (int) __b);


;; Function constexpr std::_Ios_Openmode std::operator|(std::_Ios_Openmode, std::_Ios_Openmode) (null)
;; enabled by -tree-original


return <retval> = (_Ios_Openmode) ((int) __a | (int) __b);


;; Function constexpr std::_Ios_Openmode std::operator^(std::_Ios_Openmode, std::_Ios_Openmode) (null)
;; enabled by -tree-original


return <retval> = (_Ios_Openmode) ((int) __a ^ (int) __b);


;; Function constexpr std::_Ios_Openmode std::operator~(std::_Ios_Openmode) (null)
;; enabled by -tree-original


return <retval> = ~__a;


;; Function const std::_Ios_Openmode& std::operator|=(std::_Ios_Openmode&, std::_Ios_Openmode) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (const _Ios_Openmode &) (*__a = std::operator| (*__a, __b);, (const _Ios_Openmode *) __a;)>>;


;; Function const std::_Ios_Openmode& std::operator&=(std::_Ios_Openmode&, std::_Ios_Openmode) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (const _Ios_Openmode &) (*__a = std::operator& (*__a, __b);, (const _Ios_Openmode *) __a;)>>;


;; Function const std::_Ios_Openmode& std::operator^=(std::_Ios_Openmode&, std::_Ios_Openmode) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (const _Ios_Openmode &) (*__a = std::operator^ (*__a, __b);, (const _Ios_Openmode *) __a;)>>;


;; Function constexpr std::_Ios_Iostate std::operator&(std::_Ios_Iostate, std::_Ios_Iostate) (null)
;; enabled by -tree-original


return <retval> = (_Ios_Iostate) ((int) __a & (int) __b);


;; Function constexpr std::_Ios_Iostate std::operator|(std::_Ios_Iostate, std::_Ios_Iostate) (null)
;; enabled by -tree-original


return <retval> = (_Ios_Iostate) ((int) __a | (int) __b);


;; Function constexpr std::_Ios_Iostate std::operator^(std::_Ios_Iostate, std::_Ios_Iostate) (null)
;; enabled by -tree-original


return <retval> = (_Ios_Iostate) ((int) __a ^ (int) __b);


;; Function constexpr std::_Ios_Iostate std::operator~(std::_Ios_Iostate) (null)
;; enabled by -tree-original


return <retval> = ~__a;


;; Function const std::_Ios_Iostate& std::operator|=(std::_Ios_Iostate&, std::_Ios_Iostate) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (const _Ios_Iostate &) (*__a = std::operator| (*__a, __b);, (const _Ios_Iostate *) __a;)>>;


;; Function const std::_Ios_Iostate& std::operator&=(std::_Ios_Iostate&, std::_Ios_Iostate) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (const _Ios_Iostate &) (*__a = std::operator& (*__a, __b);, (const _Ios_Iostate *) __a;)>>;


;; Function const std::_Ios_Iostate& std::operator^=(std::_Ios_Iostate&, std::_Ios_Iostate) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (const _Ios_Iostate &) (*__a = std::operator^ (*__a, __b);, (const _Ios_Iostate *) __a;)>>;


;; Function std::error_code std::make_error_code(std::io_errc) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = TARGET_EXPR <D.25698, <<< Unknown tree: aggr_init_expr
  6
  __comp_ctor 
  D.25698
  (struct error_code *) <<< Unknown tree: void_cst >>>
  (int) e
  (const struct error_category &) (const struct error_category *) std::iostream_category () >>>>;, D.25698>>
   >>>;


;; Function std::error_condition std::make_error_condition(std::io_errc) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = TARGET_EXPR <D.25702, <<< Unknown tree: aggr_init_expr
  6
  __comp_ctor 
  D.25702
  (struct error_condition *) <<< Unknown tree: void_cst >>>
  (int) e
  (const struct error_category &) (const struct error_category *) std::iostream_category () >>>>;, D.25702>>
   >>>;


;; Function std::ios_base::_Callback_list::_Callback_list(std::ios_base::event_callback, int, std::ios_base::_Callback_list*) (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Callback_list *) this)->_M_next = __cb) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Callback_list *) this)->_M_fn = __fn) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Callback_list *) this)->_M_index = __index) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Callback_list *) this)->_M_refcount = 0) >>>>>;
}


;; Function void std::ios_base::_Callback_list::_M_add_reference() (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::__atomic_add_dispatch (&((struct _Callback_list *) this)->_M_refcount, 1) >>>>>;


;; Function int std::ios_base::_Callback_list::_M_remove_reference() (null)
;; enabled by -tree-original


{
  int __res;

    int __res;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__res = __gnu_cxx::__exchange_and_add_dispatch (&((struct _Callback_list *) this)->_M_refcount, -1)) >>>>>;
  if (__res == 0)
    {
      
    }
  return <retval> = __res;
}


;; Function std::ios_base::_Words::_Words() (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Words *) this)->_M_pword = 0B) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Words *) this)->_M_iword = 0) >>>>>;
}


;; Function std::ios_base::fmtflags std::ios_base::flags() const (null)
;; enabled by -tree-original


return <retval> = (fmtflags) ((const struct ios_base *) this)->_M_flags;


;; Function std::ios_base::fmtflags std::ios_base::flags(std::ios_base::fmtflags) (null)
;; enabled by -tree-original


{
  fmtflags __old = ((struct ios_base *) this)->_M_flags;

    fmtflags __old = ((struct ios_base *) this)->_M_flags;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct ios_base *) this)->_M_flags = __fmtfl) >>>>>;
  return <retval> = __old;
}


;; Function std::ios_base::fmtflags std::ios_base::setf(std::ios_base::fmtflags) (null)
;; enabled by -tree-original


{
  fmtflags __old = ((struct ios_base *) this)->_M_flags;

    fmtflags __old = ((struct ios_base *) this)->_M_flags;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::operator|= ((_Ios_Fmtflags &) &((struct ios_base *) this)->_M_flags, __fmtfl) >>>>>;
  return <retval> = __old;
}


;; Function std::ios_base::fmtflags std::ios_base::setf(std::ios_base::fmtflags, std::ios_base::fmtflags) (null)
;; enabled by -tree-original


{
  fmtflags __old = ((struct ios_base *) this)->_M_flags;

    fmtflags __old = ((struct ios_base *) this)->_M_flags;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::operator&= ((_Ios_Fmtflags &) &((struct ios_base *) this)->_M_flags, std::operator~ (__mask)) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::operator|= ((_Ios_Fmtflags &) &((struct ios_base *) this)->_M_flags, std::operator& (__fmtfl, __mask)) >>>>>;
  return <retval> = __old;
}


;; Function void std::ios_base::unsetf(std::ios_base::fmtflags) (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::operator&= ((_Ios_Fmtflags &) &((struct ios_base *) this)->_M_flags, std::operator~ (__mask)) >>>>>;


;; Function std::streamsize std::ios_base::precision() const (null)
;; enabled by -tree-original


return <retval> = (streamsize) ((const struct ios_base *) this)->_M_precision;


;; Function std::streamsize std::ios_base::precision(std::streamsize) (null)
;; enabled by -tree-original


{
  streamsize __old = ((struct ios_base *) this)->_M_precision;

    streamsize __old = ((struct ios_base *) this)->_M_precision;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct ios_base *) this)->_M_precision = __prec) >>>>>;
  return <retval> = __old;
}


;; Function std::streamsize std::ios_base::width() const (null)
;; enabled by -tree-original


return <retval> = (streamsize) ((const struct ios_base *) this)->_M_width;


;; Function std::streamsize std::ios_base::width(std::streamsize) (null)
;; enabled by -tree-original


{
  streamsize __old = ((struct ios_base *) this)->_M_width;

    streamsize __old = ((struct ios_base *) this)->_M_width;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct ios_base *) this)->_M_width = __wide) >>>>>;
  return <retval> = __old;
}


;; Function std::locale std::ios_base::getloc() const (null)
;; enabled by -tree-original


<<cleanup_point return *<retval> = TARGET_EXPR <D.26024, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.26024
  (struct locale *) <<< Unknown tree: void_cst >>>
  (const struct locale &) &((const struct ios_base *) this)->_M_ios_locale >>>>>>;


;; Function const std::locale& std::ios_base::_M_getloc() const (null)
;; enabled by -tree-original


return <retval> = (const struct locale &) &((const struct ios_base *) this)->_M_ios_locale;


;; Function long int& std::ios_base::iword(int) (null)
;; enabled by -tree-original


{
  struct _Words & __word;

    struct _Words & __word;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__word = (struct _Words &) (((struct ios_base *) this)->_M_word_size > __ix ? ((struct ios_base *) this)->_M_word + (sizetype) ((long unsigned int) __ix * 16) : (struct _Words *) std::ios_base::_M_grow_words (this, __ix, 1))) >>>>>;
  return <retval> = (long int &) &__word->_M_iword;
}


;; Function void*& std::ios_base::pword(int) (null)
;; enabled by -tree-original


{
  struct _Words & __word;

    struct _Words & __word;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__word = (struct _Words &) (((struct ios_base *) this)->_M_word_size > __ix ? ((struct ios_base *) this)->_M_word + (sizetype) ((long unsigned int) __ix * 16) : (struct _Words *) std::ios_base::_M_grow_words (this, __ix, 0))) >>>>>;
  return <retval> = (void * &) &__word->_M_pword;
}


;; Function std::ios_base& std::boolalpha(std::ios_base&) (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::ios_base::setf ((struct ios_base *) __base, 1) >>>>>;
return <retval> = (struct ios_base &) (struct ios_base *) __base;


;; Function std::ios_base& std::noboolalpha(std::ios_base&) (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::ios_base::unsetf ((struct ios_base *) __base, 1) >>>>>;
return <retval> = (struct ios_base &) (struct ios_base *) __base;


;; Function std::ios_base& std::showbase(std::ios_base&) (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::ios_base::setf ((struct ios_base *) __base, 512) >>>>>;
return <retval> = (struct ios_base &) (struct ios_base *) __base;


;; Function std::ios_base& std::noshowbase(std::ios_base&) (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::ios_base::unsetf ((struct ios_base *) __base, 512) >>>>>;
return <retval> = (struct ios_base &) (struct ios_base *) __base;


;; Function std::ios_base& std::showpoint(std::ios_base&) (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::ios_base::setf ((struct ios_base *) __base, 1024) >>>>>;
return <retval> = (struct ios_base &) (struct ios_base *) __base;


;; Function std::ios_base& std::noshowpoint(std::ios_base&) (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::ios_base::unsetf ((struct ios_base *) __base, 1024) >>>>>;
return <retval> = (struct ios_base &) (struct ios_base *) __base;


;; Function std::ios_base& std::showpos(std::ios_base&) (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::ios_base::setf ((struct ios_base *) __base, 2048) >>>>>;
return <retval> = (struct ios_base &) (struct ios_base *) __base;


;; Function std::ios_base& std::noshowpos(std::ios_base&) (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::ios_base::unsetf ((struct ios_base *) __base, 2048) >>>>>;
return <retval> = (struct ios_base &) (struct ios_base *) __base;


;; Function std::ios_base& std::skipws(std::ios_base&) (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::ios_base::setf ((struct ios_base *) __base, 4096) >>>>>;
return <retval> = (struct ios_base &) (struct ios_base *) __base;


;; Function std::ios_base& std::noskipws(std::ios_base&) (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::ios_base::unsetf ((struct ios_base *) __base, 4096) >>>>>;
return <retval> = (struct ios_base &) (struct ios_base *) __base;


;; Function std::ios_base& std::uppercase(std::ios_base&) (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::ios_base::setf ((struct ios_base *) __base, 16384) >>>>>;
return <retval> = (struct ios_base &) (struct ios_base *) __base;


;; Function std::ios_base& std::nouppercase(std::ios_base&) (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::ios_base::unsetf ((struct ios_base *) __base, 16384) >>>>>;
return <retval> = (struct ios_base &) (struct ios_base *) __base;


;; Function std::ios_base& std::unitbuf(std::ios_base&) (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::ios_base::setf ((struct ios_base *) __base, 8192) >>>>>;
return <retval> = (struct ios_base &) (struct ios_base *) __base;


;; Function std::ios_base& std::nounitbuf(std::ios_base&) (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::ios_base::unsetf ((struct ios_base *) __base, 8192) >>>>>;
return <retval> = (struct ios_base &) (struct ios_base *) __base;


;; Function std::ios_base& std::internal(std::ios_base&) (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::ios_base::setf ((struct ios_base *) __base, 16, 176) >>>>>;
return <retval> = (struct ios_base &) (struct ios_base *) __base;


;; Function std::ios_base& std::left(std::ios_base&) (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::ios_base::setf ((struct ios_base *) __base, 32, 176) >>>>>;
return <retval> = (struct ios_base &) (struct ios_base *) __base;


;; Function std::ios_base& std::right(std::ios_base&) (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::ios_base::setf ((struct ios_base *) __base, 128, 176) >>>>>;
return <retval> = (struct ios_base &) (struct ios_base *) __base;


;; Function std::ios_base& std::dec(std::ios_base&) (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::ios_base::setf ((struct ios_base *) __base, 2, 74) >>>>>;
return <retval> = (struct ios_base &) (struct ios_base *) __base;


;; Function std::ios_base& std::hex(std::ios_base&) (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::ios_base::setf ((struct ios_base *) __base, 8, 74) >>>>>;
return <retval> = (struct ios_base &) (struct ios_base *) __base;


;; Function std::ios_base& std::oct(std::ios_base&) (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::ios_base::setf ((struct ios_base *) __base, 64, 74) >>>>>;
return <retval> = (struct ios_base &) (struct ios_base *) __base;


;; Function std::ios_base& std::fixed(std::ios_base&) (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::ios_base::setf ((struct ios_base *) __base, 4, 260) >>>>>;
return <retval> = (struct ios_base &) (struct ios_base *) __base;


;; Function std::ios_base& std::scientific(std::ios_base&) (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::ios_base::setf ((struct ios_base *) __base, 256, 260) >>>>>;
return <retval> = (struct ios_base &) (struct ios_base *) __base;


;; Function std::ios_base& std::hexfloat(std::ios_base&) (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::ios_base::setf ((struct ios_base *) __base, std::operator| (4, 256), 260) >>>>>;
return <retval> = (struct ios_base &) (struct ios_base *) __base;


;; Function std::ios_base& std::defaultfloat(std::ios_base&) (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::ios_base::unsetf ((struct ios_base *) __base, 260) >>>>>;
return <retval> = (struct ios_base &) (struct ios_base *) __base;


;; Function std::ctype<char>::char_type std::ctype<char>::toupper(std::ctype<char>::char_type) const (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = OBJ_TYPE_REF(*(((const struct ctype *) this)->D.28026._vptr.facet + 16);(const struct ctype)this->2) (this, (int) __c)>>;


;; Function const char_type* std::ctype<char>::toupper(std::ctype<char>::char_type*, const char_type*) const (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = OBJ_TYPE_REF(*(((const struct ctype *) this)->D.28026._vptr.facet + 24);(const struct ctype)this->3) (this, __lo, __hi)>>;


;; Function std::ctype<char>::char_type std::ctype<char>::tolower(std::ctype<char>::char_type) const (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = OBJ_TYPE_REF(*(((const struct ctype *) this)->D.28026._vptr.facet + 32);(const struct ctype)this->4) (this, (int) __c)>>;


;; Function const char_type* std::ctype<char>::tolower(std::ctype<char>::char_type*, const char_type*) const (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = OBJ_TYPE_REF(*(((const struct ctype *) this)->D.28026._vptr.facet + 40);(const struct ctype)this->5) (this, __lo, __hi)>>;


;; Function std::ctype<char>::char_type std::ctype<char>::widen(char) const (null)
;; enabled by -tree-original


if ((signed char) ((const struct ctype *) this)->_M_widen_ok != 0)
  {
    return <retval> = ((const struct ctype *) this)->_M_widen[(int) (unsigned char) __c];
  }
<<cleanup_point <<< Unknown tree: expr_stmt
  std::ctype<char>::_M_widen_init (this) >>>>>;
<<cleanup_point return <retval> = OBJ_TYPE_REF(*(((const struct ctype *) this)->D.28026._vptr.facet + 48);(const struct ctype)this->6) (this, (int) __c)>>;


;; Function const char* std::ctype<char>::widen(const char*, const char*, std::ctype<char>::char_type*) const (null)
;; enabled by -tree-original


if ((signed char) ((const struct ctype *) this)->_M_widen_ok == 1)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) __builtin_memcpy ((void *) __to, (const void *) __lo, (long unsigned int) ((long int) __hi - (long int) __lo)) >>>>>;
    return <retval> = __hi;
  }
if ((signed char) ((const struct ctype *) this)->_M_widen_ok == 0)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::ctype<char>::_M_widen_init (this) >>>>>;
  }
<<cleanup_point return <retval> = OBJ_TYPE_REF(*(((const struct ctype *) this)->D.28026._vptr.facet + 56);(const struct ctype)this->7) (this, __lo, __hi, __to)>>;


;; Function char std::ctype<char>::narrow(std::ctype<char>::char_type, char) const (null)
;; enabled by -tree-original


{
  const char __t;

  if ((signed char) ((const struct ctype *) this)->_M_narrow[(int) (unsigned char) __c] != 0)
    {
      return <retval> = ((const struct ctype *) this)->_M_narrow[(int) (unsigned char) __c];
    }
    const char __t;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__t = OBJ_TYPE_REF(*(((const struct ctype *) this)->D.28026._vptr.facet + 64);(const struct ctype)this->8) (this, (int) __c, (int) __dfault)) >>>>>;
  if ((signed char) __t != (signed char) __dfault)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((const struct ctype *) this)->_M_narrow[(int) (unsigned char) __c] = (char) __t) >>>>>;
    }
  return <retval> = (char) __t;
}


;; Function const char_type* std::ctype<char>::narrow(const char_type*, const char_type*, char, char*) const (null)
;; enabled by -tree-original


if (__builtin_expect ((signed char) ((const struct ctype *) this)->_M_narrow_ok == 1, 1) != 0)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) __builtin_memcpy ((void *) __to, (const void *) __lo, (long unsigned int) ((long int) __hi - (long int) __lo)) >>>>>;
    return <retval> = __hi;
  }
if ((signed char) ((const struct ctype *) this)->_M_narrow_ok == 0)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::ctype<char>::_M_narrow_init (this) >>>>>;
  }
<<cleanup_point return <retval> = OBJ_TYPE_REF(*(((const struct ctype *) this)->D.28026._vptr.facet + 72);(const struct ctype)this->9) (this, __lo, __hi, (int) __dfault, __to)>>;


;; Function const mask* std::ctype<char>::table() const (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  return <retval> = (const mask *) ((const struct ctype *) this)->_M_table
   >>>;


;; Function virtual std::ctype<char>::char_type std::ctype<char>::do_widen(char) const (null)
;; enabled by -tree-original


return <retval> = __c;


;; Function virtual const char* std::ctype<char>::do_widen(const char*, const char*, std::ctype<char>::char_type*) const (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) __builtin_memcpy ((void *) __to, (const void *) __lo, (long unsigned int) ((long int) __hi - (long int) __lo)) >>>>>;
return <retval> = __hi;


;; Function virtual char std::ctype<char>::do_narrow(std::ctype<char>::char_type, char) const (null)
;; enabled by -tree-original


return <retval> = __c;


;; Function virtual const char_type* std::ctype<char>::do_narrow(const char_type*, const char_type*, char, char*) const (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) __builtin_memcpy ((void *) __to, (const void *) __lo, (long unsigned int) ((long int) __hi - (long int) __lo)) >>>>>;
return <retval> = __hi;


;; Function bool std::ctype<char>::is(std::ctype_base::mask, char) const (null)
;; enabled by -tree-original


return <retval> = ((short unsigned int) *((const mask *) ((const struct ctype *) this)->_M_table + (sizetype) ((long unsigned int) (unsigned char) __c * 2)) & __m) != 0;


;; Function const char* std::ctype<char>::is(const char*, const char*, std::ctype_base::mask*) const (null)
;; enabled by -tree-original


while (1)
  {
    if (__low >= __high) goto <D.28414>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__vec++  = (mask) *((const mask *) ((const struct ctype *) this)->_M_table + (sizetype) ((long unsigned int) (unsigned char) *__low++  * 2))) >>>>>;
  }
<D.28414>:;
return <retval> = __high;


;; Function const char* std::ctype<char>::scan_is(std::ctype_base::mask, const char*, const char*) const (null)
;; enabled by -tree-original


while (1)
  {
    if (__low >= __high || ((short unsigned int) *((const mask *) ((const struct ctype *) this)->_M_table + (sizetype) ((long unsigned int) (unsigned char) *__low * 2)) & __m) != 0) goto <D.28422>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void)  ++__low >>>>>;
  }
<D.28422>:;
return <retval> = __low;


;; Function const char* std::ctype<char>::scan_not(std::ctype_base::mask, const char*, const char*) const (null)
;; enabled by -tree-original


while (1)
  {
    if (__low >= __high || ((short unsigned int) *((const mask *) ((const struct ctype *) this)->_M_table + (sizetype) ((long unsigned int) (unsigned char) *__low * 2)) & __m) == 0) goto <D.28430>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void)  ++__low >>>>>;
  }
<D.28430>:;
return <retval> = __low;


;; Function static constexpr bool std::numeric_limits<bool>::min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr bool std::numeric_limits<bool>::max() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 1
   >>>;


;; Function static constexpr bool std::numeric_limits<bool>::lowest() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::numeric_limits<bool>::min ()>>
   >>>;


;; Function static constexpr bool std::numeric_limits<bool>::epsilon() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr bool std::numeric_limits<bool>::round_error() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr bool std::numeric_limits<bool>::infinity() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr bool std::numeric_limits<bool>::quiet_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr bool std::numeric_limits<bool>::signaling_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr bool std::numeric_limits<bool>::denorm_min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr char std::numeric_limits<char>::min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (char) (254 - ((unsigned char) (1 << 1 * 8 + 18446744073709551614) + 255 << 1))
   >>>;


;; Function static constexpr char std::numeric_limits<char>::max() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (char) (((unsigned char) (1 << 1 * 8 + 18446744073709551614) + 255 << 1) + 1)
   >>>;


;; Function static constexpr char std::numeric_limits<char>::lowest() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::numeric_limits<char>::min ()>>
   >>>;


;; Function static constexpr char std::numeric_limits<char>::epsilon() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr char std::numeric_limits<char>::round_error() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr char std::numeric_limits<char>::infinity() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr char std::numeric_limits<char>::quiet_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr char std::numeric_limits<char>::signaling_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr char std::numeric_limits<char>::denorm_min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr signed char std::numeric_limits<signed char>::min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = -128
   >>>;


;; Function static constexpr signed char std::numeric_limits<signed char>::max() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 127
   >>>;


;; Function static constexpr signed char std::numeric_limits<signed char>::lowest() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::numeric_limits<signed char>::min ()>>
   >>>;


;; Function static constexpr signed char std::numeric_limits<signed char>::epsilon() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr signed char std::numeric_limits<signed char>::round_error() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr signed char std::numeric_limits<signed char>::infinity() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr signed char std::numeric_limits<signed char>::quiet_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr signed char std::numeric_limits<signed char>::signaling_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr signed char std::numeric_limits<signed char>::denorm_min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr unsigned char std::numeric_limits<unsigned char>::min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr unsigned char std::numeric_limits<unsigned char>::max() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 255
   >>>;


;; Function static constexpr unsigned char std::numeric_limits<unsigned char>::lowest() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::numeric_limits<unsigned char>::min ()>>
   >>>;


;; Function static constexpr unsigned char std::numeric_limits<unsigned char>::epsilon() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr unsigned char std::numeric_limits<unsigned char>::round_error() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr unsigned char std::numeric_limits<unsigned char>::infinity() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr unsigned char std::numeric_limits<unsigned char>::quiet_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr unsigned char std::numeric_limits<unsigned char>::signaling_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr unsigned char std::numeric_limits<unsigned char>::denorm_min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr wchar_t std::numeric_limits<wchar_t>::min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (wchar_t) (-2 - ((1 << 4 * 8 + 18446744073709551614) + -1 << 1))
   >>>;


;; Function static constexpr wchar_t std::numeric_limits<wchar_t>::max() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (wchar_t) (((1 << 4 * 8 + 18446744073709551614) + -1 << 1) + 1)
   >>>;


;; Function static constexpr wchar_t std::numeric_limits<wchar_t>::lowest() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::numeric_limits<wchar_t>::min ()>>
   >>>;


;; Function static constexpr wchar_t std::numeric_limits<wchar_t>::epsilon() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr wchar_t std::numeric_limits<wchar_t>::round_error() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr wchar_t std::numeric_limits<wchar_t>::infinity() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr wchar_t std::numeric_limits<wchar_t>::quiet_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr wchar_t std::numeric_limits<wchar_t>::signaling_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr wchar_t std::numeric_limits<wchar_t>::denorm_min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr char16_t std::numeric_limits<char16_t>::min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr char16_t std::numeric_limits<char16_t>::max() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 65535
   >>>;


;; Function static constexpr char16_t std::numeric_limits<char16_t>::lowest() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::numeric_limits<char16_t>::min ()>>
   >>>;


;; Function static constexpr char16_t std::numeric_limits<char16_t>::epsilon() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr char16_t std::numeric_limits<char16_t>::round_error() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr char16_t std::numeric_limits<char16_t>::infinity() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr char16_t std::numeric_limits<char16_t>::quiet_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr char16_t std::numeric_limits<char16_t>::signaling_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr char16_t std::numeric_limits<char16_t>::denorm_min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr char32_t std::numeric_limits<char32_t>::min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr char32_t std::numeric_limits<char32_t>::max() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 4294967295
   >>>;


;; Function static constexpr char32_t std::numeric_limits<char32_t>::lowest() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::numeric_limits<char32_t>::min ()>>
   >>>;


;; Function static constexpr char32_t std::numeric_limits<char32_t>::epsilon() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr char32_t std::numeric_limits<char32_t>::round_error() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr char32_t std::numeric_limits<char32_t>::infinity() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr char32_t std::numeric_limits<char32_t>::quiet_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr char32_t std::numeric_limits<char32_t>::signaling_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr char32_t std::numeric_limits<char32_t>::denorm_min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr short int std::numeric_limits<short int>::min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = -32768
   >>>;


;; Function static constexpr short int std::numeric_limits<short int>::max() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 32767
   >>>;


;; Function static constexpr short int std::numeric_limits<short int>::lowest() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::numeric_limits<short int>::min ()>>
   >>>;


;; Function static constexpr short int std::numeric_limits<short int>::epsilon() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr short int std::numeric_limits<short int>::round_error() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr short int std::numeric_limits<short int>::infinity() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr short int std::numeric_limits<short int>::quiet_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr short int std::numeric_limits<short int>::signaling_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr short int std::numeric_limits<short int>::denorm_min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr short unsigned int std::numeric_limits<short unsigned int>::min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr short unsigned int std::numeric_limits<short unsigned int>::max() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 65535
   >>>;


;; Function static constexpr short unsigned int std::numeric_limits<short unsigned int>::lowest() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::numeric_limits<short unsigned int>::min ()>>
   >>>;


;; Function static constexpr short unsigned int std::numeric_limits<short unsigned int>::epsilon() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr short unsigned int std::numeric_limits<short unsigned int>::round_error() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr short unsigned int std::numeric_limits<short unsigned int>::infinity() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr short unsigned int std::numeric_limits<short unsigned int>::quiet_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr short unsigned int std::numeric_limits<short unsigned int>::signaling_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr short unsigned int std::numeric_limits<short unsigned int>::denorm_min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr int std::numeric_limits<int>::min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = -2147483648
   >>>;


;; Function static constexpr int std::numeric_limits<int>::max() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 2147483647
   >>>;


;; Function static constexpr int std::numeric_limits<int>::lowest() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::numeric_limits<int>::min ()>>
   >>>;


;; Function static constexpr int std::numeric_limits<int>::epsilon() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr int std::numeric_limits<int>::round_error() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr int std::numeric_limits<int>::infinity() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr int std::numeric_limits<int>::quiet_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr int std::numeric_limits<int>::signaling_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr int std::numeric_limits<int>::denorm_min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr unsigned int std::numeric_limits<unsigned int>::min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr unsigned int std::numeric_limits<unsigned int>::max() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 4294967295
   >>>;


;; Function static constexpr unsigned int std::numeric_limits<unsigned int>::lowest() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::numeric_limits<unsigned int>::min ()>>
   >>>;


;; Function static constexpr unsigned int std::numeric_limits<unsigned int>::epsilon() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr unsigned int std::numeric_limits<unsigned int>::round_error() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr unsigned int std::numeric_limits<unsigned int>::infinity() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr unsigned int std::numeric_limits<unsigned int>::quiet_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr unsigned int std::numeric_limits<unsigned int>::signaling_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr unsigned int std::numeric_limits<unsigned int>::denorm_min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr long int std::numeric_limits<long int>::min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = -9223372036854775808
   >>>;


;; Function static constexpr long int std::numeric_limits<long int>::max() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 9223372036854775807
   >>>;


;; Function static constexpr long int std::numeric_limits<long int>::lowest() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::numeric_limits<long int>::min ()>>
   >>>;


;; Function static constexpr long int std::numeric_limits<long int>::epsilon() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr long int std::numeric_limits<long int>::round_error() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr long int std::numeric_limits<long int>::infinity() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr long int std::numeric_limits<long int>::quiet_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr long int std::numeric_limits<long int>::signaling_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr long int std::numeric_limits<long int>::denorm_min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr long unsigned int std::numeric_limits<long unsigned int>::min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr long unsigned int std::numeric_limits<long unsigned int>::max() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 18446744073709551615
   >>>;


;; Function static constexpr long unsigned int std::numeric_limits<long unsigned int>::lowest() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::numeric_limits<long unsigned int>::min ()>>
   >>>;


;; Function static constexpr long unsigned int std::numeric_limits<long unsigned int>::epsilon() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr long unsigned int std::numeric_limits<long unsigned int>::round_error() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr long unsigned int std::numeric_limits<long unsigned int>::infinity() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr long unsigned int std::numeric_limits<long unsigned int>::quiet_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr long unsigned int std::numeric_limits<long unsigned int>::signaling_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr long unsigned int std::numeric_limits<long unsigned int>::denorm_min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr long long int std::numeric_limits<long long int>::min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = -9223372036854775808
   >>>;


;; Function static constexpr long long int std::numeric_limits<long long int>::max() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 9223372036854775807
   >>>;


;; Function static constexpr long long int std::numeric_limits<long long int>::lowest() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::numeric_limits<long long int>::min ()>>
   >>>;


;; Function static constexpr long long int std::numeric_limits<long long int>::epsilon() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr long long int std::numeric_limits<long long int>::round_error() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr long long int std::numeric_limits<long long int>::infinity() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr long long int std::numeric_limits<long long int>::quiet_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr long long int std::numeric_limits<long long int>::signaling_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr long long int std::numeric_limits<long long int>::denorm_min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr long long unsigned int std::numeric_limits<long long unsigned int>::min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr long long unsigned int std::numeric_limits<long long unsigned int>::max() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 18446744073709551615
   >>>;


;; Function static constexpr long long unsigned int std::numeric_limits<long long unsigned int>::lowest() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::numeric_limits<long long unsigned int>::min ()>>
   >>>;


;; Function static constexpr long long unsigned int std::numeric_limits<long long unsigned int>::epsilon() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr long long unsigned int std::numeric_limits<long long unsigned int>::round_error() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr long long unsigned int std::numeric_limits<long long unsigned int>::infinity() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr long long unsigned int std::numeric_limits<long long unsigned int>::quiet_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr long long unsigned int std::numeric_limits<long long unsigned int>::signaling_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr long long unsigned int std::numeric_limits<long long unsigned int>::denorm_min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr float std::numeric_limits<float>::min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 1.17549435082228750796873653722224567781866555677208752151e-38
   >>>;


;; Function static constexpr float std::numeric_limits<float>::max() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 3.4028234663852885981170418348451692544e+38
   >>>;


;; Function static constexpr float std::numeric_limits<float>::lowest() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = -3.4028234663852885981170418348451692544e+38
   >>>;


;; Function static constexpr float std::numeric_limits<float>::epsilon() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 1.1920928955078125e-7
   >>>;


;; Function static constexpr float std::numeric_limits<float>::round_error() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 5.0e-1
   >>>;


;; Function static constexpr float std::numeric_limits<float>::infinity() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> =  Inf
   >>>;


;; Function static constexpr float std::numeric_limits<float>::quiet_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> =  Nan
   >>>;


;; Function static constexpr float std::numeric_limits<float>::signaling_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> =  Nan
   >>>;


;; Function static constexpr float std::numeric_limits<float>::denorm_min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 1.40129846432481707092372958328991613128026194187651577176e-45
   >>>;


;; Function static constexpr double std::numeric_limits<double>::min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 2.22507385850720138309023271733240406421921598046233183055e-308
   >>>;


;; Function static constexpr double std::numeric_limits<double>::max() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 1.79769313486231570814527423731704356798070567525844996599e+308
   >>>;


;; Function static constexpr double std::numeric_limits<double>::lowest() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = -1.79769313486231570814527423731704356798070567525844996599e+308
   >>>;


;; Function static constexpr double std::numeric_limits<double>::epsilon() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 2.220446049250313080847263336181640625e-16
   >>>;


;; Function static constexpr double std::numeric_limits<double>::round_error() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 5.0e-1
   >>>;


;; Function static constexpr double std::numeric_limits<double>::infinity() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> =  Inf
   >>>;


;; Function static constexpr double std::numeric_limits<double>::quiet_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> =  Nan
   >>>;


;; Function static constexpr double std::numeric_limits<double>::signaling_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> =  Nan
   >>>;


;; Function static constexpr double std::numeric_limits<double>::denorm_min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 4.94065645841246544176568792868221372365059802614324764425e-324
   >>>;


;; Function static constexpr long double std::numeric_limits<long double>::min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 3.36210314311209350626267781732175260259807934484647124011e-4932
   >>>;


;; Function static constexpr long double std::numeric_limits<long double>::max() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 1.18973149535723176502126385303097020516906332229462420044e+4932
   >>>;


;; Function static constexpr long double std::numeric_limits<long double>::lowest() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = -1.18973149535723176502126385303097020516906332229462420044e+4932
   >>>;


;; Function static constexpr long double std::numeric_limits<long double>::epsilon() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 1.08420217248550443400745280086994171142578125e-19
   >>>;


;; Function static constexpr long double std::numeric_limits<long double>::round_error() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 5.0e-1
   >>>;


;; Function static constexpr long double std::numeric_limits<long double>::infinity() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> =  Inf
   >>>;


;; Function static constexpr long double std::numeric_limits<long double>::quiet_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> =  Nan
   >>>;


;; Function static constexpr long double std::numeric_limits<long double>::signaling_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> =  Nan
   >>>;


;; Function static constexpr long double std::numeric_limits<long double>::denorm_min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 3.64519953188247460252840593361941981639905081569356334372e-4951
   >>>;


;; Function static constexpr _Rep std::chrono::duration_values<_Rep>::min() [with _Rep = long int] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = std::numeric_limits<long int>::lowest ()>>;


;; Function constexpr std::chrono::duration<_Rep, _Period>::duration(const _Rep2&) [with _Rep2 = long int; <template-parameter-2-2> = void; _Rep = long int; _Period = std::ratio<1l, 1000000000l>] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct duration *) this)->__r = (long int) *__rep) >>>>>;
}


;; Function static constexpr std::chrono::duration<_Rep, _Period> std::chrono::duration<_Rep, _Period>::min() [with _Rep = long int; _Period = std::ratio<1l, 1000000000l>] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = TARGET_EXPR <D.37285, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.37285
  (struct duration *) <<< Unknown tree: void_cst >>>
  (const long int &) &TARGET_EXPR <D.37281, std::chrono::duration_values<long int>::min ()> >>>>;, D.37285>>;


;; Function static constexpr _Rep std::chrono::duration_values<_Rep>::zero() [with _Rep = long int] (null)
;; enabled by -tree-original


return <retval> = 0;


;; Function static constexpr std::chrono::duration<_Rep, _Period> std::chrono::duration<_Rep, _Period>::zero() [with _Rep = long int; _Period = std::ratio<1l, 1000000000l>] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = TARGET_EXPR <D.37338, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.37338
  (struct duration *) <<< Unknown tree: void_cst >>>
  (const long int &) &TARGET_EXPR <D.37337, std::chrono::duration_values<long int>::zero ()> >>>>;, D.37338>>;


;; Function constexpr std::chrono::duration<_Rep, _Period>::rep std::chrono::duration<_Rep, _Period>::count() const [with _Rep = long int; _Period = std::ratio<1l, 1000000000l>; std::chrono::duration<_Rep, _Period>::rep = long int] (null)
;; enabled by -tree-original


return <retval> = (rep) ((const struct duration *) this)->__r;


;; Function constexpr bool std::chrono::operator<(const std::chrono::duration<_Rep1, _Period1>&, const std::chrono::duration<_Rep2, _Period2>&) [with _Rep1 = long int; _Period1 = std::ratio<1l, 1000000000l>; _Rep2 = long int; _Period2 = std::ratio<1l, 1000000000l>] (null)
;; enabled by -tree-original


{
  typedef struct __dur1 __dur1;
  typedef struct __dur2 __dur2;
  typedef struct __ct __ct;

  <<cleanup_point return <retval> = std::chrono::duration<long int, std::ratio<1l, 1000000000l> >::count (&TARGET_EXPR <D.37506, *(const struct duration &) (const struct duration *) __lhs>) < std::chrono::duration<long int, std::ratio<1l, 1000000000l> >::count (&TARGET_EXPR <D.37508, *(const struct duration &) (const struct duration *) __rhs>)>>;
}


;; Function constexpr std::chrono::time_point<_Clock, _Dur>::duration std::chrono::time_point<_Clock, _Dur>::time_since_epoch() const [with _Clock = std::chrono::_V2::system_clock; _Dur = std::chrono::duration<long int, std::ratio<1l, 1000000000l> >; std::chrono::time_point<_Clock, _Dur>::duration = std::chrono::duration<long int, std::ratio<1l, 1000000000l> >] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = TARGET_EXPR <D.37602, ((const struct time_point *) this)->__d>>>;


;; Function constexpr std::chrono::duration<_Rep, _Period>::duration(const _Rep2&) [with _Rep2 = long int; <template-parameter-2-2> = void; _Rep = long int; _Period = std::ratio<1l>] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct duration *) this)->__r = (long int) *__rep) >>>>>;
}


;; Function static constexpr _ToDur std::chrono::__duration_cast_impl<_ToDur, _CF, _CR, true, false>::__cast(const std::chrono::duration<_Rep, _Period>&) [with _Rep = long int; _Period = std::ratio<1l, 1000000000l>; _ToDur = std::chrono::duration<long int>; _CF = std::ratio<1l, 1000000000l>; _CR = long int] (null)
;; enabled by -tree-original


{
  typedef __to_rep __to_rep;

  <<cleanup_point return <retval> = TARGET_EXPR <D.37840, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.37840
  (struct duration *) <<< Unknown tree: void_cst >>>
  (const long int &) &TARGET_EXPR <D.37836, std::chrono::duration<long int, std::ratio<1l, 1000000000l> >::count ((const struct duration *) __d) / 1000000000> >>>>;, D.37840>>;
}


;; Function constexpr typename std::enable_if<std::chrono::__is_duration<_Tp>::value, _ToDur>::type std::chrono::duration_cast(const std::chrono::duration<_Rep, _Period>&) [with _ToDur = std::chrono::duration<long int>; _Rep = long int; _Period = std::ratio<1l, 1000000000l>; typename std::enable_if<std::chrono::__is_duration<_Tp>::value, _ToDur>::type = std::chrono::duration<long int>] (null)
;; enabled by -tree-original


{
  typedef struct __to_period __to_period;
  typedef __to_rep __to_rep;
  typedef struct __cf __cf;
  typedef __cr __cr;
  typedef struct __dc __dc;

  <<cleanup_point return <retval> = TARGET_EXPR <D.37864, std::chrono::__duration_cast_impl<std::chrono::duration<long int>, std::ratio<1l, 1000000000l>, long int, true, false>::__cast<long int, std::ratio<1l, 1000000000l> > ((const struct duration &) (const struct duration *) __d)>>>;
}


;; Function constexpr std::chrono::duration<_Rep, _Period>::rep std::chrono::duration<_Rep, _Period>::count() const [with _Rep = long int; _Period = std::ratio<1l>; std::chrono::duration<_Rep, _Period>::rep = long int] (null)
;; enabled by -tree-original


return <retval> = (rep) ((const struct duration *) this)->__r;


;; Function static time_t std::chrono::_V2::system_clock::to_time_t(const time_point&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::chrono::duration<long int>::count (&TARGET_EXPR <D.37865, std::chrono::duration_cast<std::chrono::duration<long int>, long int, std::ratio<1l, 1000000000l> > ((const struct duration &) (const struct duration *) &TARGET_EXPR <D.37603, std::chrono::time_point<std::chrono::_V2::system_clock, std::chrono::duration<long int, std::ratio<1l, 1000000000l> > >::time_since_epoch ((const struct time_point *) __t)>)>)>>
   >>>;


;; Function constexpr std::chrono::time_point<_Clock, _Dur>::time_point(const duration&) [with _Clock = std::chrono::_V2::system_clock; _Dur = std::chrono::duration<long int>; std::chrono::time_point<_Clock, _Dur>::duration = std::chrono::duration<long int>] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct time_point *) this)->__d = *(const struct duration &) (const struct duration *) __dur) >>>>>;
}


;; Function constexpr std::chrono::time_point<_Clock, _Dur>::duration std::chrono::time_point<_Clock, _Dur>::time_since_epoch() const [with _Clock = std::chrono::_V2::system_clock; _Dur = std::chrono::duration<long int>; std::chrono::time_point<_Clock, _Dur>::duration = std::chrono::duration<long int>] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = TARGET_EXPR <D.38081, ((const struct time_point *) this)->__d>>>;


;; Function static constexpr _ToDur std::chrono::__duration_cast_impl<_ToDur, _CF, _CR, false, true>::__cast(const std::chrono::duration<_Rep, _Period>&) [with _Rep = long int; _Period = std::ratio<1l>; _ToDur = std::chrono::duration<long int, std::ratio<1l, 1000000000l> >; _CF = std::ratio<1000000000l, 1l>; _CR = long int] (null)
;; enabled by -tree-original


{
  typedef __to_rep __to_rep;

  <<cleanup_point return <retval> = TARGET_EXPR <D.38140, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.38140
  (struct duration *) <<< Unknown tree: void_cst >>>
  (const long int &) &TARGET_EXPR <D.38139, std::chrono::duration<long int>::count ((const struct duration *) __d) * 1000000000> >>>>;, D.38140>>;
}


;; Function constexpr typename std::enable_if<std::chrono::__is_duration<_Tp>::value, _ToDur>::type std::chrono::duration_cast(const std::chrono::duration<_Rep, _Period>&) [with _ToDur = std::chrono::duration<long int, std::ratio<1l, 1000000000l> >; _Rep = long int; _Period = std::ratio<1l>; typename std::enable_if<std::chrono::__is_duration<_Tp>::value, _ToDur>::type = std::chrono::duration<long int, std::ratio<1l, 1000000000l> >] (null)
;; enabled by -tree-original


{
  typedef struct __to_period __to_period;
  typedef __to_rep __to_rep;
  typedef struct __cf __cf;
  typedef __cr __cr;
  typedef struct __dc __dc;

  <<cleanup_point return <retval> = TARGET_EXPR <D.38141, std::chrono::__duration_cast_impl<std::chrono::duration<long int, std::ratio<1l, 1000000000l> >, std::ratio<1000000000l, 1l>, long int, false, true>::__cast<long int, std::ratio<1l> > ((const struct duration &) (const struct duration *) __d)>>>;
}


;; Function constexpr std::chrono::time_point<_Clock, _Dur>::time_point(const duration&) [with _Clock = std::chrono::_V2::system_clock; _Dur = std::chrono::duration<long int, std::ratio<1l, 1000000000l> >; std::chrono::time_point<_Clock, _Dur>::duration = std::chrono::duration<long int, std::ratio<1l, 1000000000l> >] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct time_point *) this)->__d = *(const struct duration &) (const struct duration *) __dur) >>>>>;
}


;; Function constexpr typename std::enable_if<std::chrono::__is_duration<_Tp>::value, std::chrono::time_point<_Clock, _ToDur> >::type std::chrono::time_point_cast(const std::chrono::time_point<_Clock, _Dur>&) [with _ToDur = std::chrono::duration<long int, std::ratio<1l, 1000000000l> >; _Clock = std::chrono::_V2::system_clock; _Dur = std::chrono::duration<long int>; typename std::enable_if<std::chrono::__is_duration<_Tp>::value, std::chrono::time_point<_Clock, _ToDur> >::type = std::chrono::time_point<std::chrono::_V2::system_clock, std::chrono::duration<long int, std::ratio<1l, 1000000000l> > >] (null)
;; enabled by -tree-original


{
  typedef struct __time_point __time_point;

  <<cleanup_point return <retval> = TARGET_EXPR <D.38164, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.38164
  (struct time_point *) <<< Unknown tree: void_cst >>>
  (const struct duration &) (const struct duration *) &TARGET_EXPR <D.38142, std::chrono::duration_cast<std::chrono::duration<long int, std::ratio<1l, 1000000000l> >, long int, std::ratio<1l> > ((const struct duration &) (const struct duration *) &TARGET_EXPR <D.38082, std::chrono::time_point<std::chrono::_V2::system_clock, std::chrono::duration<long int> >::time_since_epoch ((const struct time_point *) __t)>)> >>>>;, D.38164>>;
}


;; Function static std::chrono::_V2::system_clock::time_point std::chrono::_V2::system_clock::from_time_t(time_t) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    typedef struct __from __from;

    <<cleanup_point return <retval> = TARGET_EXPR <D.38183, std::chrono::time_point_cast<std::chrono::duration<long int, std::ratio<1l, 1000000000l> >, std::chrono::_V2::system_clock, std::chrono::duration<long int> > ((const struct time_point &) (const struct time_point *) &TARGET_EXPR <D.38057, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.38057
  (struct time_point *) <<< Unknown tree: void_cst >>>
  (const struct duration &) (const struct duration *) &TARGET_EXPR <D.37870, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.37870
  (struct duration *) <<< Unknown tree: void_cst >>>
  (const long int &) (const long int *) &__t >>>> >>>>)>>>;
  }
   >>>;


;; Function constexpr std::chrono::duration<_Rep, _Period>::duration(const _Rep2&) [with _Rep2 = long double; <template-parameter-2-2> = void; _Rep = long double; _Period = std::ratio<3600l>] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct duration *) this)->__r = (long double) *__rep) >>>>>;
}


;; Function constexpr std::chrono::duration<long double, std::ratio<3600l> > std::literals::chrono_literals::operator""h(long double) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = TARGET_EXPR <D.38526, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.38526
  (struct duration *) <<< Unknown tree: void_cst >>>
  (const long double &) (const long double *) &__hours >>>>;, D.38526>>;


;; Function constexpr std::chrono::duration<_Rep, _Period>::duration(const _Rep2&) [with _Rep2 = long double; <template-parameter-2-2> = void; _Rep = long double; _Period = std::ratio<60l>] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct duration *) this)->__r = (long double) *__rep) >>>>>;
}


;; Function constexpr std::chrono::duration<long double, std::ratio<60l> > std::literals::chrono_literals::operator""min(long double) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = TARGET_EXPR <D.38918, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.38918
  (struct duration *) <<< Unknown tree: void_cst >>>
  (const long double &) (const long double *) &__mins >>>>;, D.38918>>;


;; Function constexpr std::chrono::duration<_Rep, _Period>::duration(const _Rep2&) [with _Rep2 = long double; <template-parameter-2-2> = void; _Rep = long double; _Period = std::ratio<1l>] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct duration *) this)->__r = (long double) *__rep) >>>>>;
}


;; Function constexpr std::chrono::duration<long double> std::literals::chrono_literals::operator""s(long double) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = TARGET_EXPR <D.39299, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.39299
  (struct duration *) <<< Unknown tree: void_cst >>>
  (const long double &) (const long double *) &__secs >>>>;, D.39299>>;


;; Function constexpr std::chrono::duration<_Rep, _Period>::duration(const _Rep2&) [with _Rep2 = long double; <template-parameter-2-2> = void; _Rep = long double; _Period = std::ratio<1l, 1000l>] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct duration *) this)->__r = (long double) *__rep) >>>>>;
}


;; Function constexpr std::chrono::duration<long double, std::ratio<1l, 1000l> > std::literals::chrono_literals::operator""ms(long double) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = TARGET_EXPR <D.39512, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.39512
  (struct duration *) <<< Unknown tree: void_cst >>>
  (const long double &) (const long double *) &__msecs >>>>;, D.39512>>;


;; Function constexpr std::chrono::duration<_Rep, _Period>::duration(const _Rep2&) [with _Rep2 = long double; <template-parameter-2-2> = void; _Rep = long double; _Period = std::ratio<1l, 1000000l>] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct duration *) this)->__r = (long double) *__rep) >>>>>;
}


;; Function constexpr std::chrono::duration<long double, std::ratio<1l, 1000000l> > std::literals::chrono_literals::operator""us(long double) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = TARGET_EXPR <D.39903, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.39903
  (struct duration *) <<< Unknown tree: void_cst >>>
  (const long double &) (const long double *) &__usecs >>>>;, D.39903>>;


;; Function constexpr std::chrono::duration<_Rep, _Period>::duration(const _Rep2&) [with _Rep2 = long double; <template-parameter-2-2> = void; _Rep = long double; _Period = std::ratio<1l, 1000000000l>] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct duration *) this)->__r = (long double) *__rep) >>>>>;
}


;; Function constexpr std::chrono::duration<long double, std::ratio<1l, 1000000000l> > std::literals::chrono_literals::operator""ns(long double) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = TARGET_EXPR <D.40267, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.40267
  (struct duration *) <<< Unknown tree: void_cst >>>
  (const long double &) (const long double *) &__nsecs >>>>;, D.40267>>;


;; Function const char* std::type_info::name() const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (signed char) *(const char *) ((const struct type_info *) this)->__name == 42 ? (const char *) ((const struct type_info *) this)->__name + 1 : (const char *) ((const struct type_info *) this)->__name
   >>>;


;; Function bool std::type_info::before(const std::type_info&) const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (signed char) *(const char *) ((const struct type_info *) this)->__name == 42 && (signed char) *(const char *) __arg->__name == 42 ? (const char *) ((const struct type_info *) this)->__name < (const char *) __arg->__name : __builtin_strcmp ((const char *) ((const struct type_info *) this)->__name, (const char *) __arg->__name) < 0
   >>>;


;; Function bool std::type_info::operator==(const std::type_info&) const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (const char *) ((const struct type_info *) this)->__name == (const char *) __arg->__name || (signed char) *(const char *) ((const struct type_info *) this)->__name != 42 && __builtin_strcmp ((const char *) ((const struct type_info *) this)->__name, (const char *) __arg->__name) == 0
   >>>;


;; Function bool std::type_info::operator!=(const std::type_info&) const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = !std::type_info::operator== (this, (const struct type_info &) (const struct type_info *) __arg)>>
   >>>;


;; Function std::size_t std::type_info::hash_code() const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::_Hash_bytes ((const void *) std::type_info::name (this), __builtin_strlen (std::type_info::name (this)), 3339675911)>>
   >>>;


;; Function std::type_info::type_info(const char*) (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct type_info *) this)->_vptr.type_info = &_ZTVSt9type_info + 16) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct type_info *) this)->__name = __n) >>>>>;
}


;; Function std::bad_cast::bad_cast() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::exception::exception (&((struct bad_cast *) this)->D.40379) >>>>>;
    try
      {
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct bad_cast *) this)->D.40379._vptr.exception = &_ZTVSt8bad_cast + 16) >>>>>;
      }
    catch
      {
        std::exception::~exception (&((struct bad_cast *) this)->D.40379);
      }
  }
   >>>;


;; Function std::bad_typeid::bad_typeid() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::exception::exception (&((struct bad_typeid *) this)->D.40408) >>>>>;
    try
      {
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct bad_typeid *) this)->D.40408._vptr.exception = &_ZTVSt10bad_typeid + 16) >>>>>;
      }
    catch
      {
        std::exception::~exception (&((struct bad_typeid *) this)->D.40408);
      }
  }
   >>>;


;; Function void std::__uses_alloc0::_Sink::operator=(const void*) (null)
;; enabled by -tree-original





;; Function void std::tuple<>::swap(std::tuple<>&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  
   >>>;


;; Function void* std::_Any_data::_M_access() (null)
;; enabled by -tree-original


return <retval> = (void *) &((union _Any_data *) this)->_M_pod_data[0];


;; Function const void* std::_Any_data::_M_access() const (null)
;; enabled by -tree-original


return <retval> = (const void *) &((const union _Any_data *) this)->_M_pod_data[0];


;; Function std::_Function_base::_Function_base() (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Function_base *) this)->_M_manager = 0B) >>>>>;
}


;; Function std::_Function_base::~_Function_base() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    try
      {
        if (((struct _Function_base *) this)->_M_manager != 0B)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) ((struct _Function_base *) this)->_M_manager ((union _Any_data &) &((struct _Function_base *) this)->_M_functor, (const union _Any_data &) (const union _Any_data *) &((struct _Function_base *) this)->_M_functor, 3) >>>>>;
          }
      }
    finally
      {
        *(struct 
        {
          union _Any_data _M_functor;
          bool (*_Manager_type) (union _Any_data &, const union _Any_data &, _Manager_operation) _M_manager;
        } &) this = {CLOBBER};
      }
  }
  <D.45293>:;
   >>>;


;; Function bool std::_Function_base::_M_empty() const (null)
;; enabled by -tree-original


return <retval> = (bool (*_Manager_type) (union _Any_data &, const union _Any_data &, _Manager_operation)) ((const struct _Function_base *) this)->_M_manager == 0B;


;; Function virtual const char* __gnu_cxx::__concurrence_lock_error::what() const (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  return <retval> = (const char *) "__gnu_cxx::__concurrence_lock_error"
   >>>;


;; Function virtual const char* __gnu_cxx::__concurrence_unlock_error::what() const (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  return <retval> = (const char *) "__gnu_cxx::__concurrence_unlock_error"
   >>>;


;; Function virtual const char* __gnu_cxx::__concurrence_broadcast_error::what() const (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  return <retval> = (const char *) "__gnu_cxx::__concurrence_broadcast_error"
   >>>;


;; Function virtual const char* __gnu_cxx::__concurrence_wait_error::what() const (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  return <retval> = (const char *) "__gnu_cxx::__concurrence_wait_error"
   >>>;


;; Function __gnu_cxx::__concurrence_lock_error::__concurrence_lock_error() (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::exception::exception (&((struct __concurrence_lock_error *) this)->D.46335) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __concurrence_lock_error *) this)->D.46335._vptr.exception = &_ZTVN9__gnu_cxx24__concurrence_lock_errorE + 16) >>>>>;
    }
  catch
    {
      std::exception::~exception (&((struct __concurrence_lock_error *) this)->D.46335);
    }
}


;; Function constexpr std::exception::exception(const std::exception&) (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct exception *) this)->_vptr.exception = &_ZTVSt9exception + 16) >>>>>;
}


;; Function constexpr __gnu_cxx::__concurrence_lock_error::__concurrence_lock_error(__gnu_cxx::__concurrence_lock_error&&) (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::exception::exception (&((struct __concurrence_lock_error *) this)->D.46335, (const struct exception &) (const struct exception *) NON_LVALUE_EXPR <(struct exception &) &((struct __concurrence_lock_error *) D.46433)->D.46335>) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __concurrence_lock_error *) this)->D.46335._vptr.exception = &_ZTVN9__gnu_cxx24__concurrence_lock_errorE + 16) >>>>>;
    }
  catch
    {
      std::exception::~exception (&((struct __concurrence_lock_error *) this)->D.46335);
    }
}


;; Function void __gnu_cxx::__throw_concurrence_lock_error() (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  <<< Unknown tree: throw_expr
  <<cleanup_point TARGET_EXPR <D.46447, __cxa_allocate_exception (8)>;, *(struct __concurrence_lock_error *) D.46447 = TARGET_EXPR <D.46444, <<< Unknown tree: aggr_init_expr
  4
  __comp_ctor 
  D.46444
  (struct __concurrence_lock_error *) <<< Unknown tree: void_cst >>> >>>>;>>;, __cxa_throw (D.46447, (void *) &_ZTIN9__gnu_cxx24__concurrence_lock_errorE, __comp_dtor ); >>> >>>>>;


;; Function __gnu_cxx::__concurrence_unlock_error::__concurrence_unlock_error() (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::exception::exception (&((struct __concurrence_unlock_error *) this)->D.46362) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __concurrence_unlock_error *) this)->D.46362._vptr.exception = &_ZTVN9__gnu_cxx26__concurrence_unlock_errorE + 16) >>>>>;
    }
  catch
    {
      std::exception::~exception (&((struct __concurrence_unlock_error *) this)->D.46362);
    }
}


;; Function constexpr __gnu_cxx::__concurrence_unlock_error::__concurrence_unlock_error(__gnu_cxx::__concurrence_unlock_error&&) (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::exception::exception (&((struct __concurrence_unlock_error *) this)->D.46362, (const struct exception &) (const struct exception *) NON_LVALUE_EXPR <(struct exception &) &((struct __concurrence_unlock_error *) D.46467)->D.46362>) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __concurrence_unlock_error *) this)->D.46362._vptr.exception = &_ZTVN9__gnu_cxx26__concurrence_unlock_errorE + 16) >>>>>;
    }
  catch
    {
      std::exception::~exception (&((struct __concurrence_unlock_error *) this)->D.46362);
    }
}


;; Function void __gnu_cxx::__throw_concurrence_unlock_error() (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  <<< Unknown tree: throw_expr
  <<cleanup_point TARGET_EXPR <D.46479, __cxa_allocate_exception (8)>;, *(struct __concurrence_unlock_error *) D.46479 = TARGET_EXPR <D.46478, <<< Unknown tree: aggr_init_expr
  4
  __comp_ctor 
  D.46478
  (struct __concurrence_unlock_error *) <<< Unknown tree: void_cst >>> >>>>;>>;, __cxa_throw (D.46479, (void *) &_ZTIN9__gnu_cxx26__concurrence_unlock_errorE, __comp_dtor ); >>> >>>>>;


;; Function __gnu_cxx::__concurrence_broadcast_error::__concurrence_broadcast_error() (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::exception::exception (&((struct __concurrence_broadcast_error *) this)->D.46389) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __concurrence_broadcast_error *) this)->D.46389._vptr.exception = &_ZTVN9__gnu_cxx29__concurrence_broadcast_errorE + 16) >>>>>;
    }
  catch
    {
      std::exception::~exception (&((struct __concurrence_broadcast_error *) this)->D.46389);
    }
}


;; Function constexpr __gnu_cxx::__concurrence_broadcast_error::__concurrence_broadcast_error(__gnu_cxx::__concurrence_broadcast_error&&) (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::exception::exception (&((struct __concurrence_broadcast_error *) this)->D.46389, (const struct exception &) (const struct exception *) NON_LVALUE_EXPR <(struct exception &) &((struct __concurrence_broadcast_error *) D.46495)->D.46389>) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __concurrence_broadcast_error *) this)->D.46389._vptr.exception = &_ZTVN9__gnu_cxx29__concurrence_broadcast_errorE + 16) >>>>>;
    }
  catch
    {
      std::exception::~exception (&((struct __concurrence_broadcast_error *) this)->D.46389);
    }
}


;; Function void __gnu_cxx::__throw_concurrence_broadcast_error() (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  <<< Unknown tree: throw_expr
  <<cleanup_point TARGET_EXPR <D.46507, __cxa_allocate_exception (8)>;, *(struct __concurrence_broadcast_error *) D.46507 = TARGET_EXPR <D.46506, <<< Unknown tree: aggr_init_expr
  4
  __comp_ctor 
  D.46506
  (struct __concurrence_broadcast_error *) <<< Unknown tree: void_cst >>> >>>>;>>;, __cxa_throw (D.46507, (void *) &_ZTIN9__gnu_cxx29__concurrence_broadcast_errorE, __comp_dtor ); >>> >>>>>;


;; Function __gnu_cxx::__concurrence_wait_error::__concurrence_wait_error() (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::exception::exception (&((struct __concurrence_wait_error *) this)->D.46416) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __concurrence_wait_error *) this)->D.46416._vptr.exception = &_ZTVN9__gnu_cxx24__concurrence_wait_errorE + 16) >>>>>;
    }
  catch
    {
      std::exception::~exception (&((struct __concurrence_wait_error *) this)->D.46416);
    }
}


;; Function constexpr __gnu_cxx::__concurrence_wait_error::__concurrence_wait_error(__gnu_cxx::__concurrence_wait_error&&) (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::exception::exception (&((struct __concurrence_wait_error *) this)->D.46416, (const struct exception &) (const struct exception *) NON_LVALUE_EXPR <(struct exception &) &((struct __concurrence_wait_error *) D.46523)->D.46416>) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __concurrence_wait_error *) this)->D.46416._vptr.exception = &_ZTVN9__gnu_cxx24__concurrence_wait_errorE + 16) >>>>>;
    }
  catch
    {
      std::exception::~exception (&((struct __concurrence_wait_error *) this)->D.46416);
    }
}


;; Function void __gnu_cxx::__throw_concurrence_wait_error() (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  <<< Unknown tree: throw_expr
  <<cleanup_point TARGET_EXPR <D.46535, __cxa_allocate_exception (8)>;, *(struct __concurrence_wait_error *) D.46535 = TARGET_EXPR <D.46534, <<< Unknown tree: aggr_init_expr
  4
  __comp_ctor 
  D.46534
  (struct __concurrence_wait_error *) <<< Unknown tree: void_cst >>> >>>>;>>;, __cxa_throw (D.46535, (void *) &_ZTIN9__gnu_cxx24__concurrence_wait_errorE, __comp_dtor ); >>> >>>>>;


;; Function __gnu_cxx::__mutex::__mutex() (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __mutex *) this)->_M_mutex = {.__data={.__lock=0, .__count=0, .__owner=0, .__nusers=0, .__kind=0, .__spins=0, .__elision=0, .__list={.__prev=0B, .__next=0B}}}) >>>>>;
}


;; Function void __gnu_cxx::__mutex::lock() (null)
;; enabled by -tree-original


if (<<cleanup_point __gthread_active_p () != 0>>)
  {
    if (<<cleanup_point __gthread_mutex_lock (&((struct __mutex *) this)->_M_mutex) != 0>>)
      {
        <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::__throw_concurrence_lock_error () >>>>>;
      }
  }


;; Function void __gnu_cxx::__mutex::unlock() (null)
;; enabled by -tree-original


if (<<cleanup_point __gthread_active_p () != 0>>)
  {
    if (<<cleanup_point __gthread_mutex_unlock (&((struct __mutex *) this)->_M_mutex) != 0>>)
      {
        <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::__throw_concurrence_unlock_error () >>>>>;
      }
  }


;; Function __gthread_mutex_t* __gnu_cxx::__mutex::gthread_mutex() (null)
;; enabled by -tree-original


return <retval> = &((struct __mutex *) this)->_M_mutex;


;; Function __gnu_cxx::__recursive_mutex::__recursive_mutex() (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __recursive_mutex *) this)->_M_mutex = {.__data={.__lock=0, .__count=0, .__owner=0, .__nusers=0, .__kind=1, .__spins=0, .__elision=0, .__list={.__prev=0B, .__next=0B}}}) >>>>>;
}


;; Function void __gnu_cxx::__recursive_mutex::lock() (null)
;; enabled by -tree-original


if (<<cleanup_point __gthread_active_p () != 0>>)
  {
    if (<<cleanup_point __gthread_recursive_mutex_lock (&((struct __recursive_mutex *) this)->_M_mutex) != 0>>)
      {
        <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::__throw_concurrence_lock_error () >>>>>;
      }
  }


;; Function void __gnu_cxx::__recursive_mutex::unlock() (null)
;; enabled by -tree-original


if (<<cleanup_point __gthread_active_p () != 0>>)
  {
    if (<<cleanup_point __gthread_recursive_mutex_unlock (&((struct __recursive_mutex *) this)->_M_mutex) != 0>>)
      {
        <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::__throw_concurrence_unlock_error () >>>>>;
      }
  }


;; Function __gthread_recursive_mutex_t* __gnu_cxx::__recursive_mutex::gthread_recursive_mutex() (null)
;; enabled by -tree-original


return <retval> = &((struct __recursive_mutex *) this)->_M_mutex;


;; Function __gnu_cxx::__scoped_lock::__scoped_lock(__gnu_cxx::__scoped_lock::__mutex_type&) (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __scoped_lock *) this)->_M_device = (struct __mutex_type &) (struct __mutex_type *) __name) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::__mutex::lock ((struct __mutex_type *) ((struct __scoped_lock *) this)->_M_device) >>>>>;
}


;; Function __gnu_cxx::__scoped_lock::~__scoped_lock() (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  {
    try
      {
        <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::__mutex::unlock ((struct __mutex_type *) ((struct __scoped_lock *) this)->_M_device) >>>>>;
      }
    finally
      {
        *(struct 
        {
          struct __mutex_type & _M_device;
        } &) this = {CLOBBER};
      }
  }
  <D.46675>:;
   >>>;


;; Function __gnu_cxx::__cond::__cond() (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __cond *) this)->_M_cond = {.__data={.__lock=0, .__futex=0, .__total_seq=0, .__wakeup_seq=0, .__woken_seq=0, .__mutex=0B, .__nwaiters=0, .__broadcast_seq=0}}) >>>>>;
}


;; Function void __gnu_cxx::__cond::broadcast() (null)
;; enabled by -tree-original


if (<<cleanup_point __gthread_active_p () != 0>>)
  {
    if (<<cleanup_point __gthread_cond_broadcast (&((struct __cond *) this)->_M_cond) != 0>>)
      {
        <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::__throw_concurrence_broadcast_error () >>>>>;
      }
  }


;; Function void __gnu_cxx::__cond::wait(__gnu_cxx::__mutex*) (null)
;; enabled by -tree-original


if (<<cleanup_point __gthread_cond_wait (&((struct __cond *) this)->_M_cond, __gnu_cxx::__mutex::gthread_mutex (NON_LVALUE_EXPR <mutex>)) != 0>>)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::__throw_concurrence_wait_error () >>>>>;
  }


;; Function void __gnu_cxx::__cond::wait_recursive(__gnu_cxx::__recursive_mutex*) (null)
;; enabled by -tree-original


if (<<cleanup_point __gthread_cond_wait_recursive (&((struct __cond *) this)->_M_cond, __gnu_cxx::__recursive_mutex::gthread_recursive_mutex (NON_LVALUE_EXPR <mutex>)) != 0>>)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::__throw_concurrence_wait_error () >>>>>;
  }


;; Function std::bad_weak_ptr::bad_weak_ptr() (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::exception::exception (&((struct bad_weak_ptr *) this)->D.47588) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct bad_weak_ptr *) this)->D.47588._vptr.exception = &_ZTVSt12bad_weak_ptr + 16) >>>>>;
    }
  catch
    {
      std::exception::~exception (&((struct bad_weak_ptr *) this)->D.47588);
    }
}


;; Function constexpr std::bad_weak_ptr::bad_weak_ptr(const std::bad_weak_ptr&) (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::exception::exception (&((struct bad_weak_ptr *) this)->D.47588, (const struct exception &) &((const struct bad_weak_ptr *) D.47595)->D.47588) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct bad_weak_ptr *) this)->D.47588._vptr.exception = &_ZTVSt12bad_weak_ptr + 16) >>>>>;
    }
  catch
    {
      std::exception::~exception (&((struct bad_weak_ptr *) this)->D.47588);
    }
}


;; Function void std::__throw_bad_weak_ptr() (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  <<< Unknown tree: throw_expr
  <<cleanup_point TARGET_EXPR <D.47607, __cxa_allocate_exception (8)>;, *(struct bad_weak_ptr *) D.47607 = TARGET_EXPR <D.47606, <<< Unknown tree: aggr_init_expr
  4
  __comp_ctor 
  D.47606
  (struct bad_weak_ptr *) <<< Unknown tree: void_cst >>> >>>>;>>;, __cxa_throw (D.47607, (void *) &_ZTISt12bad_weak_ptr, __comp_dtor ); >>> >>>>>;


;; Function void std::_Sp_counted_base<_Lp>::_M_add_ref_lock() [with __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)0u] (null)
;; enabled by -tree-original


if (((struct _Sp_counted_base *) this)->_M_use_count == 0)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_bad_weak_ptr () >>>>>;
  }
<<cleanup_point <<< Unknown tree: expr_stmt
  (void)  ++((struct _Sp_counted_base *) this)->_M_use_count >>>>>;


;; Function void std::_Sp_counted_base<_Lp>::_M_add_ref_lock() [with __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)1u] (null)
;; enabled by -tree-original


{
  struct __scoped_lock sentry;

    struct __scoped_lock sentry;
  <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::__scoped_lock::__scoped_lock (&sentry, (struct __mutex_type &) &((struct _Sp_counted_base *) this)->D.47846.D.47644) >>>>>;
  try
    {
      if (<<cleanup_point __gnu_cxx::__exchange_and_add_dispatch (&((struct _Sp_counted_base *) this)->_M_use_count, 1) == 0>>)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Sp_counted_base *) this)->_M_use_count = 0) >>>>>;
          <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_bad_weak_ptr () >>>>>;
        }
    }
  finally
    {
      __gnu_cxx::__scoped_lock::~__scoped_lock (&sentry);
    }
}


;; Function void std::_Sp_counted_base<_Lp>::_M_add_ref_lock() [with __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


{
  _Atomic_word __count;

    _Atomic_word __count;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__count = (_Atomic_word) std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2u>::_M_get_use_count (this)) >>>>>;
  while (1)
    {
      if (__count == 0)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_bad_weak_ptr () >>>>>;
        }
      if (<<cleanup_point !__atomic_compare_exchange_4 ((volatile void *) &((struct _Sp_counted_base *) this)->_M_use_count, (void *) &__count, (unsigned int) (__count + 1), 1, 4, 0)>>) (void) 0; else goto <D.47933>;
    }
  <D.47933>:;
}


;; Function bool std::_Sp_counted_base<_Lp>::_M_add_ref_lock_nothrow() [with __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)0u] (null)
;; enabled by -tree-original


if (((struct _Sp_counted_base *) this)->_M_use_count == 0)
  {
    return <retval> = 0;
  }
<<cleanup_point <<< Unknown tree: expr_stmt
  (void)  ++((struct _Sp_counted_base *) this)->_M_use_count >>>>>;
return <retval> = 1;


;; Function bool std::_Sp_counted_base<_Lp>::_M_add_ref_lock_nothrow() [with __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)1u] (null)
;; enabled by -tree-original


{
  struct __scoped_lock sentry;

    struct __scoped_lock sentry;
  <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::__scoped_lock::__scoped_lock (&sentry, (struct __mutex_type &) &((struct _Sp_counted_base *) this)->D.47846.D.47644) >>>>>;
  try
    {
      if (<<cleanup_point __gnu_cxx::__exchange_and_add_dispatch (&((struct _Sp_counted_base *) this)->_M_use_count, 1) == 0>>)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Sp_counted_base *) this)->_M_use_count = 0) >>>>>;
          return <retval> = 0;
        }
      return <retval> = 1;
    }
  finally
    {
      __gnu_cxx::__scoped_lock::~__scoped_lock (&sentry);
    }
}


;; Function bool std::_Sp_counted_base<_Lp>::_M_add_ref_lock_nothrow() [with __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


{
  _Atomic_word __count;

    _Atomic_word __count;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__count = (_Atomic_word) std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2u>::_M_get_use_count (this)) >>>>>;
  while (1)
    {
      if (__count == 0)
        {
          return <retval> = 0;
        }
      if (<<cleanup_point !__atomic_compare_exchange_4 ((volatile void *) &((struct _Sp_counted_base *) this)->_M_use_count, (void *) &__count, (unsigned int) (__count + 1), 1, 4, 0)>>) (void) 0; else goto <D.47946>;
    }
  <D.47946>:;
  return <retval> = 1;
}


;; Function void std::_Sp_counted_base<_Lp>::_M_add_ref_copy() [with __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)0u] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void)  ++((struct _Sp_counted_base *) this)->_M_use_count >>>>>;


;; Function void std::_Sp_counted_base<_Lp>::_M_release() [with __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)0u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  if (<<cleanup_point  --((struct _Sp_counted_base *) this)->_M_use_count == 0>>)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  OBJ_TYPE_REF(*(((struct _Sp_counted_base *) this)->_vptr._Sp_counted_base + 16);(struct _Sp_counted_base)this->2) (this) >>>>>;
      if (<<cleanup_point  --((struct _Sp_counted_base *) this)->_M_weak_count == 0>>)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  OBJ_TYPE_REF(*(((struct _Sp_counted_base *) this)->_vptr._Sp_counted_base + 24);(struct _Sp_counted_base)this->3) (this) >>>>>;
        }
    }
   >>>;


;; Function void std::_Sp_counted_base<_Lp>::_M_weak_add_ref() [with __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)0u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void)  ++((struct _Sp_counted_base *) this)->_M_weak_count >>>>>
   >>>;


;; Function void std::_Sp_counted_base<_Lp>::_M_weak_release() [with __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)0u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  if (<<cleanup_point  --((struct _Sp_counted_base *) this)->_M_weak_count == 0>>)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  OBJ_TYPE_REF(*(((struct _Sp_counted_base *) this)->_vptr._Sp_counted_base + 24);(struct _Sp_counted_base)this->3) (this) >>>>>;
    }
   >>>;


;; Function long int std::_Sp_counted_base<_Lp>::_M_get_use_count() const [with __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)0u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (long int) ((const struct _Sp_counted_base *) this)->_M_use_count
   >>>;


;; Function void std::_Sp_counted_ptr<_Ptr, _Lp>::_M_dispose() [with _Ptr = std::nullptr_t; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)0u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  
   >>>;


;; Function void std::_Sp_counted_ptr<_Ptr, _Lp>::_M_dispose() [with _Ptr = std::nullptr_t; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)1u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  
   >>>;


;; Function void std::_Sp_counted_ptr<_Ptr, _Lp>::_M_dispose() [with _Ptr = std::nullptr_t; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  
   >>>;


;; Function constexpr std::memory_order std::operator|(std::memory_order, std::__memory_order_modifier) (null)
;; enabled by -tree-original


return <retval> = (memory_order) ((int) __m | (int) __mod);


;; Function constexpr std::memory_order std::operator&(std::memory_order, std::__memory_order_modifier) (null)
;; enabled by -tree-original


return <retval> = (memory_order) ((int) __m & (int) __mod);


;; Function constexpr std::memory_order std::__cmpexch_failure_order2(std::memory_order) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = __m != 4 ? __m != 3 ? __m : 0 : 2
   >>>;


;; Function constexpr std::memory_order std::__cmpexch_failure_order(std::memory_order) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (memory_order) ((int) std::__cmpexch_failure_order2 (std::operator& (__m, 65535)) | (int) std::operator& (__m, 4294901760))>>
   >>>;


;; Function void std::atomic_thread_fence(std::memory_order) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  __atomic_thread_fence ((int) __m) >>>>>
   >>>;


;; Function void std::atomic_signal_fence(std::memory_order) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  __atomic_signal_fence ((int) __m) >>>>>
   >>>;


;; Function constexpr std::atomic_flag::atomic_flag(bool) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct atomic_flag *) this)->D.50109 = {._M_i=std::atomic_flag::_S_init ((int) __i)}) >>>>>;
  }
   >>>;


;; Function bool std::atomic_flag::test_and_set(std::memory_order) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = __atomic_test_and_set ((volatile void *) &((struct atomic_flag *) this)->D.50109._M_i, (int) __m)>>
   >>>;


;; Function bool std::atomic_flag::test_and_set(std::memory_order) volatile (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = __atomic_test_and_set ((volatile void *) &((volatile struct atomic_flag *) this)->D.50109._M_i, (int) __m)>>
   >>>;


;; Function void std::atomic_flag::clear(std::memory_order) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    memory_order __b;

        memory_order __b;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__b = std::operator& (__m, 65535)) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  __atomic_clear ((volatile void *) &((struct atomic_flag *) this)->D.50109._M_i, (int) __m) >>>>>;
  }
   >>>;


;; Function void std::atomic_flag::clear(std::memory_order) volatile (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    memory_order __b;

        memory_order __b;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__b = std::operator& (__m, 65535)) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  __atomic_clear ((volatile void *) &((volatile struct atomic_flag *) this)->D.50109._M_i, (int) __m) >>>>>;
  }
   >>>;


;; Function static constexpr std::__atomic_flag_data_type std::atomic_flag::_S_init(bool) (null)
;; enabled by -tree-original


return <retval> = __i;


;; Function void* std::align(std::size_t, std::size_t, void*&, std::size_t&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    const long unsigned int __intptr = (uintptr_t) *__ptr;
    const long unsigned int __aligned = ((long unsigned int) __intptr + (long unsigned int) __align) + 18446744073709551615 & -NON_LVALUE_EXPR <__align>;
    const long unsigned int __diff = (long unsigned int) __aligned - (long unsigned int) __intptr;

        const long unsigned int __intptr = (uintptr_t) *__ptr;
        const long unsigned int __aligned = ((long unsigned int) __intptr + (long unsigned int) __align) + 18446744073709551615 & -NON_LVALUE_EXPR <__align>;
        const long unsigned int __diff = (long unsigned int) __aligned - (long unsigned int) __intptr;
    if (__size + (long unsigned int) __diff > *__space)
      {
        return <retval> = 0B;
      }
    else
      {
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__space = *__space - NON_LVALUE_EXPR <__diff>) >>>>>;
        <<cleanup_point return <retval> = *__ptr = (void *) __aligned>>;
      }
  }
   >>>;


;; Function std::thread::id::id() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct id *) this)->_M_thread = 0) >>>>>;
  }
   >>>;


;; Function std::thread::id::id(std::thread::native_handle_type) (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct id *) this)->_M_thread = __id) >>>>>;
}


;; Function bool std::operator==(std::thread::id, std::thread::id) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = __gthread_equal (__x._M_thread, __y._M_thread) != 0>>
   >>>;


;; Function bool std::operator<(std::thread::id, std::thread::id) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = __x._M_thread < __y._M_thread
   >>>;


;; Function std::thread::thread(std::thread&&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::thread::id::id (&((struct thread *) this)->_M_id) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::thread::swap (this, (struct thread &) (struct thread *) __t) >>>>>;
  }
   >>>;


;; Function std::thread::~thread() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    try
      {
        if (<<cleanup_point std::thread::joinable (this)>>)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  std::terminate () >>>>>;
          }
      }
    finally
      {
        *(struct 
        {
          struct id _M_id;
        } &) this = {CLOBBER};
      }
  }
  <D.52891>:;
   >>>;


;; Function std::thread& std::thread::operator=(std::thread&&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  if (<<cleanup_point std::thread::joinable (this)>>)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::terminate () >>>>>;
    }
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::thread::swap (this, (struct thread &) (struct thread *) __t) >>>>>;
  return <retval> = (struct thread &) (struct thread *) this;
   >>>;


;; Function void std::thread::swap(std::thread&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::swap<std::thread::id> ((struct id &) &((struct thread *) this)->_M_id, (struct id &) &__t->_M_id) >>>>>
   >>>;


;; Function bool std::thread::joinable() const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = !std::operator== (TARGET_EXPR <D.53254, ((const struct thread *) this)->_M_id>, TARGET_EXPR <D.53249, <<< Unknown tree: aggr_init_expr
  4
  __comp_ctor 
  D.53249
  (struct id *) <<< Unknown tree: void_cst >>> >>>>)>>
   >>>;


;; Function std::thread::id std::thread::get_id() const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = TARGET_EXPR <D.53256, ((const struct thread *) this)->_M_id>>>
   >>>;


;; Function std::thread::native_handle_type std::thread::native_handle() (null)
;; enabled by -tree-original


return <retval> = ((struct thread *) this)->_M_id._M_thread;


;; Function std::__shared_ptr<_Tp, _Lp>::~__shared_ptr() [with _Tp = std::thread::_Impl_base; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


{
  try
    {
      try
        {
          
        }
      finally
        {
          std::__shared_count<>::~__shared_count (&((struct __shared_ptr *) this)->_M_refcount);
        }
    }
  finally
    {
      *(struct 
      {
        struct _Impl_base * _M_ptr;
        struct __shared_count _M_refcount;
      } &) this = {CLOBBER};
    }
}
<D.53270>:;


;; Function std::shared_ptr<std::thread::_Impl_base>::~shared_ptr() (null)
;; enabled by -tree-original


{
  try
    {
      try
        {
          
        }
      finally
        {
          std::__shared_ptr<std::thread::_Impl_base, (__gnu_cxx::_Lock_policy)2u>::~__shared_ptr (&((struct shared_ptr *) this)->D.52702);
        }
    }
  finally
    {
      *(struct 
      {
        struct 
        {
          struct _Impl_base * _M_ptr;
          struct __shared_count _M_refcount;
        } D.52703;
      } &) this = {CLOBBER};
    }
}
<D.53268>:;


;; Function virtual std::thread::_Impl_base::~_Impl_base() (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Impl_base *) this)->_vptr._Impl_base = &_ZTVNSt6thread10_Impl_baseE + 16) >>>>>;
  try
    {
      try
        {
          
        }
      finally
        {
          std::shared_ptr<std::thread::_Impl_base>::~shared_ptr (&((struct _Impl_base *) this)->_M_this_ptr);
        }
    }
  finally
    {
      *(struct 
      {
        int (*__vtbl_ptr_type) () * _vptr._Impl_base;
        struct __shared_base_type _M_this_ptr;
      } &) this = {CLOBBER};
    }
}
<D.53266>:;
if ((__in_chrg & 1) != 0)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  operator delete ((void *) this, 24) >>>>>;
  }


;; Function void std::swap(std::thread&, std::thread&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::thread::swap ((struct thread *) __x, (struct thread &) (struct thread *) __y) >>>>>
   >>>;


;; Function bool std::operator!=(std::thread::id, std::thread::id) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = !std::operator== (TARGET_EXPR <D.53296, __x>, TARGET_EXPR <D.53297, __y>)>>
   >>>;


;; Function bool std::operator<=(std::thread::id, std::thread::id) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = !std::operator< (TARGET_EXPR <D.53302, __y>, TARGET_EXPR <D.53303, __x>)>>
   >>>;


;; Function bool std::operator>(std::thread::id, std::thread::id) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::operator< (TARGET_EXPR <D.53308, __y>, TARGET_EXPR <D.53309, __x>)>>
   >>>;


;; Function bool std::operator>=(std::thread::id, std::thread::id) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = !std::operator< (TARGET_EXPR <D.53314, __x>, TARGET_EXPR <D.53315, __y>)>>
   >>>;


;; Function std::size_t std::hash<std::thread::id>::operator()(const std::thread::id&) const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::_Hash_impl::hash<long unsigned int> ((const long unsigned int &) &__id->_M_thread)>>
   >>>;


;; Function std::thread::id std::this_thread::get_id() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = TARGET_EXPR <D.53338, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.53338
  (struct id *) <<< Unknown tree: void_cst >>>
  __gthread_self () >>>>;, D.53338>>
   >>>;


;; Function void std::this_thread::yield() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) __gthread_yield () >>>>>
   >>>;


;; Function constexpr std::__atomic_base<_IntTp>::__atomic_base(std::__atomic_base<_IntTp>::__int_type) [with _ITp = bool; std::__atomic_base<_IntTp>::__int_type = bool] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __atomic_base *) this)->_M_i = __i) >>>>>;
  }
   >>>;


;; Function constexpr std::atomic<bool>::atomic(bool) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__atomic_base<bool>::__atomic_base (&((struct atomic *) this)->_M_base, (int) __i) >>>>>;
  }
   >>>;


;; Function bool std::atomic<bool>::operator=(bool) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::__atomic_base<bool>::operator= (&((struct atomic *) this)->_M_base, (int) __i)>>
   >>>;


;; Function bool std::atomic<bool>::operator=(bool) volatile (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::__atomic_base<bool>::operator= (&((volatile struct atomic *) this)->_M_base, (int) __i)>>
   >>>;


;; Function std::atomic<bool>::operator bool() const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::__atomic_base<bool>::load (&((const struct atomic *) this)->_M_base, 5)>>
   >>>;


;; Function std::atomic<bool>::operator bool() const volatile (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::__atomic_base<bool>::load (&((const volatile struct atomic *) this)->_M_base, 5)>>
   >>>;


;; Function bool std::atomic<bool>::is_lock_free() const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::__atomic_base<bool>::is_lock_free (&((const struct atomic *) this)->_M_base)>>
   >>>;


;; Function bool std::atomic<bool>::is_lock_free() const volatile (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::__atomic_base<bool>::is_lock_free (&((const volatile struct atomic *) this)->_M_base)>>
   >>>;


;; Function void std::atomic<bool>::store(bool, std::memory_order) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__atomic_base<bool>::store (&((struct atomic *) this)->_M_base, (int) __i, __m) >>>>>
   >>>;


;; Function void std::atomic<bool>::store(bool, std::memory_order) volatile (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__atomic_base<bool>::store (&((volatile struct atomic *) this)->_M_base, (int) __i, __m) >>>>>
   >>>;


;; Function bool std::atomic<bool>::load(std::memory_order) const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::__atomic_base<bool>::load (&((const struct atomic *) this)->_M_base, __m)>>
   >>>;


;; Function bool std::atomic<bool>::load(std::memory_order) const volatile (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::__atomic_base<bool>::load (&((const volatile struct atomic *) this)->_M_base, __m)>>
   >>>;


;; Function bool std::atomic<bool>::exchange(bool, std::memory_order) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::__atomic_base<bool>::exchange (&((struct atomic *) this)->_M_base, (int) __i, __m)>>
   >>>;


;; Function bool std::atomic<bool>::exchange(bool, std::memory_order) volatile (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::__atomic_base<bool>::exchange (&((volatile struct atomic *) this)->_M_base, (int) __i, __m)>>
   >>>;


;; Function bool std::atomic<bool>::compare_exchange_weak(bool&, bool, std::memory_order, std::memory_order) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::__atomic_base<bool>::compare_exchange_weak (&((struct atomic *) this)->_M_base, (__int_type &) (bool *) __i1, (int) __i2, __m1, __m2)>>
   >>>;


;; Function bool std::atomic<bool>::compare_exchange_weak(bool&, bool, std::memory_order, std::memory_order) volatile (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::__atomic_base<bool>::compare_exchange_weak (&((volatile struct atomic *) this)->_M_base, (__int_type &) (bool *) __i1, (int) __i2, __m1, __m2)>>
   >>>;


;; Function bool std::atomic<bool>::compare_exchange_weak(bool&, bool, std::memory_order) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::__atomic_base<bool>::compare_exchange_weak (&((struct atomic *) this)->_M_base, (__int_type &) (bool *) __i1, (int) __i2, __m)>>
   >>>;


;; Function bool std::atomic<bool>::compare_exchange_weak(bool&, bool, std::memory_order) volatile (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::__atomic_base<bool>::compare_exchange_weak (&((volatile struct atomic *) this)->_M_base, (__int_type &) (bool *) __i1, (int) __i2, __m)>>
   >>>;


;; Function bool std::atomic<bool>::compare_exchange_strong(bool&, bool, std::memory_order, std::memory_order) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::__atomic_base<bool>::compare_exchange_strong (&((struct atomic *) this)->_M_base, (__int_type &) (bool *) __i1, (int) __i2, __m1, __m2)>>
   >>>;


;; Function bool std::atomic<bool>::compare_exchange_strong(bool&, bool, std::memory_order, std::memory_order) volatile (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::__atomic_base<bool>::compare_exchange_strong (&((volatile struct atomic *) this)->_M_base, (__int_type &) (bool *) __i1, (int) __i2, __m1, __m2)>>
   >>>;


;; Function bool std::atomic<bool>::compare_exchange_strong(bool&, bool, std::memory_order) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::__atomic_base<bool>::compare_exchange_strong (&((struct atomic *) this)->_M_base, (__int_type &) (bool *) __i1, (int) __i2, __m)>>
   >>>;


;; Function bool std::atomic<bool>::compare_exchange_strong(bool&, bool, std::memory_order) volatile (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::__atomic_base<bool>::compare_exchange_strong (&((volatile struct atomic *) this)->_M_base, (__int_type &) (bool *) __i1, (int) __i2, __m)>>
   >>>;


;; Function constexpr std::__atomic_base<_IntTp>::__atomic_base(std::__atomic_base<_IntTp>::__int_type) [with _ITp = char; std::__atomic_base<_IntTp>::__int_type = char] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __atomic_base *) this)->_M_i = __i) >>>>>;
  }
   >>>;


;; Function constexpr std::atomic<char>::atomic(std::atomic<char>::__integral_type) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__atomic_base<char>::__atomic_base (&((struct atomic *) this)->D.54402, (int) __i) >>>>>;
  }
   >>>;


;; Function constexpr std::__atomic_base<_IntTp>::__atomic_base(std::__atomic_base<_IntTp>::__int_type) [with _ITp = signed char; std::__atomic_base<_IntTp>::__int_type = signed char] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __atomic_base *) this)->_M_i = __i) >>>>>;
  }
   >>>;


;; Function constexpr std::atomic<signed char>::atomic(std::atomic<signed char>::__integral_type) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__atomic_base<signed char>::__atomic_base (&((struct atomic *) this)->D.54680, (int) __i) >>>>>;
  }
   >>>;


;; Function constexpr std::__atomic_base<_IntTp>::__atomic_base(std::__atomic_base<_IntTp>::__int_type) [with _ITp = unsigned char; std::__atomic_base<_IntTp>::__int_type = unsigned char] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __atomic_base *) this)->_M_i = __i) >>>>>;
  }
   >>>;


;; Function constexpr std::atomic<unsigned char>::atomic(std::atomic<unsigned char>::__integral_type) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__atomic_base<unsigned char>::__atomic_base (&((struct atomic *) this)->D.54958, (int) __i) >>>>>;
  }
   >>>;


;; Function constexpr std::__atomic_base<_IntTp>::__atomic_base(std::__atomic_base<_IntTp>::__int_type) [with _ITp = short int; std::__atomic_base<_IntTp>::__int_type = short int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __atomic_base *) this)->_M_i = __i) >>>>>;
  }
   >>>;


;; Function constexpr std::atomic<short int>::atomic(std::atomic<short int>::__integral_type) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__atomic_base<short int>::__atomic_base (&((struct atomic *) this)->D.55236, (int) __i) >>>>>;
  }
   >>>;


;; Function constexpr std::__atomic_base<_IntTp>::__atomic_base(std::__atomic_base<_IntTp>::__int_type) [with _ITp = short unsigned int; std::__atomic_base<_IntTp>::__int_type = short unsigned int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __atomic_base *) this)->_M_i = __i) >>>>>;
  }
   >>>;


;; Function constexpr std::atomic<short unsigned int>::atomic(std::atomic<short unsigned int>::__integral_type) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__atomic_base<short unsigned int>::__atomic_base (&((struct atomic *) this)->D.55514, (int) __i) >>>>>;
  }
   >>>;


;; Function constexpr std::__atomic_base<_IntTp>::__atomic_base(std::__atomic_base<_IntTp>::__int_type) [with _ITp = int; std::__atomic_base<_IntTp>::__int_type = int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __atomic_base *) this)->_M_i = __i) >>>>>;
  }
   >>>;


;; Function constexpr std::atomic<int>::atomic(std::atomic<int>::__integral_type) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__atomic_base<int>::__atomic_base (&((struct atomic *) this)->D.55792, __i) >>>>>;
  }
   >>>;


;; Function constexpr std::__atomic_base<_IntTp>::__atomic_base(std::__atomic_base<_IntTp>::__int_type) [with _ITp = unsigned int; std::__atomic_base<_IntTp>::__int_type = unsigned int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __atomic_base *) this)->_M_i = __i) >>>>>;
  }
   >>>;


;; Function constexpr std::atomic<unsigned int>::atomic(std::atomic<unsigned int>::__integral_type) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__atomic_base<unsigned int>::__atomic_base (&((struct atomic *) this)->D.56070, __i) >>>>>;
  }
   >>>;


;; Function constexpr std::__atomic_base<_IntTp>::__atomic_base(std::__atomic_base<_IntTp>::__int_type) [with _ITp = long int; std::__atomic_base<_IntTp>::__int_type = long int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __atomic_base *) this)->_M_i = __i) >>>>>;
  }
   >>>;


;; Function constexpr std::atomic<long int>::atomic(std::atomic<long int>::__integral_type) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__atomic_base<long int>::__atomic_base (&((struct atomic *) this)->D.56348, __i) >>>>>;
  }
   >>>;


;; Function constexpr std::__atomic_base<_IntTp>::__atomic_base(std::__atomic_base<_IntTp>::__int_type) [with _ITp = long unsigned int; std::__atomic_base<_IntTp>::__int_type = long unsigned int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __atomic_base *) this)->_M_i = __i) >>>>>;
  }
   >>>;


;; Function constexpr std::atomic<long unsigned int>::atomic(std::atomic<long unsigned int>::__integral_type) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__atomic_base<long unsigned int>::__atomic_base (&((struct atomic *) this)->D.56626, __i) >>>>>;
  }
   >>>;


;; Function constexpr std::__atomic_base<_IntTp>::__atomic_base(std::__atomic_base<_IntTp>::__int_type) [with _ITp = long long int; std::__atomic_base<_IntTp>::__int_type = long long int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __atomic_base *) this)->_M_i = __i) >>>>>;
  }
   >>>;


;; Function constexpr std::atomic<long long int>::atomic(std::atomic<long long int>::__integral_type) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__atomic_base<long long int>::__atomic_base (&((struct atomic *) this)->D.56904, __i) >>>>>;
  }
   >>>;


;; Function constexpr std::__atomic_base<_IntTp>::__atomic_base(std::__atomic_base<_IntTp>::__int_type) [with _ITp = long long unsigned int; std::__atomic_base<_IntTp>::__int_type = long long unsigned int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __atomic_base *) this)->_M_i = __i) >>>>>;
  }
   >>>;


;; Function constexpr std::atomic<long long unsigned int>::atomic(std::atomic<long long unsigned int>::__integral_type) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__atomic_base<long long unsigned int>::__atomic_base (&((struct atomic *) this)->D.57182, __i) >>>>>;
  }
   >>>;


;; Function constexpr std::__atomic_base<_IntTp>::__atomic_base(std::__atomic_base<_IntTp>::__int_type) [with _ITp = wchar_t; std::__atomic_base<_IntTp>::__int_type = wchar_t] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __atomic_base *) this)->_M_i = __i) >>>>>;
  }
   >>>;


;; Function constexpr std::atomic<wchar_t>::atomic(std::atomic<wchar_t>::__integral_type) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__atomic_base<wchar_t>::__atomic_base (&((struct atomic *) this)->D.57460, __i) >>>>>;
  }
   >>>;


;; Function constexpr std::__atomic_base<_IntTp>::__atomic_base(std::__atomic_base<_IntTp>::__int_type) [with _ITp = char16_t; std::__atomic_base<_IntTp>::__int_type = char16_t] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __atomic_base *) this)->_M_i = __i) >>>>>;
  }
   >>>;


;; Function constexpr std::atomic<char16_t>::atomic(std::atomic<char16_t>::__integral_type) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__atomic_base<char16_t>::__atomic_base (&((struct atomic *) this)->D.57738, (int) __i) >>>>>;
  }
   >>>;


;; Function constexpr std::__atomic_base<_IntTp>::__atomic_base(std::__atomic_base<_IntTp>::__int_type) [with _ITp = char32_t; std::__atomic_base<_IntTp>::__int_type = char32_t] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __atomic_base *) this)->_M_i = __i) >>>>>;
  }
   >>>;


;; Function constexpr std::atomic<char32_t>::atomic(std::atomic<char32_t>::__integral_type) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__atomic_base<char32_t>::__atomic_base (&((struct atomic *) this)->D.58016, __i) >>>>>;
  }
   >>>;


;; Function bool std::atomic_flag_test_and_set_explicit(std::atomic_flag*, std::memory_order) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::atomic_flag::test_and_set (NON_LVALUE_EXPR <__a>, __m)>>
   >>>;


;; Function bool std::atomic_flag_test_and_set_explicit(volatile std::atomic_flag*, std::memory_order) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::atomic_flag::test_and_set (NON_LVALUE_EXPR <__a>, __m)>>
   >>>;


;; Function void std::atomic_flag_clear_explicit(std::atomic_flag*, std::memory_order) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::atomic_flag::clear (NON_LVALUE_EXPR <__a>, __m) >>>>>
   >>>;


;; Function void std::atomic_flag_clear_explicit(volatile std::atomic_flag*, std::memory_order) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::atomic_flag::clear (NON_LVALUE_EXPR <__a>, __m) >>>>>
   >>>;


;; Function bool std::atomic_flag_test_and_set(std::atomic_flag*) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::atomic_flag_test_and_set_explicit (__a, 5)>>
   >>>;


;; Function bool std::atomic_flag_test_and_set(volatile std::atomic_flag*) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::atomic_flag_test_and_set_explicit (__a, 5)>>
   >>>;


;; Function void std::atomic_flag_clear(std::atomic_flag*) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::atomic_flag_clear_explicit (__a, 5) >>>>>
   >>>;


;; Function void std::atomic_flag_clear(volatile std::atomic_flag*) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::atomic_flag_clear_explicit (__a, 5) >>>>>
   >>>;


;; Function void std::mutex::lock() (null)
;; enabled by -tree-original


{
  int __e;

    int __e;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__e = __gthread_mutex_lock (&((struct mutex *) this)->D.58537._M_mutex)) >>>>>;
  if (__e != 0)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_system_error (__e) >>>>>;
    }
}


;; Function bool std::mutex::try_lock() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = __gthread_mutex_trylock (&((struct mutex *) this)->D.58537._M_mutex) == 0>>
   >>>;


;; Function void std::mutex::unlock() (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) __gthread_mutex_unlock (&((struct mutex *) this)->D.58537._M_mutex) >>>>>;


;; Function std::__mutex_base::__native_type* std::mutex::native_handle() (null)
;; enabled by -tree-original


return <retval> = (union __native_type *) &((struct mutex *) this)->D.58537._M_mutex;


;; Function void std::recursive_mutex::lock() (null)
;; enabled by -tree-original


{
  int __e;

    int __e;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__e = __gthread_recursive_mutex_lock (&((struct recursive_mutex *) this)->D.58596._M_mutex)) >>>>>;
  if (__e != 0)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_system_error (__e) >>>>>;
    }
}


;; Function bool std::recursive_mutex::try_lock() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = __gthread_recursive_mutex_trylock (&((struct recursive_mutex *) this)->D.58596._M_mutex) == 0>>
   >>>;


;; Function void std::recursive_mutex::unlock() (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) __gthread_recursive_mutex_unlock (&((struct recursive_mutex *) this)->D.58596._M_mutex) >>>>>;


;; Function std::__recursive_mutex_base::__native_type* std::recursive_mutex::native_handle() (null)
;; enabled by -tree-original


return <retval> = (union __native_type *) &((struct recursive_mutex *) this)->D.58596._M_mutex;


;; Function void std::timed_mutex::lock() (null)
;; enabled by -tree-original


{
  int __e;

    int __e;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__e = __gthread_mutex_lock (&((struct timed_mutex *) this)->D.58786._M_mutex)) >>>>>;
  if (__e != 0)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_system_error (__e) >>>>>;
    }
}


;; Function bool std::timed_mutex::try_lock() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = __gthread_mutex_trylock (&((struct timed_mutex *) this)->D.58786._M_mutex) == 0>>
   >>>;


;; Function void std::timed_mutex::unlock() (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) __gthread_mutex_unlock (&((struct timed_mutex *) this)->D.58786._M_mutex) >>>>>;


;; Function std::__mutex_base::__native_type* std::timed_mutex::native_handle() (null)
;; enabled by -tree-original


return <retval> = (union __native_type *) &((struct timed_mutex *) this)->D.58786._M_mutex;


;; Function void std::recursive_timed_mutex::lock() (null)
;; enabled by -tree-original


{
  int __e;

    int __e;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__e = __gthread_recursive_mutex_lock (&((struct recursive_timed_mutex *) this)->D.58930._M_mutex)) >>>>>;
  if (__e != 0)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_system_error (__e) >>>>>;
    }
}


;; Function bool std::recursive_timed_mutex::try_lock() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = __gthread_recursive_mutex_trylock (&((struct recursive_timed_mutex *) this)->D.58930._M_mutex) == 0>>
   >>>;


;; Function void std::recursive_timed_mutex::unlock() (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) __gthread_recursive_mutex_unlock (&((struct recursive_timed_mutex *) this)->D.58930._M_mutex) >>>>>;


;; Function std::__recursive_mutex_base::__native_type* std::recursive_timed_mutex::native_handle() (null)
;; enabled by -tree-original


return <retval> = (union __native_type *) &((struct recursive_timed_mutex *) this)->D.58930._M_mutex;


;; Function std::condition_variable::__native_type* std::condition_variable::native_handle() (null)
;; enabled by -tree-original


return <retval> = (union __native_type *) &((struct condition_variable *) this)->_M_cond;


;; Function std::__shared_ptr<_Tp, _Lp>::~__shared_ptr() [with _Tp = std::mutex; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


{
  try
    {
      try
        {
          
        }
      finally
        {
          std::__shared_count<>::~__shared_count (&((struct __shared_ptr *) this)->_M_refcount);
        }
    }
  finally
    {
      *(struct 
      {
        struct mutex * _M_ptr;
        struct __shared_count _M_refcount;
      } &) this = {CLOBBER};
    }
}
<D.61137>:;


;; Function std::shared_ptr<std::mutex>::~shared_ptr() (null)
;; enabled by -tree-original


{
  try
    {
      try
        {
          
        }
      finally
        {
          std::__shared_ptr<std::mutex, (__gnu_cxx::_Lock_policy)2u>::~__shared_ptr (&((struct shared_ptr *) this)->D.61009);
        }
    }
  finally
    {
      *(struct 
      {
        struct 
        {
          struct mutex * _M_ptr;
          struct __shared_count _M_refcount;
        } D.61010;
      } &) this = {CLOBBER};
    }
}
<D.61135>:;


;; Function std::_V2::condition_variable_any::condition_variable_any() (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::condition_variable::condition_variable (&((struct condition_variable_any *) this)->_M_cond) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct condition_variable_any *) this)->_M_mutex = TARGET_EXPR <D.61133, <<< Unknown tree: aggr_init_expr
  3
  make_shared
  D.61133 >>>>) >>>>>;
      try
        {
          
        }
      catch
        {
          std::shared_ptr<std::mutex>::~shared_ptr (&((struct condition_variable_any *) this)->_M_mutex);
        }
    }
  catch
    {
      std::condition_variable::~condition_variable (&((struct condition_variable_any *) this)->_M_cond);
    }
}


;; Function void std::_V2::condition_variable_any::notify_one() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    struct lock_guard __lock;

        struct lock_guard __lock;
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::lock_guard<std::mutex>::lock_guard (&__lock, (struct mutex_type &) (struct mutex *) std::__shared_ptr<std::mutex, (__gnu_cxx::_Lock_policy)2u>::operator* (&((struct condition_variable_any *) this)->_M_mutex.D.61009)) >>>>>;
    try
      {
        <<cleanup_point <<< Unknown tree: expr_stmt
  std::condition_variable::notify_one (&((struct condition_variable_any *) this)->_M_cond) >>>>>;
      }
    finally
      {
        std::lock_guard<std::mutex>::~lock_guard (&__lock);
      }
  }
   >>>;


;; Function void std::_V2::condition_variable_any::notify_all() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    struct lock_guard __lock;

        struct lock_guard __lock;
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::lock_guard<std::mutex>::lock_guard (&__lock, (struct mutex_type &) (struct mutex *) std::__shared_ptr<std::mutex, (__gnu_cxx::_Lock_policy)2u>::operator* (&((struct condition_variable_any *) this)->_M_mutex.D.61009)) >>>>>;
    try
      {
        <<cleanup_point <<< Unknown tree: expr_stmt
  std::condition_variable::notify_all (&((struct condition_variable_any *) this)->_M_cond) >>>>>;
      }
    finally
      {
        std::lock_guard<std::mutex>::~lock_guard (&__lock);
      }
  }
   >>>;


;; Function void std::shared_timed_mutex::lock() (null)
;; enabled by -tree-original


{
  int __ret;

    int __ret;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__ret = pthread_rwlock_wrlock (&((struct shared_timed_mutex *) this)->_M_rwlock)) >>>>>;
  if (__ret == 35)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_system_error (35) >>>>>;
    }
}


;; Function bool std::shared_timed_mutex::try_lock() (null)
;; enabled by -tree-original


{
  int __ret;

    int __ret;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__ret = pthread_rwlock_trywrlock (&((struct shared_timed_mutex *) this)->_M_rwlock)) >>>>>;
  if (__ret == 16)
    {
      return <retval> = 0;
    }
  return <retval> = 1;
}


;; Function void std::shared_timed_mutex::unlock() (null)
;; enabled by -tree-original


{
  int __ret;

    int __ret;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__ret = pthread_rwlock_unlock (&((struct shared_timed_mutex *) this)->_M_rwlock)) >>>>>;
}


;; Function void std::shared_timed_mutex::lock_shared() (null)
;; enabled by -tree-original


{
  int __ret;

    int __ret;
  while (1)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__ret = pthread_rwlock_rdlock (&((struct shared_timed_mutex *) this)->_M_rwlock)) >>>>>;
      if (__ret != 11) goto <D.61384>;
    }
  <D.61384>:;
  if (__ret == 35)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_system_error (35) >>>>>;
    }
}


;; Function bool std::shared_timed_mutex::try_lock_shared() (null)
;; enabled by -tree-original


{
  int __ret;

    int __ret;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__ret = pthread_rwlock_tryrdlock (&((struct shared_timed_mutex *) this)->_M_rwlock)) >>>>>;
  if (__ret == 16 || __ret == 11)
    {
      return <retval> = 0;
    }
  return <retval> = 1;
}


;; Function void std::shared_timed_mutex::unlock_shared() (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::shared_timed_mutex::unlock (this) >>>>>;


;; Function std::error_code std::make_error_code(std::future_errc) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = TARGET_EXPR <D.61688, <<< Unknown tree: aggr_init_expr
  6
  __comp_ctor 
  D.61688
  (struct error_code *) <<< Unknown tree: void_cst >>>
  (int) __errc
  (const struct error_category &) (const struct error_category *) std::future_category () >>>>;, D.61688>>
   >>>;


;; Function std::error_condition std::make_error_condition(std::future_errc) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = TARGET_EXPR <D.61692, <<< Unknown tree: aggr_init_expr
  6
  __comp_ctor 
  D.61692
  (struct error_condition *) <<< Unknown tree: void_cst >>>
  (int) __errc
  (const struct error_category &) (const struct error_category *) std::future_category () >>>>;, D.61692>>
   >>>;


;; Function std::future_error::future_error(std::error_code) (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::logic_error::logic_error (&((struct future_error *) this)->D.61721, (const struct string &) (const struct string *) &TARGET_EXPR <D.61728, <<< Unknown tree: aggr_init_expr
  5
  operator+
  D.61728
  (const char *) "std::future_error: "
  (struct basic_string &) &TARGET_EXPR <D.61727, <<< Unknown tree: aggr_init_expr
  4
  message
  D.61727
  &__ec >>>> >>>>) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct future_error *) this)->D.61721.D.24612._vptr.exception = &_ZTVSt12future_error + 16) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct future_error *) this)->_M_code = __ec) >>>>>;
    }
  catch
    {
      std::logic_error::~logic_error (&((struct future_error *) this)->D.61721);
    }
}


;; Function const std::error_code& std::future_error::code() const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (const struct error_code &) &((const struct future_error *) this)->_M_code
   >>>;


;; Function constexpr std::launch std::operator&(std::launch, std::launch) (null)
;; enabled by -tree-original


return <retval> = (launch) ((int) __x & (int) __y);


;; Function constexpr std::launch std::operator|(std::launch, std::launch) (null)
;; enabled by -tree-original


return <retval> = (launch) ((int) __x | (int) __y);


;; Function constexpr std::launch std::operator^(std::launch, std::launch) (null)
;; enabled by -tree-original


return <retval> = (launch) ((int) __x ^ (int) __y);


;; Function constexpr std::launch std::operator~(std::launch) (null)
;; enabled by -tree-original


return <retval> = ~__x;


;; Function std::launch& std::operator&=(std::launch&, std::launch) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (launch &) (*__x = std::operator& (*__x, __y);, (launch *) __x;)>>;


;; Function std::launch& std::operator|=(std::launch&, std::launch) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (launch &) (*__x = std::operator| (*__x, __y);, (launch *) __x;)>>;


;; Function std::launch& std::operator^=(std::launch&, std::launch) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (launch &) (*__x = std::operator^ (*__x, __y);, (launch *) __x;)>>;


;; Function void std::__future_base::_Result_base::_Deleter::operator()(std::__future_base::_Result_base*) const (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  OBJ_TYPE_REF(*NON_LVALUE_EXPR <NON_LVALUE_EXPR <__fr>->_vptr._Result_base>;(struct _Result_base)NON_LVALUE_EXPR <__fr>->0) (NON_LVALUE_EXPR <__fr>) >>>>>;


;; Function constexpr std::_Head_base<_Idx, _Head, true>::_Head_base() [with long unsigned int _Idx = 1ul; _Head = std::__future_base::_Result_base::_Deleter] (null)
;; enabled by -tree-original


{
  
}


;; Function constexpr std::_Tuple_impl<_Idx, _Head>::_Tuple_impl() [with long unsigned int _Idx = 1ul; _Head = std::__future_base::_Result_base::_Deleter] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Head_base<1ul, std::__future_base::_Result_base::_Deleter, true>::_Head_base ((struct _Head_base *) this) >>>>>;
}


;; Function constexpr std::_Head_base<_Idx, _Head, false>::_Head_base() [with long unsigned int _Idx = 0ul; _Head = std::__future_base::_Result_base*] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Head_base *) this)->_M_head_impl = 0B) >>>>>;
}


;; Function constexpr std::_Tuple_impl<_Idx, _Head, _Tail ...>::_Tuple_impl() [with long unsigned int _Idx = 0ul; _Head = std::__future_base::_Result_base*; _Tail = {std::__future_base::_Result_base::_Deleter}] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Tuple_impl<1ul, std::__future_base::_Result_base::_Deleter>::_Tuple_impl ((struct _Tuple_impl *) this) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Head_base<0ul, std::__future_base::_Result_base*, false>::_Head_base (&((struct _Tuple_impl *) this)->D.63461) >>>>>;
}


;; Function constexpr std::tuple<_T1, _T2>::tuple() [with _T1 = std::__future_base::_Result_base*; _T2 = std::__future_base::_Result_base::_Deleter] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Tuple_impl<0ul, std::__future_base::_Result_base*, std::__future_base::_Result_base::_Deleter>::_Tuple_impl (&((struct tuple *) this)->D.64132) >>>>>;
}


;; Function constexpr std::unique_ptr<_Tp, _Dp>::unique_ptr() [with _Tp = std::__future_base::_Result_base; _Dp = std::__future_base::_Result_base::_Deleter] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct unique_ptr *) this)->_M_t = <<< Unknown tree: aggr_init_expr
  4
  __comp_ctor 
  D.65425
  (struct tuple *) <<< Unknown tree: void_cst >>> >>>) >>>>>;
  }
   >>>;


;; Function constexpr std::once_flag::once_flag() (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct once_flag *) this)->_M_once = 0) >>>>>;
}


;; Function std::__future_base::_State_baseV2::_State_baseV2() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _State_baseV2 *) this)->_vptr._State_baseV2 = &_ZTVNSt13__future_base13_State_baseV2E + 16) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _State_baseV2 *) this)->_M_result = <<< Unknown tree: aggr_init_expr
  4
  __comp_ctor 
  D.65455
  (struct unique_ptr *) <<< Unknown tree: void_cst >>> >>>) >>>>>;
    try
      {
        <<cleanup_point <<< Unknown tree: expr_stmt
  std::__atomic_futex_unsigned<>::__atomic_futex_unsigned (&((struct _State_baseV2 *) this)->_M_status, 0) >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _State_baseV2 *) this)->_M_retrieved = TARGET_EXPR <D.65498, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.65498
  (struct atomic_flag *) <<< Unknown tree: void_cst >>>
  0 >>>>) >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  std::once_flag::once_flag (&((struct _State_baseV2 *) this)->_M_once) >>>>>;
      }
    catch
      {
        std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>::~unique_ptr (&((struct _State_baseV2 *) this)->_M_result);
      }
  }
   >>>;


;; Function std::__future_base::_Result_base& std::__future_base::_State_baseV2::wait() (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  OBJ_TYPE_REF(*(((struct _State_baseV2 *) this)->_vptr._State_baseV2 + 16);(struct _State_baseV2)this->2) (this) >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  std::__atomic_futex_unsigned<>::_M_load_when_equal (&((struct _State_baseV2 *) this)->_M_status, 1, 2) >>>>>;
<<cleanup_point return <retval> = (struct _Result_base &) (struct _Result_base *) std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>::operator* (&((struct _State_baseV2 *) this)->_M_result)>>;


;; Function void std::__future_base::_State_baseV2::_M_set_result(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>, bool) (null)
;; enabled by -tree-original


{
  bool __did_set = 0;

  <<cleanup_point   bool __did_set = 0;>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::call_once<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*), std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*> ((struct once_flag &) &((struct _State_baseV2 *) this)->_M_once, (struct 
  {
    void _State_baseV2::<Tc8fa> (struct _State_baseV2 *, struct function *, bool *) * __pfn;
    long int __delta;
  } &) &TARGET_EXPR <D.65712, <<< Unknown tree: ptrmem_cst >>>>, (struct _State_baseV2 * &) &TARGET_EXPR <D.65713, (struct _State_baseV2 *) this>, (struct function * &) &TARGET_EXPR <D.65714, std::__addressof<std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()> > ((struct function &) (struct function *) __res)>, (bool * &) &TARGET_EXPR <D.65715, std::__addressof<bool> ((bool &) &__did_set)>) >>>>>;
  if (__did_set)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__atomic_futex_unsigned<>::_M_store_notify_all (&((struct _State_baseV2 *) this)->_M_status, 1, 3) >>>>>;
    }
  else
    {
      if (!__ignore_failure)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_future_error (2) >>>>>;
        }
    }
}


;; Function std::__at_thread_exit_elt::__at_thread_exit_elt() (null)
;; enabled by -tree-original


{
  
}


;; Function constexpr std::__weak_count<_Lp>::__weak_count() [with __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __weak_count *) this)->_M_pi = 0B) >>>>>;
  }
   >>>;


;; Function constexpr std::__weak_ptr<_Tp, _Lp>::__weak_ptr() [with _Tp = std::__future_base::_State_baseV2; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __weak_ptr *) this)->_M_ptr = 0B) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __weak_ptr *) this)->_M_refcount = <<< Unknown tree: aggr_init_expr
  4
  __comp_ctor 
  D.68319
  (struct __weak_count *) <<< Unknown tree: void_cst >>> >>>) >>>>>;
    try
      {
        
      }
    catch
      {
        std::__weak_count<(__gnu_cxx::_Lock_policy)2u>::~__weak_count (&((struct __weak_ptr *) this)->_M_refcount);
      }
  }
   >>>;


;; Function std::__weak_ptr<_Tp, _Lp>::~__weak_ptr() [with _Tp = std::__future_base::_State_baseV2; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


{
  try
    {
      try
        {
          
        }
      finally
        {
          std::__weak_count<(__gnu_cxx::_Lock_policy)2u>::~__weak_count (&((struct __weak_ptr *) this)->_M_refcount);
        }
    }
  finally
    {
      *(struct 
      {
        struct _State_baseV2 * _M_ptr;
        struct __weak_count _M_refcount;
      } &) this = {CLOBBER};
    }
}
<D.68325>:;


;; Function constexpr std::weak_ptr<_Tp>::weak_ptr() [with _Tp = std::__future_base::_State_baseV2] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__weak_ptr<std::__future_base::_State_baseV2, (__gnu_cxx::_Lock_policy)2u>::__weak_ptr (&((struct weak_ptr *) this)->D.65219) >>>>>;
  try
    {
      
    }
  catch
    {
      std::__weak_ptr<std::__future_base::_State_baseV2, (__gnu_cxx::_Lock_policy)2u>::~__weak_ptr (&((struct weak_ptr *) this)->D.65219);
    }
}


;; Function std::weak_ptr<std::__future_base::_State_baseV2>::~weak_ptr() (null)
;; enabled by -tree-original


{
  try
    {
      try
        {
          
        }
      finally
        {
          std::__weak_ptr<std::__future_base::_State_baseV2, (__gnu_cxx::_Lock_policy)2u>::~__weak_ptr (&((struct weak_ptr *) this)->D.65219);
        }
    }
  finally
    {
      *(struct 
      {
        struct 
        {
          struct _State_baseV2 * _M_ptr;
          struct __weak_count _M_refcount;
        } D.65220;
      } &) this = {CLOBBER};
    }
}
<D.68334>:;


;; Function std::__future_base::_State_baseV2::_Make_ready::_Make_ready() (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__at_thread_exit_elt::__at_thread_exit_elt (&((struct _Make_ready *) this)->D.65274) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::weak_ptr<std::__future_base::_State_baseV2>::weak_ptr (&((struct _Make_ready *) this)->_M_shared_state) >>>>>;
  try
    {
      
    }
  catch
    {
      std::weak_ptr<std::__future_base::_State_baseV2>::~weak_ptr (&((struct _Make_ready *) this)->_M_shared_state);
    }
}


;; Function constexpr typename std::remove_reference< <template-parameter-1-1> >::type&& std::move(_Tp&&) [with _Tp = std::weak_ptr<std::__future_base::_State_baseV2>&; typename std::remove_reference< <template-parameter-1-1> >::type = std::weak_ptr<std::__future_base::_State_baseV2>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct type &) (struct type *) NON_LVALUE_EXPR <(struct type &) __t>
   >>>;


;; Function std::weak_ptr<_Tp>& std::weak_ptr<_Tp>::operator=(std::weak_ptr<_Tp>&&) [with _Tp = std::__future_base::_State_baseV2] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::__weak_ptr<std::__future_base::_State_baseV2, (__gnu_cxx::_Lock_policy)2u>::operator= (&((struct weak_ptr *) this)->D.65219, (struct __weak_ptr &) (struct __weak_ptr *) NON_LVALUE_EXPR <(struct __weak_ptr &) &((struct weak_ptr *) __r)->D.65219>) >>>>>;
return <retval> = (struct weak_ptr &) (struct weak_ptr *) this;


;; Function void std::__future_base::_State_baseV2::_M_set_delayed_result(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>, std::weak_ptr<std::__future_base::_State_baseV2>) (null)
;; enabled by -tree-original


{
  bool __did_set = 0;
  struct unique_ptr __mr;

  <<cleanup_point   bool __did_set = 0;>>;
    struct unique_ptr __mr;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::unique_ptr<std::__future_base::_State_baseV2::_Make_ready>::unique_ptr (&__mr, (TARGET_EXPR <D.68272, operator new (32)>;, try
    {
      std::__future_base::_State_baseV2::_Make_ready::_Make_ready ((struct _Make_ready *) D.68272);
    }
  catch
    {
      operator delete (D.68272, 32);
    }, (struct _Make_ready *) D.68272;)) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::call_once<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*), std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*> ((struct once_flag &) &((struct _State_baseV2 *) this)->_M_once, (struct 
  {
    void _State_baseV2::<Tc8fa> (struct _State_baseV2 *, struct function *, bool *) * __pfn;
    long int __delta;
  } &) &TARGET_EXPR <D.68342, <<< Unknown tree: ptrmem_cst >>>>, (struct _State_baseV2 * &) &TARGET_EXPR <D.68343, (struct _State_baseV2 *) this>, (struct function * &) &TARGET_EXPR <D.68344, std::__addressof<std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()> > ((struct function &) (struct function *) __res)>, (bool * &) &TARGET_EXPR <D.68345, std::__addressof<bool> ((bool &) &__did_set)>) >>>>>;
      if (!__did_set)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_future_error (2) >>>>>;
        }
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::weak_ptr<std::__future_base::_State_baseV2>::operator= (&std::unique_ptr<std::__future_base::_State_baseV2::_Make_ready>::operator-> (&__mr)->_M_shared_state, (struct weak_ptr &) (struct type *) std::move<std::weak_ptr<std::__future_base::_State_baseV2>&> ((struct weak_ptr &) (struct weak_ptr *) __self)) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__future_base::_State_baseV2::_Make_ready::_M_set (std::unique_ptr<std::__future_base::_State_baseV2::_Make_ready>::operator-> (&__mr)) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::unique_ptr<std::__future_base::_State_baseV2::_Make_ready>::release (&__mr) >>>>>;
    }
  finally
    {
      std::unique_ptr<std::__future_base::_State_baseV2::_Make_ready>::~unique_ptr (&__mr);
    }
}


;; Function std::future_error::future_error(const std::future_error&) (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::logic_error::logic_error (&((struct future_error *) this)->D.61721, (const struct logic_error &) &((const struct future_error *) D.68364)->D.61721) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct future_error *) this)->D.61721.D.24612._vptr.exception = &_ZTVSt12future_error + 16) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct future_error *) this)->_M_code = D.68364->_M_code) >>>>>;
    }
  catch
    {
      std::logic_error::~logic_error (&((struct future_error *) this)->D.61721);
    }
}


;; Function void std::__future_base::_State_baseV2::_M_break_promise(std::__future_base::_State_baseV2::_Ptr_type) (null)
;; enabled by -tree-original


{
  {
    if (<<cleanup_point std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>::operator bool ((struct _Ptr_type *) __res)>>)
      {
        {
          struct error_code __ec;

                    struct error_code __ec;
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__ec = std::make_error_code (4)) >>>>>;
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::__exception_ptr::exception_ptr::operator= (&std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>::operator-> ((struct _Ptr_type *) __res)->_M_error, (struct exception_ptr &) &TARGET_EXPR <D.68379, <<< Unknown tree: aggr_init_expr
  4
  make_exception_ptr
  D.68379
  &TARGET_EXPR <D.68373, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.68373
  (struct future_error *) <<< Unknown tree: void_cst >>>
  TARGET_EXPR <D.68372, __ec> >>>> >>>>) >>>>>;
          <<cleanup_point <<< Unknown tree: expr_stmt
  std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>::swap (&((struct _State_baseV2 *) this)->_M_result, (struct unique_ptr &) (struct _Ptr_type *) __res) >>>>>;
          <<cleanup_point <<< Unknown tree: expr_stmt
  std::__atomic_futex_unsigned<>::_M_store_notify_all (&((struct _State_baseV2 *) this)->_M_status, 1, 3) >>>>>;
        }
      }
  }
}


;; Function void std::__future_base::_State_baseV2::_M_set_retrieved_flag() (null)
;; enabled by -tree-original


if (<<cleanup_point std::atomic_flag::test_and_set (&((struct _State_baseV2 *) this)->_M_retrieved, 5)>>)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_future_error (1) >>>>>;
  }


;; Function void std::__future_base::_State_baseV2::_M_do_set(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*) (null)
;; enabled by -tree-original


{
  struct _Ptr_type __res;

    struct _Ptr_type __res;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__res = <<< Unknown tree: aggr_init_expr
  4
  operator()
  D.68389
  NON_LVALUE_EXPR <__f> >>>) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__did_set = 1) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>::swap (&((struct _State_baseV2 *) this)->_M_result, (struct unique_ptr &) &__res) >>>>>;
    }
  finally
    {
      std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>::~unique_ptr (&__res);
    }
}


;; Function virtual void std::__future_base::_State_baseV2::_M_complete_async() (null)
;; enabled by -tree-original





;; Function virtual bool std::__future_base::_State_baseV2::_M_is_deferred_future() const (null)
;; enabled by -tree-original


return <retval> = 0;


;; Function virtual void std::__future_base::_Result<void>::_M_destroy() (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  if ((struct _Result *) this != 0B)
    {
      OBJ_TYPE_REF(*(((struct _Result *) this)->D.68681._vptr._Result_base + 16);(struct _Result)this->2) (this);
    }
  else
    {
      <<< Unknown tree: void_cst >>>
    } >>>>>;


;; Function std::__shared_ptr<_Tp, _Lp>::~__shared_ptr() [with _Tp = std::__future_base::_State_baseV2; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


{
  try
    {
      try
        {
          
        }
      finally
        {
          std::__shared_count<>::~__shared_count (&((struct __shared_ptr *) this)->_M_refcount);
        }
    }
  finally
    {
      *(struct 
      {
        struct _State_baseV2 * _M_ptr;
        struct __shared_count _M_refcount;
      } &) this = {CLOBBER};
    }
}
<D.70307>:;


;; Function std::shared_ptr<std::__future_base::_State_baseV2>::~shared_ptr() (null)
;; enabled by -tree-original


{
  try
    {
      try
        {
          
        }
      finally
        {
          std::__shared_ptr<std::__future_base::_State_baseV2, (__gnu_cxx::_Lock_policy)2u>::~__shared_ptr (&((struct shared_ptr *) this)->D.69901);
        }
    }
  finally
    {
      *(struct 
      {
        struct 
        {
          struct _State_baseV2 * _M_ptr;
          struct __shared_count _M_refcount;
        } D.69902;
      } &) this = {CLOBBER};
    }
}
<D.70305>:;


;; Function std::__basic_future<void>::~__basic_future() (null)
;; enabled by -tree-original


{
  try
    {
      try
        {
          
        }
      finally
        {
          std::shared_ptr<std::__future_base::_State_baseV2>::~shared_ptr (&((struct __basic_future *) this)->_M_state);
        }
    }
  finally
    {
      *(struct 
      {
        struct __state_type _M_state;
      } &) this = {CLOBBER};
    }
}
<D.70303>:;


;; Function std::future<void>::future(const __state_type&) (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__basic_future<void>::__basic_future (&((struct future *) this)->D.70272, (const struct __state_type &) (const struct __state_type *) __state) >>>>>;
  try
    {
      
    }
  catch
    {
      std::__basic_future<void>::~__basic_future (&((struct future *) this)->D.70272);
    }
}


;; Function constexpr std::__future_base::__future_base() (null)
;; enabled by -tree-original


{
  
}


;; Function constexpr std::__shared_count<_Lp>::__shared_count() [with __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __shared_count *) this)->_M_pi = 0B) >>>>>;
  }
   >>>;


;; Function constexpr std::__shared_ptr<_Tp, _Lp>::__shared_ptr() [with _Tp = std::__future_base::_State_baseV2; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __shared_ptr *) this)->_M_ptr = 0B) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __shared_ptr *) this)->_M_refcount = <<< Unknown tree: aggr_init_expr
  4
  __comp_ctor 
  D.70359
  (struct __shared_count *) <<< Unknown tree: void_cst >>> >>>) >>>>>;
    try
      {
        
      }
    catch
      {
        std::__shared_count<>::~__shared_count (&((struct __shared_ptr *) this)->_M_refcount);
      }
  }
   >>>;


;; Function constexpr std::shared_ptr<_Tp>::shared_ptr() [with _Tp = std::__future_base::_State_baseV2] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__shared_ptr<std::__future_base::_State_baseV2, (__gnu_cxx::_Lock_policy)2u>::__shared_ptr (&((struct shared_ptr *) this)->D.69901) >>>>>;
    try
      {
        
      }
    catch
      {
        std::__shared_ptr<std::__future_base::_State_baseV2, (__gnu_cxx::_Lock_policy)2u>::~__shared_ptr (&((struct shared_ptr *) this)->D.69901);
      }
  }
   >>>;


;; Function constexpr std::__basic_future<_Res>::__basic_future() [with _Res = void] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__future_base::__future_base ((struct __future_base *) this) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __basic_future *) this)->_M_state = <<< Unknown tree: aggr_init_expr
  4
  __comp_ctor 
  D.70366
  (struct shared_ptr *) <<< Unknown tree: void_cst >>> >>>) >>>>>;
    try
      {
        
      }
    catch
      {
        std::shared_ptr<std::__future_base::_State_baseV2>::~shared_ptr (&((struct __basic_future *) this)->_M_state);
      }
  }
   >>>;


;; Function constexpr std::future<void>::future() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__basic_future<void>::__basic_future (&((struct future *) this)->D.70272) >>>>>;
    try
      {
        
      }
    catch
      {
        std::__basic_future<void>::~__basic_future (&((struct future *) this)->D.70272);
      }
  }
   >>>;


;; Function constexpr typename std::remove_reference< <template-parameter-1-1> >::type&& std::move(_Tp&&) [with _Tp = std::future<void>&; typename std::remove_reference< <template-parameter-1-1> >::type = std::future<void>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct type &) (struct type *) NON_LVALUE_EXPR <(struct type &) __t>
   >>>;


;; Function std::future<void>::future(std::future<void>&&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__basic_future<void>::__basic_future (&((struct future *) this)->D.70272, (struct future &) (struct type *) std::move<std::future<void>&> ((struct future &) (struct future *) __uf)) >>>>>;
    try
      {
        
      }
    catch
      {
        std::__basic_future<void>::~__basic_future (&((struct future *) this)->D.70272);
      }
  }
   >>>;


;; Function std::future<void>::~future() (null)
;; enabled by -tree-original


{
  try
    {
      try
        {
          
        }
      finally
        {
          std::__basic_future<void>::~__basic_future (&((struct future *) this)->D.70272);
        }
    }
  finally
    {
      *(struct 
      {
        struct 
        {
          struct __state_type _M_state;
        } D.70273;
      } &) this = {CLOBBER};
    }
}
<D.70395>:;


;; Function std::future<void>& std::future<void>::operator=(std::future<void>&&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__basic_future<void>::_M_swap (&(TARGET_EXPR <D.70384, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.70384
  (struct future *) <<< Unknown tree: void_cst >>>
  (struct future &) (struct type *) std::move<std::future<void>&> ((struct future &) (struct future *) __fut) >>>>).D.70272, (struct __basic_future &) &((struct future *) this)->D.70272) >>>>>;
  return <retval> = (struct future &) (struct future *) this;
   >>>;


;; Function void std::future<void>::get() (null)
;; enabled by -tree-original


{
  struct _Reset __reset;

    struct _Reset __reset;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__basic_future<void>::_Reset::_Reset (&__reset, (struct __basic_future &) &((struct future *) this)->D.70272) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::__basic_future<void>::_M_get_result (&((struct future *) this)->D.70272) >>>>>;
    }
  finally
    {
      std::__basic_future<void>::_Reset::~_Reset (&__reset);
    }
}


;; Function constexpr std::shared_future<void>::shared_future() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__basic_future<void>::__basic_future (&((struct shared_future *) this)->D.70553) >>>>>;
    try
      {
        
      }
    catch
      {
        std::__basic_future<void>::~__basic_future (&((struct shared_future *) this)->D.70553);
      }
  }
   >>>;


;; Function std::shared_future<void>::shared_future(const std::shared_future<void>&) (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__basic_future<void>::__basic_future (&((struct shared_future *) this)->D.70553, (const struct shared_future &) (const struct shared_future *) __sf) >>>>>;
  try
    {
      
    }
  catch
    {
      std::__basic_future<void>::~__basic_future (&((struct shared_future *) this)->D.70553);
    }
}


;; Function std::shared_future<void>::shared_future(std::future<void>&&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__basic_future<void>::__basic_future (&((struct shared_future *) this)->D.70553, (struct future &) (struct type *) std::move<std::future<void>&> ((struct future &) (struct future *) __uf)) >>>>>;
    try
      {
        
      }
    catch
      {
        std::__basic_future<void>::~__basic_future (&((struct shared_future *) this)->D.70553);
      }
  }
   >>>;


;; Function constexpr typename std::remove_reference< <template-parameter-1-1> >::type&& std::move(_Tp&&) [with _Tp = std::shared_future<void>&; typename std::remove_reference< <template-parameter-1-1> >::type = std::shared_future<void>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct type &) (struct type *) NON_LVALUE_EXPR <(struct type &) __t>
   >>>;


;; Function std::shared_future<void>::shared_future(std::shared_future<void>&&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__basic_future<void>::__basic_future (&((struct shared_future *) this)->D.70553, (struct shared_future &) (struct type *) std::move<std::shared_future<void>&> ((struct shared_future &) (struct shared_future *) __sf)) >>>>>;
    try
      {
        
      }
    catch
      {
        std::__basic_future<void>::~__basic_future (&((struct shared_future *) this)->D.70553);
      }
  }
   >>>;


;; Function std::shared_future<void>::~shared_future() (null)
;; enabled by -tree-original


{
  try
    {
      try
        {
          
        }
      finally
        {
          std::__basic_future<void>::~__basic_future (&((struct shared_future *) this)->D.70553);
        }
    }
  finally
    {
      *(struct 
      {
        struct 
        {
          struct __state_type _M_state;
        } D.70554;
      } &) this = {CLOBBER};
    }
}
<D.70586>:;


;; Function std::shared_future<void>& std::shared_future<void>::operator=(const std::shared_future<void>&) (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::__basic_future<void>::_M_swap (&(TARGET_EXPR <D.70575, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.70575
  (struct shared_future *) <<< Unknown tree: void_cst >>>
  (const struct shared_future &) (const struct shared_future *) __sf >>>>).D.70553, (struct __basic_future &) &((struct shared_future *) this)->D.70553) >>>>>;
return <retval> = (struct shared_future &) (struct shared_future *) this;


;; Function std::shared_future<void>& std::shared_future<void>::operator=(std::shared_future<void>&&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__basic_future<void>::_M_swap (&(TARGET_EXPR <D.70593, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.70593
  (struct shared_future *) <<< Unknown tree: void_cst >>>
  (struct shared_future &) (struct type *) std::move<std::shared_future<void>&> ((struct shared_future &) (struct shared_future *) __sf) >>>>).D.70553, (struct __basic_future &) &((struct shared_future *) this)->D.70553) >>>>>;
  return <retval> = (struct shared_future &) (struct shared_future *) this;
   >>>;


;; Function void std::shared_future<void>::get() const (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::__basic_future<void>::_M_get_result (&((const struct shared_future *) this)->D.70553) >>>>>;


;; Function std::shared_future<void> std::future<void>::share() (null)
;; enabled by -tree-original


<<cleanup_point return *<retval> = TARGET_EXPR <D.70621, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.70621
  (struct shared_future *) <<< Unknown tree: void_cst >>>
  (struct future &) (struct type *) std::move<std::future<void>&> ((struct future &) (struct future *) this) >>>>>>;


;; Function std::__future_base::_Result<void>::_Result() (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__future_base::_Result_base::_Result_base (&((struct _Result *) this)->D.68681) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Result *) this)->D.68681._vptr._Result_base = &_ZTVNSt13__future_base7_ResultIvEE + 16) >>>>>;
    }
  catch
    {
      std::__future_base::_Result_base::~_Result_base (&((struct _Result *) this)->D.68681);
    }
}


;; Function std::promise<void>::promise() (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct promise *) this)->_M_future = TARGET_EXPR <D.72577, <<< Unknown tree: aggr_init_expr
  3
  make_shared
  D.72577 >>>>) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::unique_ptr<std::__future_base::_Result<void>, std::__future_base::_Result_base::_Deleter>::unique_ptr (&((struct promise *) this)->_M_storage, (TARGET_EXPR <D.72578, operator new (16)>;, try
    {
      *(struct _Res_type *) D.72578 = <<< Unknown tree: aggr_init_expr
  4
  __comp_ctor 
  D.72600
  (struct _Result *) <<< Unknown tree: void_cst >>> >>>;
    }
  catch
    {
      operator delete (D.72578, 16);
    }, (struct _Res_type *) D.72578;)) >>>>>;
      try
        {
          
        }
      catch
        {
          std::unique_ptr<std::__future_base::_Result<void>, std::__future_base::_Result_base::_Deleter>::~unique_ptr (&((struct promise *) this)->_M_storage);
        }
    }
  catch
    {
      std::shared_ptr<std::__future_base::_State_baseV2>::~shared_ptr (&((struct promise *) this)->_M_future);
    }
}


;; Function constexpr typename std::remove_reference< <template-parameter-1-1> >::type&& std::move(_Tp&&) [with _Tp = std::shared_ptr<std::__future_base::_State_baseV2>&; typename std::remove_reference< <template-parameter-1-1> >::type = std::shared_ptr<std::__future_base::_State_baseV2>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct type &) (struct type *) NON_LVALUE_EXPR <(struct type &) __t>
   >>>;


;; Function constexpr typename std::remove_reference< <template-parameter-1-1> >::type&& std::move(_Tp&&) [with _Tp = std::unique_ptr<std::__future_base::_Result<void>, std::__future_base::_Result_base::_Deleter>&; typename std::remove_reference< <template-parameter-1-1> >::type = std::unique_ptr<std::__future_base::_Result<void>, std::__future_base::_Result_base::_Deleter>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct type &) (struct type *) NON_LVALUE_EXPR <(struct type &) __t>
   >>>;


;; Function std::promise<void>::promise(std::promise<void>&&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::shared_ptr<std::__future_base::_State_baseV2>::shared_ptr (&((struct promise *) this)->_M_future, (struct shared_ptr &) (struct type *) std::move<std::shared_ptr<std::__future_base::_State_baseV2>&> ((struct shared_ptr &) &__rhs->_M_future)) >>>>>;
    try
      {
        <<cleanup_point <<< Unknown tree: expr_stmt
  std::unique_ptr<std::__future_base::_Result<void>, std::__future_base::_Result_base::_Deleter>::unique_ptr (&((struct promise *) this)->_M_storage, (struct unique_ptr &) (struct type *) std::move<std::unique_ptr<std::__future_base::_Result<void>, std::__future_base::_Result_base::_Deleter>&> ((struct unique_ptr &) &__rhs->_M_storage)) >>>>>;
        try
          {
            
          }
        catch
          {
            std::unique_ptr<std::__future_base::_Result<void>, std::__future_base::_Result_base::_Deleter>::~unique_ptr (&((struct promise *) this)->_M_storage);
          }
      }
    catch
      {
        std::shared_ptr<std::__future_base::_State_baseV2>::~shared_ptr (&((struct promise *) this)->_M_future);
      }
  }
   >>>;


;; Function std::promise<void>::~promise() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    try
      {
        try
          {
            try
              {
                if (<<cleanup_point std::__shared_ptr<std::__future_base::_State_baseV2, (__gnu_cxx::_Lock_policy)2u>::operator bool (&((struct promise *) this)->_M_future.D.69901) && !std::__shared_ptr<std::__future_base::_State_baseV2, (__gnu_cxx::_Lock_policy)2u>::unique (&((struct promise *) this)->_M_future.D.69901)>>)
                  {
                    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__future_base::_State_baseV2::_M_break_promise (std::__shared_ptr<std::__future_base::_State_baseV2, (__gnu_cxx::_Lock_policy)2u>::operator-> (&((struct promise *) this)->_M_future.D.69901), &TARGET_EXPR <D.72851, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.72851
  (struct _Ptr_type *) <<< Unknown tree: void_cst >>>
  (struct unique_ptr &) (struct type *) std::move<std::unique_ptr<std::__future_base::_Result<void>, std::__future_base::_Result_base::_Deleter>&> ((struct unique_ptr &) &((struct promise *) this)->_M_storage) >>>>) >>>>>;
                  }
              }
            finally
              {
                std::unique_ptr<std::__future_base::_Result<void>, std::__future_base::_Result_base::_Deleter>::~unique_ptr (&((struct promise *) this)->_M_storage);
              }
          }
        finally
          {
            std::shared_ptr<std::__future_base::_State_baseV2>::~shared_ptr (&((struct promise *) this)->_M_future);
          }
      }
    finally
      {
        *(struct 
        {
          struct shared_ptr _M_future;
          struct _Ptr_type _M_storage;
        } &) this = {CLOBBER};
      }
  }
  <D.72787>:;
   >>>;


;; Function constexpr typename std::remove_reference< <template-parameter-1-1> >::type&& std::move(_Tp&&) [with _Tp = std::promise<void>&; typename std::remove_reference< <template-parameter-1-1> >::type = std::promise<void>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct type &) (struct type *) NON_LVALUE_EXPR <(struct type &) __t>
   >>>;


;; Function std::promise<void>& std::promise<void>::operator=(std::promise<void>&&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::promise<void>::swap (&TARGET_EXPR <D.72866, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.72866
  (struct promise *) <<< Unknown tree: void_cst >>>
  (struct promise &) (struct type *) std::move<std::promise<void>&> ((struct promise &) (struct promise *) __rhs) >>>>, (struct promise &) (struct promise *) this) >>>>>;
  return <retval> = (struct promise &) (struct promise *) this;
   >>>;


;; Function void std::promise<void>::swap(std::promise<void>&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__shared_ptr<std::__future_base::_State_baseV2, (__gnu_cxx::_Lock_policy)2u>::swap (&((struct promise *) this)->_M_future.D.69901, (struct __shared_ptr &) &__rhs->_M_future.D.69901) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::unique_ptr<std::__future_base::_Result<void>, std::__future_base::_Result_base::_Deleter>::swap (&((struct promise *) this)->_M_storage, (struct unique_ptr &) &__rhs->_M_storage) >>>>>;
   >>>;


;; Function std::future<void> std::promise<void>::get_future() (null)
;; enabled by -tree-original


<<cleanup_point return *<retval> = TARGET_EXPR <D.72869, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.72869
  (struct future *) <<< Unknown tree: void_cst >>>
  (const struct __state_type &) (const struct __state_type *) &((struct promise *) this)->_M_future >>>>>>;


;; Function std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>::~function() (null)
;; enabled by -tree-original


{
  try
    {
      try
        {
          
        }
      finally
        {
          std::_Function_base::~_Function_base (&((struct function *) this)->D.65694);
        }
    }
  finally
    {
      *(struct 
      {
        struct 
        {
          union _Any_data _M_functor;
          bool (*_Manager_type) (union _Any_data &, const union _Any_data &, _Manager_operation) _M_manager;
        } D.65695;
        struct unique_ptr (*_Invoker_type) (const union _Any_data &) _M_invoker;
      } &) this = {CLOBBER};
    }
}
<D.73193>:;


;; Function void std::promise<void>::set_exception(std::__exception_ptr::exception_ptr) (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::__future_base::_State_baseV2::_M_set_result (std::__shared_ptr<std::__future_base::_State_baseV2, (__gnu_cxx::_Lock_policy)2u>::operator-> (&((struct promise *) this)->_M_future.D.69901), &TARGET_EXPR <D.73173, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.73173
  (struct function *) <<< Unknown tree: void_cst >>>
  TARGET_EXPR <D.72880, std::__future_base::_State_baseV2::__setter<void> ((struct exception_ptr &) (struct exception_ptr *) __p, (struct promise *) this)> >>>>, 0) >>>>>;


;; Function std::weak_ptr<_Tp>::weak_ptr(std::weak_ptr<_Tp>&&) [with _Tp = std::__future_base::_State_baseV2] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__weak_ptr<std::__future_base::_State_baseV2, (__gnu_cxx::_Lock_policy)2u>::__weak_ptr (&((struct weak_ptr *) this)->D.65219, (struct __weak_ptr &) (struct __weak_ptr *) NON_LVALUE_EXPR <(struct __weak_ptr &) &((struct weak_ptr *) D.64968)->D.65219>) >>>>>;
  try
    {
      
    }
  catch
    {
      std::__weak_ptr<std::__future_base::_State_baseV2, (__gnu_cxx::_Lock_policy)2u>::~__weak_ptr (&((struct weak_ptr *) this)->D.65219);
    }
}


;; Function void std::promise<void>::set_exception_at_thread_exit(std::__exception_ptr::exception_ptr) (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::__future_base::_State_baseV2::_M_set_delayed_result (std::__shared_ptr<std::__future_base::_State_baseV2, (__gnu_cxx::_Lock_policy)2u>::operator-> (&((struct promise *) this)->_M_future.D.69901), &TARGET_EXPR <D.73215, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.73215
  (struct function *) <<< Unknown tree: void_cst >>>
  TARGET_EXPR <D.73205, std::__future_base::_State_baseV2::__setter<void> ((struct exception_ptr &) (struct exception_ptr *) __p, (struct promise *) this)> >>>>, &TARGET_EXPR <D.73216, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.73216
  (struct weak_ptr *) <<< Unknown tree: void_cst >>>
  (const struct shared_ptr &) (const struct shared_ptr *) &((struct promise *) this)->_M_future >>>>) >>>>>;


;; Function std::promise<void>::_Ptr_type std::__future_base::_State_baseV2::_Setter<void, void>::operator()() const (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::__future_base::_State_baseV2::_S_check<std::__future_base::_State_baseV2> ((const struct shared_ptr &) (const struct shared_ptr *) &((struct promise *) ((const struct _Setter *) this)->_M_promise)->_M_future) >>>>>;
<<cleanup_point return *<retval> = TARGET_EXPR <D.73226, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.73226
  (struct unique_ptr *) <<< Unknown tree: void_cst >>>
  (struct unique_ptr &) (struct type *) std::move<std::unique_ptr<std::__future_base::_Result<void>, std::__future_base::_Result_base::_Deleter>&> ((struct unique_ptr &) &((struct promise *) ((const struct _Setter *) this)->_M_promise)->_M_storage) >>>>>>;


;; Function void std::promise<void>::set_value() (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::__future_base::_State_baseV2::_M_set_result (std::__shared_ptr<std::__future_base::_State_baseV2, (__gnu_cxx::_Lock_policy)2u>::operator-> (&((struct promise *) this)->_M_future.D.69901), &TARGET_EXPR <D.73372, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.73372
  (struct function *) <<< Unknown tree: void_cst >>>
  TARGET_EXPR <D.73230, {._M_promise=(struct promise *) this}> >>>>, 0) >>>>>;


;; Function void std::promise<void>::set_value_at_thread_exit() (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::__future_base::_State_baseV2::_M_set_delayed_result (std::__shared_ptr<std::__future_base::_State_baseV2, (__gnu_cxx::_Lock_policy)2u>::operator-> (&((struct promise *) this)->_M_future.D.69901), &TARGET_EXPR <D.73377, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.73377
  (struct function *) <<< Unknown tree: void_cst >>>
  TARGET_EXPR <D.73376, {._M_promise=(struct promise *) this}> >>>>, &TARGET_EXPR <D.73378, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.73378
  (struct weak_ptr *) <<< Unknown tree: void_cst >>>
  (const struct shared_ptr &) (const struct shared_ptr *) &((struct promise *) this)->_M_future >>>>) >>>>>;


;; Function virtual void std::__future_base::_Async_state_commonV2::_M_complete_async() (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::__future_base::_Async_state_commonV2::_M_join (this) >>>>>;


;; Function void std::__future_base::_Async_state_commonV2::_M_join() (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::call_once<void (std::thread::*)(), std::reference_wrapper<std::thread> > ((struct once_flag &) &((struct _Async_state_commonV2 *) this)->_M_once, (struct 
  {
    void thread::<Ta344> (struct thread *) * __pfn;
    long int __delta;
  } &) &TARGET_EXPR <D.74035, <<< Unknown tree: ptrmem_cst >>>>, (struct reference_wrapper &) &TARGET_EXPR <D.74021, std::ref<std::thread> ((struct thread &) &((struct _Async_state_commonV2 *) this)->_M_thread)>) >>>>>;


;; Function std::_Bit_reference::_Bit_reference(std::_Bit_type*, std::_Bit_type) (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Bit_reference *) this)->_M_p = __x) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Bit_reference *) this)->_M_mask = __y) >>>>>;
}


;; Function std::_Bit_reference::_Bit_reference() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Bit_reference *) this)->_M_p = 0B) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Bit_reference *) this)->_M_mask = 0) >>>>>;
  }
   >>>;


;; Function std::_Bit_reference::operator bool() const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (*(_Bit_type *) ((const struct _Bit_reference *) this)->_M_p & (long unsigned int) ((const struct _Bit_reference *) this)->_M_mask) != 0
   >>>;


;; Function std::_Bit_reference& std::_Bit_reference::operator=(bool) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  if (__x)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*((struct _Bit_reference *) this)->_M_p = *((struct _Bit_reference *) this)->_M_p | ((struct _Bit_reference *) this)->_M_mask) >>>>>;
    }
  else
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*((struct _Bit_reference *) this)->_M_p = *((struct _Bit_reference *) this)->_M_p & ~((struct _Bit_reference *) this)->_M_mask) >>>>>;
    }
  return <retval> = (struct _Bit_reference &) (struct _Bit_reference *) this;
   >>>;


;; Function std::_Bit_reference& std::_Bit_reference::operator=(const std::_Bit_reference&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct _Bit_reference &) (struct _Bit_reference *) std::_Bit_reference::operator= (this, (int) std::_Bit_reference::operator bool ((const struct _Bit_reference *) __x))>>
   >>>;


;; Function bool std::_Bit_reference::operator==(const std::_Bit_reference&) const (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = std::_Bit_reference::operator bool (this) == std::_Bit_reference::operator bool ((const struct _Bit_reference *) __x)>>;


;; Function bool std::_Bit_reference::operator<(const std::_Bit_reference&) const (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = !std::_Bit_reference::operator bool (this) && std::_Bit_reference::operator bool ((const struct _Bit_reference *) __x)>>;


;; Function void std::_Bit_reference::flip() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*((struct _Bit_reference *) this)->_M_p = *((struct _Bit_reference *) this)->_M_p ^ ((struct _Bit_reference *) this)->_M_mask) >>>>>
   >>>;


;; Function void std::swap(std::_Bit_reference, std::_Bit_reference) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    bool __tmp;

        bool __tmp;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__tmp = std::_Bit_reference::operator bool (&__x)) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::_Bit_reference::operator= (&__x, (const struct _Bit_reference &) (const struct _Bit_reference *) &__y) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::_Bit_reference::operator= (&__y, (int) __tmp) >>>>>;
  }
   >>>;


;; Function void std::swap(std::_Bit_reference, bool&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    bool __tmp;

        bool __tmp;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__tmp = std::_Bit_reference::operator bool (&__x)) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::_Bit_reference::operator= (&__x, (int) *__y) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__y = __tmp) >>>>>;
  }
   >>>;


;; Function void std::swap(bool&, std::_Bit_reference) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    bool __tmp = *__x;

        bool __tmp = *__x;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__x = std::_Bit_reference::operator bool (&__y)) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::_Bit_reference::operator= (&__y, (int) __tmp) >>>>>;
  }
   >>>;


;; Function constexpr std::iterator<std::random_access_iterator_tag, bool>::iterator() (null)
;; enabled by -tree-original


{
  
}


;; Function std::_Bit_iterator_base::_Bit_iterator_base(std::_Bit_type*, unsigned int) (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::iterator<std::random_access_iterator_tag, bool>::iterator ((struct iterator *) this) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Bit_iterator_base *) this)->_M_p = __x) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Bit_iterator_base *) this)->_M_offset = __y) >>>>>;
}


;; Function void std::_Bit_iterator_base::_M_bump_up() (null)
;; enabled by -tree-original


if (<<cleanup_point ((struct _Bit_iterator_base *) this)->_M_offset++  == 63>>)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Bit_iterator_base *) this)->_M_offset = 0) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void)  ++((struct _Bit_iterator_base *) this)->_M_p >>>>>;
  }


;; Function void std::_Bit_iterator_base::_M_bump_down() (null)
;; enabled by -tree-original


if (<<cleanup_point ((struct _Bit_iterator_base *) this)->_M_offset--  == 0>>)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Bit_iterator_base *) this)->_M_offset = 63) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void)  --((struct _Bit_iterator_base *) this)->_M_p >>>>>;
  }


;; Function void std::_Bit_iterator_base::_M_incr(std::ptrdiff_t) (null)
;; enabled by -tree-original


{
  difference_type __n = (ptrdiff_t) ((struct _Bit_iterator_base *) this)->_M_offset + __i;

    difference_type __n = (ptrdiff_t) ((struct _Bit_iterator_base *) this)->_M_offset + __i;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Bit_iterator_base *) this)->_M_p = ((struct _Bit_iterator_base *) this)->_M_p + (sizetype) ((long unsigned int) (__n / 64) * 8)) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__n = __n % 64) >>>>>;
  if (__n < 0)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__n = __n + 64) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void)  --((struct _Bit_iterator_base *) this)->_M_p >>>>>;
    }
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Bit_iterator_base *) this)->_M_offset = (unsigned int) __n) >>>>>;
}


;; Function bool std::_Bit_iterator_base::operator==(const std::_Bit_iterator_base&) const (null)
;; enabled by -tree-original


return <retval> = (_Bit_type *) ((const struct _Bit_iterator_base *) this)->_M_p == (_Bit_type *) __i->_M_p && (unsigned int) ((const struct _Bit_iterator_base *) this)->_M_offset == (unsigned int) __i->_M_offset;


;; Function bool std::_Bit_iterator_base::operator<(const std::_Bit_iterator_base&) const (null)
;; enabled by -tree-original


return <retval> = (_Bit_type *) ((const struct _Bit_iterator_base *) this)->_M_p < (_Bit_type *) __i->_M_p || (_Bit_type *) ((const struct _Bit_iterator_base *) this)->_M_p == (_Bit_type *) __i->_M_p && (unsigned int) ((const struct _Bit_iterator_base *) this)->_M_offset < (unsigned int) __i->_M_offset;


;; Function bool std::_Bit_iterator_base::operator!=(const std::_Bit_iterator_base&) const (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = !std::_Bit_iterator_base::operator== (this, (const struct _Bit_iterator_base &) (const struct _Bit_iterator_base *) __i)>>;


;; Function bool std::_Bit_iterator_base::operator>(const std::_Bit_iterator_base&) const (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = std::_Bit_iterator_base::operator< ((const struct _Bit_iterator_base *) __i, (const struct _Bit_iterator_base &) (const struct _Bit_iterator_base *) this)>>;


;; Function bool std::_Bit_iterator_base::operator<=(const std::_Bit_iterator_base&) const (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = !std::_Bit_iterator_base::operator< ((const struct _Bit_iterator_base *) __i, (const struct _Bit_iterator_base &) (const struct _Bit_iterator_base *) this)>>;


;; Function bool std::_Bit_iterator_base::operator>=(const std::_Bit_iterator_base&) const (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = !std::_Bit_iterator_base::operator< (this, (const struct _Bit_iterator_base &) (const struct _Bit_iterator_base *) __i)>>;


;; Function std::ptrdiff_t std::operator-(const std::_Bit_iterator_base&, const std::_Bit_iterator_base&) (null)
;; enabled by -tree-original


return <retval> = (((long int) __x->_M_p - (long int) __y->_M_p) * 8 + (long int) __x->_M_offset) - (long int) __y->_M_offset;


;; Function std::_Bit_iterator::_Bit_iterator() (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Bit_iterator_base::_Bit_iterator_base (&((struct _Bit_iterator *) this)->D.75104, 0B, 0) >>>>>;
}


;; Function std::_Bit_iterator::_Bit_iterator(std::_Bit_type*, unsigned int) (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Bit_iterator_base::_Bit_iterator_base (&((struct _Bit_iterator *) this)->D.75104, __x, __y) >>>>>;
}


;; Function std::_Bit_iterator::iterator std::_Bit_iterator::_M_const_cast() const (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = TARGET_EXPR <D.75158, *(const struct _Bit_iterator &) (const struct _Bit_iterator *) this>>>;


;; Function std::_Bit_iterator::reference std::_Bit_iterator::operator*() const (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = TARGET_EXPR <D.75169, <<< Unknown tree: aggr_init_expr
  6
  __comp_ctor 
  D.75169
  (struct _Bit_reference *) <<< Unknown tree: void_cst >>>
  (_Bit_type *) ((const struct _Bit_iterator *) this)->D.75104._M_p
  1 << (unsigned int) ((const struct _Bit_iterator *) this)->D.75104._M_offset >>>>;, D.75169>>;


;; Function std::_Bit_iterator::iterator& std::_Bit_iterator::operator++() (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::_Bit_iterator_base::_M_bump_up (&((struct _Bit_iterator *) this)->D.75104) >>>>>;
return <retval> = (struct iterator &) (struct iterator *) this;


;; Function std::_Bit_iterator::iterator std::_Bit_iterator::operator++(int) (null)
;; enabled by -tree-original


{
  struct iterator __tmp = *(const struct _Bit_iterator &) (const struct _Bit_iterator *) this;

    struct iterator __tmp = *(const struct _Bit_iterator &) (const struct _Bit_iterator *) this;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Bit_iterator_base::_M_bump_up (&((struct _Bit_iterator *) this)->D.75104) >>>>>;
  <<cleanup_point return <retval> = TARGET_EXPR <D.75183, __tmp>>>;
}


;; Function std::_Bit_iterator::iterator& std::_Bit_iterator::operator--() (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::_Bit_iterator_base::_M_bump_down (&((struct _Bit_iterator *) this)->D.75104) >>>>>;
return <retval> = (struct iterator &) (struct iterator *) this;


;; Function std::_Bit_iterator::iterator std::_Bit_iterator::operator--(int) (null)
;; enabled by -tree-original


{
  struct iterator __tmp = *(const struct _Bit_iterator &) (const struct _Bit_iterator *) this;

    struct iterator __tmp = *(const struct _Bit_iterator &) (const struct _Bit_iterator *) this;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Bit_iterator_base::_M_bump_down (&((struct _Bit_iterator *) this)->D.75104) >>>>>;
  <<cleanup_point return <retval> = TARGET_EXPR <D.75188, __tmp>>>;
}


;; Function std::_Bit_iterator::iterator& std::_Bit_iterator::operator+=(std::iterator<std::random_access_iterator_tag, bool>::difference_type) (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::_Bit_iterator_base::_M_incr (&((struct _Bit_iterator *) this)->D.75104, __i) >>>>>;
return <retval> = (struct iterator &) (struct iterator *) this;


;; Function std::_Bit_iterator::iterator& std::_Bit_iterator::operator-=(std::iterator<std::random_access_iterator_tag, bool>::difference_type) (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::_Bit_iterator::operator+= (this, -NON_LVALUE_EXPR <__i>) >>>>>;
return <retval> = (struct iterator &) (struct iterator *) this;


;; Function std::_Bit_iterator::iterator std::_Bit_iterator::operator+(std::iterator<std::random_access_iterator_tag, bool>::difference_type) const (null)
;; enabled by -tree-original


{
  struct iterator __tmp = *(const struct _Bit_iterator &) (const struct _Bit_iterator *) this;

    struct iterator __tmp = *(const struct _Bit_iterator &) (const struct _Bit_iterator *) this;
  <<cleanup_point return <retval> = TARGET_EXPR <D.75194, *(const struct _Bit_iterator &) (const struct _Bit_iterator *) std::_Bit_iterator::operator+= (&__tmp, __i)>>>;
}


;; Function std::_Bit_iterator::iterator std::_Bit_iterator::operator-(std::iterator<std::random_access_iterator_tag, bool>::difference_type) const (null)
;; enabled by -tree-original


{
  struct iterator __tmp = *(const struct _Bit_iterator &) (const struct _Bit_iterator *) this;

    struct iterator __tmp = *(const struct _Bit_iterator &) (const struct _Bit_iterator *) this;
  <<cleanup_point return <retval> = TARGET_EXPR <D.75198, *(const struct _Bit_iterator &) (const struct _Bit_iterator *) std::_Bit_iterator::operator-= (&__tmp, __i)>>>;
}


;; Function std::_Bit_iterator::reference std::_Bit_iterator::operator[](std::iterator<std::random_access_iterator_tag, bool>::difference_type) const (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = TARGET_EXPR <D.75201, std::_Bit_iterator::operator* (&TARGET_EXPR <D.75200, std::_Bit_iterator::operator+ (this, __i)>)>>>;


;; Function std::_Bit_iterator std::operator+(std::ptrdiff_t, const std::_Bit_iterator&) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = TARGET_EXPR <D.75206, std::_Bit_iterator::operator+ ((const struct _Bit_iterator *) __x, __n)>>>;


;; Function std::_Bit_const_iterator::_Bit_const_iterator() (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Bit_iterator_base::_Bit_iterator_base (&((struct _Bit_const_iterator *) this)->D.75269, 0B, 0) >>>>>;
}


;; Function std::_Bit_const_iterator::_Bit_const_iterator(std::_Bit_type*, unsigned int) (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Bit_iterator_base::_Bit_iterator_base (&((struct _Bit_const_iterator *) this)->D.75269, __x, __y) >>>>>;
}


;; Function std::_Bit_const_iterator::_Bit_const_iterator(const std::_Bit_iterator&) (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Bit_iterator_base::_Bit_iterator_base (&((struct _Bit_const_iterator *) this)->D.75269, (_Bit_type *) ((const struct _Bit_iterator *) __x)->D.75104._M_p, (unsigned int) ((const struct _Bit_iterator *) __x)->D.75104._M_offset) >>>>>;
}


;; Function std::_Bit_iterator std::_Bit_const_iterator::_M_const_cast() const (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = TARGET_EXPR <D.75281, <<< Unknown tree: aggr_init_expr
  6
  __comp_ctor 
  D.75281
  (struct _Bit_iterator *) <<< Unknown tree: void_cst >>>
  (_Bit_type *) ((const struct _Bit_const_iterator *) this)->D.75269._M_p
  (unsigned int) ((const struct _Bit_const_iterator *) this)->D.75269._M_offset >>>>;, D.75281>>;


;; Function std::_Bit_const_iterator::const_reference std::_Bit_const_iterator::operator*() const (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = std::_Bit_reference::operator bool (&TARGET_EXPR <D.75283, <<< Unknown tree: aggr_init_expr
  6
  __comp_ctor 
  D.75283
  (struct _Bit_reference *) <<< Unknown tree: void_cst >>>
  (_Bit_type *) ((const struct _Bit_const_iterator *) this)->D.75269._M_p
  1 << (unsigned int) ((const struct _Bit_const_iterator *) this)->D.75269._M_offset >>>>)>>;


;; Function std::_Bit_const_iterator::const_iterator& std::_Bit_const_iterator::operator++() (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::_Bit_iterator_base::_M_bump_up (&((struct _Bit_const_iterator *) this)->D.75269) >>>>>;
return <retval> = (struct const_iterator &) (struct const_iterator *) this;


;; Function std::_Bit_const_iterator::const_iterator std::_Bit_const_iterator::operator++(int) (null)
;; enabled by -tree-original


{
  struct const_iterator __tmp = *(const struct _Bit_const_iterator &) (const struct _Bit_const_iterator *) this;

    struct const_iterator __tmp = *(const struct _Bit_const_iterator &) (const struct _Bit_const_iterator *) this;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Bit_iterator_base::_M_bump_up (&((struct _Bit_const_iterator *) this)->D.75269) >>>>>;
  <<cleanup_point return <retval> = TARGET_EXPR <D.75315, __tmp>>>;
}


;; Function std::_Bit_const_iterator::const_iterator& std::_Bit_const_iterator::operator--() (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::_Bit_iterator_base::_M_bump_down (&((struct _Bit_const_iterator *) this)->D.75269) >>>>>;
return <retval> = (struct const_iterator &) (struct const_iterator *) this;


;; Function std::_Bit_const_iterator::const_iterator std::_Bit_const_iterator::operator--(int) (null)
;; enabled by -tree-original


{
  struct const_iterator __tmp = *(const struct _Bit_const_iterator &) (const struct _Bit_const_iterator *) this;

    struct const_iterator __tmp = *(const struct _Bit_const_iterator &) (const struct _Bit_const_iterator *) this;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Bit_iterator_base::_M_bump_down (&((struct _Bit_const_iterator *) this)->D.75269) >>>>>;
  <<cleanup_point return <retval> = TARGET_EXPR <D.75320, __tmp>>>;
}


;; Function std::_Bit_const_iterator::const_iterator& std::_Bit_const_iterator::operator+=(std::iterator<std::random_access_iterator_tag, bool>::difference_type) (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::_Bit_iterator_base::_M_incr (&((struct _Bit_const_iterator *) this)->D.75269, __i) >>>>>;
return <retval> = (struct const_iterator &) (struct const_iterator *) this;


;; Function std::_Bit_const_iterator::const_iterator& std::_Bit_const_iterator::operator-=(std::iterator<std::random_access_iterator_tag, bool>::difference_type) (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::_Bit_const_iterator::operator+= (this, -NON_LVALUE_EXPR <__i>) >>>>>;
return <retval> = (struct const_iterator &) (struct const_iterator *) this;


;; Function std::_Bit_const_iterator::const_iterator std::_Bit_const_iterator::operator+(std::iterator<std::random_access_iterator_tag, bool>::difference_type) const (null)
;; enabled by -tree-original


{
  struct const_iterator __tmp = *(const struct _Bit_const_iterator &) (const struct _Bit_const_iterator *) this;

    struct const_iterator __tmp = *(const struct _Bit_const_iterator &) (const struct _Bit_const_iterator *) this;
  <<cleanup_point return <retval> = TARGET_EXPR <D.75326, *(const struct _Bit_const_iterator &) (const struct _Bit_const_iterator *) std::_Bit_const_iterator::operator+= (&__tmp, __i)>>>;
}


;; Function std::_Bit_const_iterator::const_iterator std::_Bit_const_iterator::operator-(std::iterator<std::random_access_iterator_tag, bool>::difference_type) const (null)
;; enabled by -tree-original


{
  struct const_iterator __tmp = *(const struct _Bit_const_iterator &) (const struct _Bit_const_iterator *) this;

    struct const_iterator __tmp = *(const struct _Bit_const_iterator &) (const struct _Bit_const_iterator *) this;
  <<cleanup_point return <retval> = TARGET_EXPR <D.75330, *(const struct _Bit_const_iterator &) (const struct _Bit_const_iterator *) std::_Bit_const_iterator::operator-= (&__tmp, __i)>>>;
}


;; Function std::_Bit_const_iterator::const_reference std::_Bit_const_iterator::operator[](std::iterator<std::random_access_iterator_tag, bool>::difference_type) const (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = std::_Bit_const_iterator::operator* (&TARGET_EXPR <D.75332, std::_Bit_const_iterator::operator+ (this, __i)>)>>;


;; Function std::_Bit_const_iterator std::operator+(std::ptrdiff_t, const std::_Bit_const_iterator&) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = TARGET_EXPR <D.75337, std::_Bit_const_iterator::operator+ ((const struct _Bit_const_iterator *) __x, __n)>>>;


;; Function void std::__fill_bvector(std::_Bit_iterator, std::_Bit_iterator, bool) (null)
;; enabled by -tree-original


while (1)
  {
    if (<<cleanup_point std::_Bit_iterator_base::operator!= (&__first.D.75104, (const struct _Bit_iterator_base &) (const struct _Bit_iterator_base *) &__last.D.75104)>>) (void) 0; else goto <D.75348>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::_Bit_reference::operator= (&TARGET_EXPR <D.75347, std::_Bit_iterator::operator* (&__first)>, (int) __x) >>>>>;
    <<cleanup_point (void) std::_Bit_iterator::operator++ (&__first)>>;
  }
<D.75348>:;


;; Function void std::fill(std::_Bit_iterator, std::_Bit_iterator, const bool&) (null)
;; enabled by -tree-original


if (__first.D.75104._M_p != __last.D.75104._M_p)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::fill<long unsigned int*, int> (__first.D.75104._M_p + 8, __last.D.75104._M_p, (const int &) &TARGET_EXPR <D.75359, (bool) *__x ? -1 : 0>) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__fill_bvector (TARGET_EXPR <D.75361, __first>, TARGET_EXPR <D.75360, <<< Unknown tree: aggr_init_expr
  6
  __comp_ctor 
  D.75360
  (struct _Bit_iterator *) <<< Unknown tree: void_cst >>>
  __first.D.75104._M_p + 8
  0 >>>>, (int) *__x) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__fill_bvector (TARGET_EXPR <D.75362, <<< Unknown tree: aggr_init_expr
  6
  __comp_ctor 
  D.75362
  (struct _Bit_iterator *) <<< Unknown tree: void_cst >>>
  __last.D.75104._M_p
  0 >>>>, TARGET_EXPR <D.75363, __last>, (int) *__x) >>>>>;
  }
else
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__fill_bvector (TARGET_EXPR <D.75364, __first>, TARGET_EXPR <D.75365, __last>, (int) *__x) >>>>>;
  }


;; Function constexpr typename std::common_type<std::chrono::duration<_Rep1, _Period1>, std::chrono::duration<_Rep2, _Period2> >::type std::chrono::operator-(const std::chrono::duration<_Rep1, _Period1>&, const std::chrono::duration<_Rep2, _Period2>&) [with _Rep1 = long int; _Period1 = std::ratio<1l, 1000000000l>; _Rep2 = long int; _Period2 = std::ratio<1l, 1000000000l>; typename std::common_type<std::chrono::duration<_Rep1, _Period1>, std::chrono::duration<_Rep2, _Period2> >::type = std::chrono::duration<long int, std::ratio<1l, 1000000000l> >] (null)
;; enabled by -tree-original


{
  typedef struct __dur1 __dur1;
  typedef struct __dur2 __dur2;
  typedef struct __cd __cd;

  <<cleanup_point return <retval> = TARGET_EXPR <D.77245, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.77245
  (struct duration *) <<< Unknown tree: void_cst >>>
  (const long int &) &TARGET_EXPR <D.77244, std::chrono::duration<long int, std::ratio<1l, 1000000000l> >::count (&TARGET_EXPR <D.77242, *(const struct duration &) (const struct duration *) __lhs>) - std::chrono::duration<long int, std::ratio<1l, 1000000000l> >::count (&TARGET_EXPR <D.77243, *(const struct duration &) (const struct duration *) __rhs>)> >>>>;, D.77245>>;
}


;; Function constexpr typename std::common_type<_Duration1, _Duration2>::type std::chrono::operator-(const std::chrono::time_point<_Clock, _Duration1>&, const std::chrono::time_point<_Clock, _Duration2>&) [with _Clock = std::chrono::_V2::system_clock; _Dur1 = std::chrono::duration<long int, std::ratio<1l, 1000000000l> >; _Dur2 = std::chrono::duration<long int, std::ratio<1l, 1000000000l> >; typename std::common_type<_Duration1, _Duration2>::type = std::chrono::duration<long int, std::ratio<1l, 1000000000l> >] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = TARGET_EXPR <D.77246, std::chrono::operator-<long int, std::ratio<1l, 1000000000l>, long int, std::ratio<1l, 1000000000l> > ((const struct duration &) (const struct duration *) &TARGET_EXPR <D.77233, std::chrono::time_point<std::chrono::_V2::system_clock, std::chrono::duration<long int, std::ratio<1l, 1000000000l> > >::time_since_epoch ((const struct time_point *) __lhs)>, (const struct duration &) (const struct duration *) &TARGET_EXPR <D.77234, std::chrono::time_point<std::chrono::_V2::system_clock, std::chrono::duration<long int, std::ratio<1l, 1000000000l> > >::time_since_epoch ((const struct time_point *) __rhs)>)>>>;


;; Function static constexpr _ToDur std::chrono::__duration_cast_impl<_ToDur, _CF, _CR, true, true>::__cast(const std::chrono::duration<_Rep, _Period>&) [with _Rep = long int; _Period = std::ratio<1l, 1000000000l>; _ToDur = std::chrono::duration<long int, std::ratio<1l, 1000000000l> >; _CF = std::ratio<1l>; _CR = long int] (null)
;; enabled by -tree-original


{
  typedef __to_rep __to_rep;

  <<cleanup_point return <retval> = TARGET_EXPR <D.77278, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.77278
  (struct duration *) <<< Unknown tree: void_cst >>>
  (const long int &) &TARGET_EXPR <D.77277, std::chrono::duration<long int, std::ratio<1l, 1000000000l> >::count ((const struct duration *) __d)> >>>>;, D.77278>>;
}


;; Function constexpr typename std::enable_if<std::chrono::__is_duration<_Tp>::value, _ToDur>::type std::chrono::duration_cast(const std::chrono::duration<_Rep, _Period>&) [with _ToDur = std::chrono::duration<long int, std::ratio<1l, 1000000000l> >; _Rep = long int; _Period = std::ratio<1l, 1000000000l>; typename std::enable_if<std::chrono::__is_duration<_Tp>::value, _ToDur>::type = std::chrono::duration<long int, std::ratio<1l, 1000000000l> >] (null)
;; enabled by -tree-original


{
  typedef struct __to_period __to_period;
  typedef __to_rep __to_rep;
  typedef struct __cf __cf;
  typedef __cr __cr;
  typedef struct __dc __dc;

  <<cleanup_point return <retval> = TARGET_EXPR <D.77279, std::chrono::__duration_cast_impl<std::chrono::duration<long int, std::ratio<1l, 1000000000l> >, std::ratio<1l>, long int, true, true>::__cast<long int, std::ratio<1l, 1000000000l> > ((const struct duration &) (const struct duration *) __d)>>>;
}


;; Function long int f(int, int) (null)
;; enabled by -tree-original


{
  volatile int i = 0;
  atrshmlog_time_t log_starttime;
  struct time_point starttime;
  volatile int h = 0;
  struct duration delta;

  <<cleanup_point   volatile int i = 0;>>;
    atrshmlog_time_t log_starttime;
    struct time_point starttime;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (starttime = std::chrono::_V2::system_clock::now ()) >>>>>;
  <<cleanup_point   volatile int h = 0;>>;
  while (1)
    {
      if (i_loops <= 0) goto <D.77281>;
      {
        const int event = th;
        const char eventflag = 73;
        int userevent;
        atrshmlog_time_t log_endtime;

        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*(atrshmlog_time_t &) &log_starttime = ((int) *NON_LVALUE_EXPR <atrshmlog_event_locks> & (int) atrshmlog_logging_process) != 0 ? atrshmlog_get_tsc_x86_64_gnu () : 0) >>>>>;
                const int event = th;
        <<cleanup_point         const char eventflag = 73;>>;
                int userevent;
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (userevent = (int) i) >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) i++  >>>>>;
        {
          int k = 0;

          <<cleanup_point           int k = 0;>>;
          while (1)
            {
              if ((long int) k >= mainloopcount) goto <D.77283>;
              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (h = (int) h + 1) >>>>>;
              <<cleanup_point (void) k++ >>;
            }
          <D.77283>:;
        }
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) i_loops--  >>>>>;
                atrshmlog_time_t log_endtime;
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*(atrshmlog_time_t &) &log_endtime = ((int) *NON_LVALUE_EXPR <atrshmlog_event_locks> & (int) atrshmlog_logging_process) != 0 ? atrshmlog_get_tsc_x86_64_gnu () : 0) >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  if (((int) *(atrshmlog_event_locks + (sizetype) *(const int &) &event) & (int) atrshmlog_logging_process) != 0)
    {
      (void) atrshmlog_write1 ((int) *(const int &) &event, (atrshmlog_int32_t) *(const char &) &eventflag, *(int &) &userevent, *(atrshmlog_time_t &) &log_starttime, *(atrshmlog_time_t &) &log_endtime, (const void *) (const char *) "hello world", (atrshmlog_int32_t) ((unsigned int) 12 + 4294967295));
    }
  else
    {
      <<< Unknown tree: void_cst >>>
    } >>>>>;
      }
    }
  <D.77281>:;
  <<cleanup_point <<< Unknown tree: expr_stmt
  atrshmlog_stop () >>>>>;
    struct duration delta;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (delta = std::chrono::duration_cast<std::chrono::duration<long int, std::ratio<1l, 1000000000l> >, long int, std::ratio<1l, 1000000000l> > ((const struct duration &) (const struct duration *) &TARGET_EXPR <D.77247, std::chrono::operator-<std::chrono::_V2::system_clock, std::chrono::duration<long int, std::ratio<1l, 1000000000l> >, std::chrono::duration<long int, std::ratio<1l, 1000000000l> > > ((const struct time_point &) (const struct time_point *) &TARGET_EXPR <D.77228, std::chrono::_V2::system_clock::now ()>, (const struct time_point &) (const struct time_point *) &starttime)>)) >>>>>;
  <<cleanup_point return <retval> = std::chrono::duration<long int, std::ratio<1l, 1000000000l> >::count (&delta)>>;
}


;; Function std::__basic_future<long int>::~__basic_future() (null)
;; enabled by -tree-original


{
  try
    {
      try
        {
          
        }
      finally
        {
          std::shared_ptr<std::__future_base::_State_baseV2>::~shared_ptr (&((struct __basic_future *) this)->_M_state);
        }
    }
  finally
    {
      *(struct 
      {
        struct __state_type _M_state;
      } &) this = {CLOBBER};
    }
}
<D.82491>:;


;; Function std::future<long int>::~future() (null)
;; enabled by -tree-original


{
  try
    {
      try
        {
          
        }
      finally
        {
          std::__basic_future<long int>::~__basic_future (&((struct future *) this)->D.82467);
        }
    }
  finally
    {
      *(struct 
      {
        struct 
        {
          struct __state_type _M_state;
        } D.82468;
      } &) this = {CLOBBER};
    }
}
<D.82489>:;


;; Function constexpr typename std::remove_reference< <template-parameter-1-1> >::type&& std::move(_Tp&&) [with _Tp = std::packaged_task<long int(int, int)>&; typename std::remove_reference< <template-parameter-1-1> >::type = std::packaged_task<long int(int, int)>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct type &) (struct type *) NON_LVALUE_EXPR <(struct type &) __t>
   >>>;


;; Function void dispatcher(int, int) (null)
;; enabled by -tree-original


{
  typedef long int Task_type (int, int) Task_type;
  typedef struct Future_type Future_type;
  typedef struct vp_type vp_type;
  typedef struct vf_type vf_type;
  typedef struct vt_type vt_type;
  struct vp_type vp;
  struct vf_type vf;
  struct vt_type the_tasks;
  int limit = i_count;

  (void) 0;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::basic_ostream<char>::operator<< ((struct basic_ostream *) std::basic_ostream<char>::operator<< ((struct basic_ostream *) std::operator<< <std::char_traits<char> > ((struct basic_ostream &) (struct basic_ostream *) std::basic_ostream<char>::operator<< ((struct basic_ostream *) std::operator<< <std::char_traits<char> > ((struct basic_ostream &) &cout, (const char *) "dispatcher has count "), i_count), (const char *) " and looptime "), i_seconds), endl) >>>>>;
    struct vp_type vp;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::vector<std::packaged_task<long int(int, int)> >::vector (&vp) >>>>>;
  try
    {
            struct vf_type vf;
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::vector<std::future<long int> >::vector (&vf) >>>>>;
      try
        {
                    struct vt_type the_tasks;
          <<cleanup_point <<< Unknown tree: expr_stmt
  std::vector<std::thread*>::vector (&the_tasks) >>>>>;
          try
            {
                            int limit = i_count;
              {
                int i = 0;

                <<cleanup_point                 int i = 0;>>;
                while (1)
                  {
                    if (i >= limit) goto <D.82549>;
                    <<cleanup_point <<< Unknown tree: expr_stmt
  std::vector<std::packaged_task<long int(int, int)> >::emplace_back<std::packaged_task<long int(int, int)> > (&vp, (struct packaged_task &) &TARGET_EXPR <D.82289, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.82289
  (struct packaged_task *) <<< Unknown tree: void_cst >>>
  (long int (&<T105d3>) (int, int)) f >>>>) >>>>>;
                    <<cleanup_point <<< Unknown tree: expr_stmt
  std::vector<std::future<long int> >::emplace_back<std::future<long int> > (&vf, (struct future &) &TARGET_EXPR <D.82469, <<< Unknown tree: aggr_init_expr
  4
  get_future
  D.82469
  (struct value_type *) std::vector<std::packaged_task<long int(int, int)> >::operator[] (&vp, (size_type) i) >>>>) >>>>>;
                    <<cleanup_point (void) i++ >>;
                  }
                <D.82549>:;
              }
              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::basic_ostream<char>::operator<< ((struct basic_ostream *) std::operator<< <std::char_traits<char> > ((struct basic_ostream &) &cout, (const char *) "packages made "), endl) >>>>>;
              {
                int i = 0;

                <<cleanup_point                 int i = 0;>>;
                while (1)
                  {
                    if (i >= limit) goto <D.82551>;
                    <<cleanup_point <<< Unknown tree: expr_stmt
  std::vector<std::thread*>::push_back (&the_tasks, (struct thread * &) &TARGET_EXPR <D.82532, (TARGET_EXPR <D.82530, (struct packaged_task &) (struct type *) std::move<std::packaged_task<long int(int, int)>&> ((struct packaged_task &) (struct value_type *) std::vector<std::packaged_task<long int(int, int)> >::operator[] (&vp, (size_type) i))>;, TARGET_EXPR <D.82531, (int &) &TARGET_EXPR <D.82529, i + 1>>;;, TARGET_EXPR <D.82513, operator new (8)>;, try
    {
      std::thread::thread<std::packaged_task<long int(int, int)>, int&, int> ((struct thread *) D.82513, NON_LVALUE_EXPR <D.82530>, (int &) &i_seconds, NON_LVALUE_EXPR <D.82531>);
    }
  catch
    {
      operator delete (D.82513, 8);
    }, (struct thread *) D.82513;)>) >>>>>;
                    <<cleanup_point (void) i++ >>;
                  }
                <D.82551>:;
              }
              <<cleanup_point <<< Unknown tree: expr_stmt
  std::vector<std::packaged_task<long int(int, int)> >::clear (&vp) >>>>>;
              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) sleep (10) >>>>>;
              {
                int i = 0;

                <<cleanup_point                 int i = 0;>>;
                while (1)
                  {
                    if (i >= limit) goto <D.82553>;
                    {
                      struct thread * p;

                                            struct thread * p;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (p = *std::vector<std::thread*>::operator[] (&the_tasks, (size_type) i)) >>>>>;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  std::thread::join (NON_LVALUE_EXPR <p>) >>>>>;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  if (SAVE_EXPR <p> != 0B)
    {
      std::thread::~thread (SAVE_EXPR <p>);, operator delete ((void *) SAVE_EXPR <p>, 8);;
    }
  else
    {
      <<< Unknown tree: void_cst >>>
    } >>>>>;
                    }
                    <<cleanup_point (void) i++ >>;
                  }
                <D.82553>:;
              }
              <<cleanup_point <<< Unknown tree: expr_stmt
  std::vector<std::thread*>::clear (&the_tasks) >>>>>;
              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (totalcount = 0) >>>>>;
              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (maxcount = 0) >>>>>;
              {
                int i = 0;

                <<cleanup_point                 int i = 0;>>;
                while (1)
                  {
                    if (i >= limit) goto <D.82555>;
                    {
                      long int r;

                                            long int r;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (r = std::future<long int>::get ((struct value_type *) std::vector<std::future<long int> >::operator[] (&vf, (size_type) i))) >>>>>;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::basic_ostream<char>::operator<< ((struct __ostream_type *) std::basic_ostream<char>::operator<< ((struct basic_ostream *) std::operator<< <std::char_traits<char> > ((struct basic_ostream &) (struct basic_ostream *) std::basic_ostream<char>::operator<< (&cout, i), (const char *) " "), r), endl) >>>>>;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (totalcount = totalcount + r) >>>>>;
                      if (maxcount < r)
                        {
                          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (maxcount = r) >>>>>;
                        }
                    }
                    <<cleanup_point (void) i++ >>;
                  }
                <D.82555>:;
              }
              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::basic_ostream<char>::operator<< ((struct __ostream_type *) std::basic_ostream<char>::operator<< ((struct basic_ostream *) std::operator<< <std::char_traits<char> > ((struct basic_ostream &) (struct __ostream_type *) std::basic_ostream<char>::operator<< ((struct basic_ostream *) std::operator<< <std::char_traits<char> > ((struct basic_ostream &) &cout, (const char *) "threads delivered futures "), totalcount), (const char *) " "), maxcount), endl) >>>>>;
            }
          finally
            {
              std::vector<std::thread*>::~vector (&the_tasks);
            }
        }
      finally
        {
          std::vector<std::future<long int> >::~vector (&vf);
        }
    }
  finally
    {
      std::vector<std::packaged_task<long int(int, int)> >::~vector (&vp);
    }
}


;; Function int main(int, char**) (null)
;; enabled by -tree-original


{
  int result_logging;
  atrshmlog_time_t starttime;
  atrshmlog_time_t endtime;
  volatile int hugo = -3;
  int taskcount = 10;
  int waittime = 10;
  long int d;

  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::basic_ostream<char>::operator<< ((struct basic_ostream *) std::operator<< <std::char_traits<char> > ((struct basic_ostream &) &cout, (const char *) "shm log check for c++ code and threads"), endl) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) atrshmlog_attach () >>>>>;
    int result_logging;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (result_logging = atrshmlog_get_logging ()) >>>>>;
  if (result_logging != 0)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::basic_ostream<char>::operator<< ((struct basic_ostream *) std::basic_ostream<char>::operator<< ((struct basic_ostream *) std::operator<< <std::char_traits<char> > ((struct basic_ostream &) &cout, (const char *) "check logging "), result_logging), endl) >>>>>;
    }
    atrshmlog_time_t starttime;
    atrshmlog_time_t endtime;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*(atrshmlog_time_t &) &starttime = ((int) *NON_LVALUE_EXPR <atrshmlog_event_locks> & (int) atrshmlog_logging_process) != 0 ? atrshmlog_get_tsc_x86_64_gnu () : 0) >>>>>;
  {
    int i = 0;

    <<cleanup_point     int i = 0;>>;
    while (1)
      {
        if (i > 63) goto <D.82597>;
        {
          const int event = 888;
          const char eventflag = 73;
          const int userevent = i;

          <<cleanup_point           const int event = 888;>>;
          <<cleanup_point           const char eventflag = 73;>>;
                    const int userevent = i;
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*(atrshmlog_time_t &) &endtime = ((int) *NON_LVALUE_EXPR <atrshmlog_event_locks> & (int) atrshmlog_logging_process) != 0 ? atrshmlog_get_tsc_x86_64_gnu () : 0) >>>>>;
          <<cleanup_point <<< Unknown tree: expr_stmt
  if (((int) *(atrshmlog_event_locks + (sizetype) *(const int &) &event) & (int) atrshmlog_logging_process) != 0)
    {
      (void) atrshmlog_write1 ((int) *(const int &) &event, (atrshmlog_int32_t) *(const char &) &eventflag, (int) *(const int &) &userevent, *(atrshmlog_time_t &) &starttime, *(atrshmlog_time_t &) &endtime, (const void *) (const char *) "hallo world", (atrshmlog_int32_t) ((unsigned int) 12 + 4294967295));
    }
  else
    {
      <<< Unknown tree: void_cst >>>
    } >>>>>;
        }
        <<cleanup_point (void) i++ >>;
      }
    <D.82597>:;
  }
  <<cleanup_point   volatile int hugo = -3;>>;
  {
    int k = 0;

    <<cleanup_point     int k = 0;>>;
    while (1)
      {
        if (k > 999999) goto <D.82599>;
        {
          {
            int j = 0;

            <<cleanup_point             int j = 0;>>;
            while (1)
              {
                if (j > 4999) goto <D.82601>;
                <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (hugo = (int) hugo + 3) >>>>>;
                <<cleanup_point (void) j++ >>;
              }
            <D.82601>:;
          }
        }
        <<cleanup_point (void) k++ >>;
      }
    <D.82599>:;
  }
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::basic_ostream<char>::operator<< ((struct basic_ostream *) std::operator<< <std::char_traits<char> > ((struct basic_ostream &) &cout, (const char *) "start of threads."), endl) >>>>>;
  <<cleanup_point   int taskcount = 10;>>;
  <<cleanup_point   int waittime = 10;>>;
  {
    if (argc > 1)
      {
        {
          long int new_taskcount;

                    long int new_taskcount;
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (new_taskcount = strtol ((const char *) *(argv + 8), 0B, 10)) >>>>>;
          if ((unsigned long) new_taskcount + 18446744073709551615 <= 299998)
            {
              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (taskcount = (int) new_taskcount) >>>>>;
            }
        }
      }
  }
  {
    if (argc > 2)
      {
        {
          long int new_time;

                    long int new_time;
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (new_time = strtol ((const char *) *(argv + 16), 0B, 10)) >>>>>;
          if ((unsigned long) new_time + 18446744073709551615 <= 1999999998)
            {
              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (waittime = (int) new_time) >>>>>;
            }
        }
      }
  }
  {
    if (argc > 3)
      {
        {
          long int loopcount;

                    long int loopcount;
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (loopcount = strtol ((const char *) *(argv + 24), 0B, 10)) >>>>>;
          if ((unsigned long) loopcount + 18446744073709551607 <= 1999999990)
            {
              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (mainloopcount = loopcount) >>>>>;
            }
        }
      }
  }
  <<cleanup_point <<< Unknown tree: expr_stmt
  dispatcher (taskcount, waittime) >>>>>;
    long int d;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (d = f (waittime * taskcount, 999)) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  atrshmlog_stop () >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::basic_ostream<char>::operator<< ((struct __ostream_type *) std::basic_ostream<char>::operator<< ((struct basic_ostream *) std::operator<< <std::char_traits<char> > ((struct basic_ostream &) &cout, (const char *) "main "), d), endl) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::basic_ostream<char>::operator<< ((struct __ostream_type *) std::basic_ostream<char>::operator<< ((struct basic_ostream *) std::operator<< <std::char_traits<char> > ((struct basic_ostream &) (struct __ostream_type *) std::basic_ostream<char>::operator<< (&cout, (double) totalcount / (double) d), (const char *) " "), (double) d / (double) maxcount), endl) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::basic_ostream<char>::operator<< ((struct basic_ostream *) std::operator<< <std::char_traits<char> > ((struct basic_ostream &) &cout, (const char *) "end of test."), endl) >>>>>;
  {
    atrshmlog_int32_t maxindex;
    atrshmlog_int32_t * dynstat;

        atrshmlog_int32_t maxindex;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (maxindex = atrshmlog_get_statistics_max_index ()) >>>>>;
        atrshmlog_int32_t * dynstat;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (dynstat = (atrshmlog_int32_t *) calloc (4, (size_t) (maxindex + 1))) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  atrshmlog_get_statistics (dynstat) >>>>>;
    {
      int i = 0;

      <<cleanup_point       int i = 0;>>;
      while (1)
        {
          if (i > maxindex) goto <D.82603>;
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) printf ((const char *) "atrshmlogstat %i %ld\n", i, (long int) *(dynstat + (sizetype) ((long unsigned int) i * 4))) >>>>>;
          <<cleanup_point (void)  ++i>>;
        }
      <D.82603>:;
    }
  }
  return <retval> = 0;
}
return <retval> = 0;


;; Function const _CharT* std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::c_str() const [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (const char *) std::__cxx11::basic_string<char>::_M_data (this)>>
   >>>;


;; Function _Ret __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = long int; _Ret = int; _CharT = char; _Base = {int}; std::size_t = long unsigned int] (null)
;; enabled by -tree-original


{
  int __ret;
  char * __endptr;
  const long int __tmp;

    int __ret;
    char * __endptr;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__errno_location () = 0) >>>>>;
    const long int __tmp;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__tmp = __convf (__str, &__endptr, __base#0)) >>>>>;
  if ((const char *) __endptr == __str)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_invalid_argument (__name) >>>>>;
    }
  else
    {
      if (*__errno_location () == 34 || (unsigned long) __tmp + 2147483648 > 4294967295)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_out_of_range (__name) >>>>>;
        }
      else
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__ret = (int) __tmp) >>>>>;
        }
    }
  if (__idx != 0B)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__idx = (size_t) ((long int) __endptr - (long int) __str)) >>>>>;
    }
  return <retval> = __ret;
}


;; Function _Ret __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = long int; _Ret = long int; _CharT = char; _Base = {int}; std::size_t = long unsigned int] (null)
;; enabled by -tree-original


{
  long int __ret;
  char * __endptr;
  const long int __tmp;

    long int __ret;
    char * __endptr;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__errno_location () = 0) >>>>>;
    const long int __tmp;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__tmp = __convf (__str, &__endptr, __base#0)) >>>>>;
  if ((const char *) __endptr == __str)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_invalid_argument (__name) >>>>>;
    }
  else
    {
      if (*__errno_location () == 34)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_out_of_range (__name) >>>>>;
        }
      else
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__ret = (long int) __tmp) >>>>>;
        }
    }
  if (__idx != 0B)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__idx = (size_t) ((long int) __endptr - (long int) __str)) >>>>>;
    }
  return <retval> = __ret;
}


;; Function _Ret __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = long unsigned int; _Ret = long unsigned int; _CharT = char; _Base = {int}; std::size_t = long unsigned int] (null)
;; enabled by -tree-original


{
  long unsigned int __ret;
  char * __endptr;
  const long unsigned int __tmp;

    long unsigned int __ret;
    char * __endptr;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__errno_location () = 0) >>>>>;
    const long unsigned int __tmp;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__tmp = __convf (__str, &__endptr, __base#0)) >>>>>;
  if ((const char *) __endptr == __str)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_invalid_argument (__name) >>>>>;
    }
  else
    {
      if (*__errno_location () == 34)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_out_of_range (__name) >>>>>;
        }
      else
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__ret = (long unsigned int) __tmp) >>>>>;
        }
    }
  if (__idx != 0B)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__idx = (size_t) ((long int) __endptr - (long int) __str)) >>>>>;
    }
  return <retval> = __ret;
}


;; Function _Ret __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = long long int; _Ret = long long int; _CharT = char; _Base = {int}; std::size_t = long unsigned int] (null)
;; enabled by -tree-original


{
  long long int __ret;
  char * __endptr;
  const long long int __tmp;

    long long int __ret;
    char * __endptr;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__errno_location () = 0) >>>>>;
    const long long int __tmp;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__tmp = __convf (__str, &__endptr, __base#0)) >>>>>;
  if ((const char *) __endptr == __str)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_invalid_argument (__name) >>>>>;
    }
  else
    {
      if (*__errno_location () == 34)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_out_of_range (__name) >>>>>;
        }
      else
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__ret = (long long int) __tmp) >>>>>;
        }
    }
  if (__idx != 0B)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__idx = (size_t) ((long int) __endptr - (long int) __str)) >>>>>;
    }
  return <retval> = __ret;
}


;; Function _Ret __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = long long unsigned int; _Ret = long long unsigned int; _CharT = char; _Base = {int}; std::size_t = long unsigned int] (null)
;; enabled by -tree-original


{
  long long unsigned int __ret;
  char * __endptr;
  const long long unsigned int __tmp;

    long long unsigned int __ret;
    char * __endptr;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__errno_location () = 0) >>>>>;
    const long long unsigned int __tmp;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__tmp = __convf (__str, &__endptr, __base#0)) >>>>>;
  if ((const char *) __endptr == __str)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_invalid_argument (__name) >>>>>;
    }
  else
    {
      if (*__errno_location () == 34)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_out_of_range (__name) >>>>>;
        }
      else
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__ret = (long long unsigned int) __tmp) >>>>>;
        }
    }
  if (__idx != 0B)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__idx = (size_t) ((long int) __endptr - (long int) __str)) >>>>>;
    }
  return <retval> = __ret;
}


;; Function _Ret __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = float; _Ret = float; _CharT = char; _Base = {}; std::size_t = long unsigned int] (null)
;; enabled by -tree-original


{
  float __ret;
  char * __endptr;
  const float __tmp;

    float __ret;
    char * __endptr;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__errno_location () = 0) >>>>>;
    const float __tmp;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__tmp = __convf (__str, &__endptr)) >>>>>;
  if ((const char *) __endptr == __str)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_invalid_argument (__name) >>>>>;
    }
  else
    {
      if (*__errno_location () == 34)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_out_of_range (__name) >>>>>;
        }
      else
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__ret = (float) __tmp) >>>>>;
        }
    }
  if (__idx != 0B)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__idx = (size_t) ((long int) __endptr - (long int) __str)) >>>>>;
    }
  return <retval> = __ret;
}


;; Function _Ret __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = double; _Ret = double; _CharT = char; _Base = {}; std::size_t = long unsigned int] (null)
;; enabled by -tree-original


{
  double __ret;
  char * __endptr;
  const double __tmp;

    double __ret;
    char * __endptr;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__errno_location () = 0) >>>>>;
    const double __tmp;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__tmp = __convf (__str, &__endptr)) >>>>>;
  if ((const char *) __endptr == __str)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_invalid_argument (__name) >>>>>;
    }
  else
    {
      if (*__errno_location () == 34)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_out_of_range (__name) >>>>>;
        }
      else
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__ret = (double) __tmp) >>>>>;
        }
    }
  if (__idx != 0B)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__idx = (size_t) ((long int) __endptr - (long int) __str)) >>>>>;
    }
  return <retval> = __ret;
}


;; Function _Ret __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = long double; _Ret = long double; _CharT = char; _Base = {}; std::size_t = long unsigned int] (null)
;; enabled by -tree-original


{
  long double __ret;
  char * __endptr;
  const long double __tmp;

    long double __ret;
    char * __endptr;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__errno_location () = 0) >>>>>;
    const long double __tmp;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__tmp = __convf (__str, &__endptr)) >>>>>;
  if ((const char *) __endptr == __str)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_invalid_argument (__name) >>>>>;
    }
  else
    {
      if (*__errno_location () == 34)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_out_of_range (__name) >>>>>;
        }
      else
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__ret = (long double) __tmp) >>>>>;
        }
    }
  if (__idx != 0B)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__idx = (size_t) ((long int) __endptr - (long int) __str)) >>>>>;
    }
  return <retval> = __ret;
}


;; Function _String __gnu_cxx::__to_xstring(int (*)(_CharT*, std::size_t, const _CharT*, __va_list_tag*), std::size_t, const _CharT*, ...) [with _String = std::__cxx11::basic_string<char>; _CharT = char; std::size_t = long unsigned int] (null)
;; enabled by -tree-original


{
  char * __s;
  struct  __args[1];
  const int __len;

    char * __s;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__s = (char *) __builtin_alloca (1 * __n)) >>>>>;
    struct  __args[1];
  <<cleanup_point <<< Unknown tree: expr_stmt
  __builtin_va_start ((struct  *) &__args, __fmt) >>>>>;
    const int __len;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__len = __convf (__s, __n, __fmt, (struct  *) &__args)) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  __builtin_va_end ((struct  *) &__args) >>>>>;
  <<cleanup_point return *<retval> = TARGET_EXPR <D.82869, <<< Unknown tree: aggr_init_expr
  7
  __comp_ctor 
  D.82869
  (struct basic_string *) <<< Unknown tree: void_cst >>>
  __s
  __s + (sizetype) __len
  (const struct allocator &) (const struct allocator *) &TARGET_EXPR <D.82868, <<< Unknown tree: aggr_init_expr
  4
  __comp_ctor 
  D.82868
  (struct allocator *) <<< Unknown tree: void_cst >>> >>>> >>>>>>;
}


;; Function std::__cxx11::basic_string<char>::_Alloc_hider::~_Alloc_hider() (null)
;; enabled by -tree-original


{
  try
    {
      try
        {
          
        }
      finally
        {
          std::allocator<char>::~allocator ((struct allocator *) this);
        }
    }
  finally
    {
      *(struct 
      {
        char * _M_p;
      } &) this = {CLOBBER};
    }
}
<D.82873>:;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::~basic_string() [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    try
      {
        try
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_M_dispose (this) >>>>>;
          }
        finally
          {
            std::__cxx11::basic_string<char>::_Alloc_hider::~_Alloc_hider (&((struct basic_string *) this)->_M_dataplus);
          }
      }
    finally
      {
        *(struct 
        {
          struct _Alloc_hider _M_dataplus;
          size_type _M_string_length;
          union ._68 D.18328;
        } &) this = {CLOBBER};
      }
  }
  <D.82871>:;
   >>>;


;; Function constexpr typename std::remove_reference< <template-parameter-1-1> >::type&& std::move(_Tp&&) [with _Tp = std::allocator<char>&; typename std::remove_reference< <template-parameter-1-1> >::type = std::allocator<char>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct type &) (struct type *) NON_LVALUE_EXPR <(struct type &) __t>
   >>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_Alloc_hider::_Alloc_hider (&((struct basic_string *) this)->_M_dataplus, std::__cxx11::basic_string<char>::_M_local_data (this), (const struct allocator &) (const struct allocator *) std::move<std::allocator<char>&> ((struct allocator &) (struct allocator_type *) std::__cxx11::basic_string<char>::_M_get_allocator ((struct basic_string *) __str))) >>>>>;
    try
      {
        if (<<cleanup_point std::__cxx11::basic_string<char>::_M_is_local ((struct basic_string *) __str)>>)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::char_traits<char>::copy ((char *) &((struct basic_string *) this)->D.17414._M_local_buf, (const char_type *) &__str->D.17414._M_local_buf, 16) >>>>>;
          }
        else
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_M_data (this, std::__cxx11::basic_string<char>::_M_data ((struct basic_string *) __str)) >>>>>;
            <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_M_capacity (this, __str->D.17414._M_allocated_capacity) >>>>>;
          }
        <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_M_length (this, std::__cxx11::basic_string<char>::length ((struct basic_string *) __str)) >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_M_data ((struct basic_string *) __str, std::__cxx11::basic_string<char>::_M_local_data ((struct basic_string *) __str)) >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_M_set_length ((struct basic_string *) __str, 0) >>>>>;
      }
    catch
      {
        std::__cxx11::basic_string<char>::_Alloc_hider::~_Alloc_hider (&((struct basic_string *) this)->_M_dataplus);
      }
  }
   >>>;


;; Function const _CharT* std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::c_str() const [with _CharT = wchar_t; _Traits = std::char_traits<wchar_t>; _Alloc = std::allocator<wchar_t>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (const wchar_t *) std::__cxx11::basic_string<wchar_t>::_M_data (this)>>
   >>>;


;; Function _Ret __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = long int; _Ret = int; _CharT = wchar_t; _Base = {int}; std::size_t = long unsigned int] (null)
;; enabled by -tree-original


{
  int __ret;
  wchar_t * __endptr;
  const long int __tmp;

    int __ret;
    wchar_t * __endptr;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__errno_location () = 0) >>>>>;
    const long int __tmp;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__tmp = __convf (__str, &__endptr, __base#0)) >>>>>;
  if ((const wchar_t *) __endptr == __str)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_invalid_argument (__name) >>>>>;
    }
  else
    {
      if (*__errno_location () == 34 || (unsigned long) __tmp + 2147483648 > 4294967295)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_out_of_range (__name) >>>>>;
        }
      else
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__ret = (int) __tmp) >>>>>;
        }
    }
  if (__idx != 0B)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__idx = (size_t) (((long int) __endptr - (long int) __str) /[ex] 4)) >>>>>;
    }
  return <retval> = __ret;
}


;; Function _Ret __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = long int; _Ret = long int; _CharT = wchar_t; _Base = {int}; std::size_t = long unsigned int] (null)
;; enabled by -tree-original


{
  long int __ret;
  wchar_t * __endptr;
  const long int __tmp;

    long int __ret;
    wchar_t * __endptr;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__errno_location () = 0) >>>>>;
    const long int __tmp;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__tmp = __convf (__str, &__endptr, __base#0)) >>>>>;
  if ((const wchar_t *) __endptr == __str)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_invalid_argument (__name) >>>>>;
    }
  else
    {
      if (*__errno_location () == 34)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_out_of_range (__name) >>>>>;
        }
      else
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__ret = (long int) __tmp) >>>>>;
        }
    }
  if (__idx != 0B)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__idx = (size_t) (((long int) __endptr - (long int) __str) /[ex] 4)) >>>>>;
    }
  return <retval> = __ret;
}


;; Function _Ret __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = long unsigned int; _Ret = long unsigned int; _CharT = wchar_t; _Base = {int}; std::size_t = long unsigned int] (null)
;; enabled by -tree-original


{
  long unsigned int __ret;
  wchar_t * __endptr;
  const long unsigned int __tmp;

    long unsigned int __ret;
    wchar_t * __endptr;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__errno_location () = 0) >>>>>;
    const long unsigned int __tmp;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__tmp = __convf (__str, &__endptr, __base#0)) >>>>>;
  if ((const wchar_t *) __endptr == __str)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_invalid_argument (__name) >>>>>;
    }
  else
    {
      if (*__errno_location () == 34)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_out_of_range (__name) >>>>>;
        }
      else
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__ret = (long unsigned int) __tmp) >>>>>;
        }
    }
  if (__idx != 0B)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__idx = (size_t) (((long int) __endptr - (long int) __str) /[ex] 4)) >>>>>;
    }
  return <retval> = __ret;
}


;; Function _Ret __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = long long int; _Ret = long long int; _CharT = wchar_t; _Base = {int}; std::size_t = long unsigned int] (null)
;; enabled by -tree-original


{
  long long int __ret;
  wchar_t * __endptr;
  const long long int __tmp;

    long long int __ret;
    wchar_t * __endptr;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__errno_location () = 0) >>>>>;
    const long long int __tmp;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__tmp = __convf (__str, &__endptr, __base#0)) >>>>>;
  if ((const wchar_t *) __endptr == __str)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_invalid_argument (__name) >>>>>;
    }
  else
    {
      if (*__errno_location () == 34)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_out_of_range (__name) >>>>>;
        }
      else
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__ret = (long long int) __tmp) >>>>>;
        }
    }
  if (__idx != 0B)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__idx = (size_t) (((long int) __endptr - (long int) __str) /[ex] 4)) >>>>>;
    }
  return <retval> = __ret;
}


;; Function _Ret __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = long long unsigned int; _Ret = long long unsigned int; _CharT = wchar_t; _Base = {int}; std::size_t = long unsigned int] (null)
;; enabled by -tree-original


{
  long long unsigned int __ret;
  wchar_t * __endptr;
  const long long unsigned int __tmp;

    long long unsigned int __ret;
    wchar_t * __endptr;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__errno_location () = 0) >>>>>;
    const long long unsigned int __tmp;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__tmp = __convf (__str, &__endptr, __base#0)) >>>>>;
  if ((const wchar_t *) __endptr == __str)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_invalid_argument (__name) >>>>>;
    }
  else
    {
      if (*__errno_location () == 34)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_out_of_range (__name) >>>>>;
        }
      else
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__ret = (long long unsigned int) __tmp) >>>>>;
        }
    }
  if (__idx != 0B)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__idx = (size_t) (((long int) __endptr - (long int) __str) /[ex] 4)) >>>>>;
    }
  return <retval> = __ret;
}


;; Function _Ret __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = float; _Ret = float; _CharT = wchar_t; _Base = {}; std::size_t = long unsigned int] (null)
;; enabled by -tree-original


{
  float __ret;
  wchar_t * __endptr;
  const float __tmp;

    float __ret;
    wchar_t * __endptr;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__errno_location () = 0) >>>>>;
    const float __tmp;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__tmp = __convf (__str, &__endptr)) >>>>>;
  if ((const wchar_t *) __endptr == __str)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_invalid_argument (__name) >>>>>;
    }
  else
    {
      if (*__errno_location () == 34)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_out_of_range (__name) >>>>>;
        }
      else
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__ret = (float) __tmp) >>>>>;
        }
    }
  if (__idx != 0B)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__idx = (size_t) (((long int) __endptr - (long int) __str) /[ex] 4)) >>>>>;
    }
  return <retval> = __ret;
}


;; Function _Ret __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = double; _Ret = double; _CharT = wchar_t; _Base = {}; std::size_t = long unsigned int] (null)
;; enabled by -tree-original


{
  double __ret;
  wchar_t * __endptr;
  const double __tmp;

    double __ret;
    wchar_t * __endptr;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__errno_location () = 0) >>>>>;
    const double __tmp;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__tmp = __convf (__str, &__endptr)) >>>>>;
  if ((const wchar_t *) __endptr == __str)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_invalid_argument (__name) >>>>>;
    }
  else
    {
      if (*__errno_location () == 34)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_out_of_range (__name) >>>>>;
        }
      else
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__ret = (double) __tmp) >>>>>;
        }
    }
  if (__idx != 0B)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__idx = (size_t) (((long int) __endptr - (long int) __str) /[ex] 4)) >>>>>;
    }
  return <retval> = __ret;
}


;; Function _Ret __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = long double; _Ret = long double; _CharT = wchar_t; _Base = {}; std::size_t = long unsigned int] (null)
;; enabled by -tree-original


{
  long double __ret;
  wchar_t * __endptr;
  const long double __tmp;

    long double __ret;
    wchar_t * __endptr;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__errno_location () = 0) >>>>>;
    const long double __tmp;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__tmp = __convf (__str, &__endptr)) >>>>>;
  if ((const wchar_t *) __endptr == __str)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_invalid_argument (__name) >>>>>;
    }
  else
    {
      if (*__errno_location () == 34)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_out_of_range (__name) >>>>>;
        }
      else
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__ret = (long double) __tmp) >>>>>;
        }
    }
  if (__idx != 0B)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__idx = (size_t) (((long int) __endptr - (long int) __str) /[ex] 4)) >>>>>;
    }
  return <retval> = __ret;
}


;; Function _String __gnu_cxx::__to_xstring(int (*)(_CharT*, std::size_t, const _CharT*, __va_list_tag*), std::size_t, const _CharT*, ...) [with _String = std::__cxx11::basic_string<wchar_t>; _CharT = wchar_t; std::size_t = long unsigned int] (null)
;; enabled by -tree-original


{
  wchar_t * __s;
  struct  __args[1];
  const int __len;

    wchar_t * __s;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__s = (wchar_t *) __builtin_alloca (4 * __n)) >>>>>;
    struct  __args[1];
  <<cleanup_point <<< Unknown tree: expr_stmt
  __builtin_va_start ((struct  *) &__args, __fmt) >>>>>;
    const int __len;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__len = __convf (__s, __n, __fmt, (struct  *) &__args)) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  __builtin_va_end ((struct  *) &__args) >>>>>;
  <<cleanup_point return *<retval> = TARGET_EXPR <D.82984, <<< Unknown tree: aggr_init_expr
  7
  __comp_ctor 
  D.82984
  (struct basic_string *) <<< Unknown tree: void_cst >>>
  __s
  __s + (sizetype) ((long unsigned int) __len * 4)
  (const struct allocator &) (const struct allocator *) &TARGET_EXPR <D.82983, <<< Unknown tree: aggr_init_expr
  4
  __comp_ctor 
  D.82983
  (struct allocator *) <<< Unknown tree: void_cst >>> >>>> >>>>>>;
}


;; Function std::__cxx11::basic_string<wchar_t>::_Alloc_hider::~_Alloc_hider() (null)
;; enabled by -tree-original


{
  try
    {
      try
        {
          
        }
      finally
        {
          std::allocator<wchar_t>::~allocator ((struct allocator *) this);
        }
    }
  finally
    {
      *(struct 
      {
        wchar_t * _M_p;
      } &) this = {CLOBBER};
    }
}
<D.82988>:;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::~basic_string() [with _CharT = wchar_t; _Traits = std::char_traits<wchar_t>; _Alloc = std::allocator<wchar_t>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    try
      {
        try
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<wchar_t>::_M_dispose (this) >>>>>;
          }
        finally
          {
            std::__cxx11::basic_string<wchar_t>::_Alloc_hider::~_Alloc_hider (&((struct basic_string *) this)->_M_dataplus);
          }
      }
    finally
      {
        *(struct 
        {
          struct _Alloc_hider _M_dataplus;
          size_type _M_string_length;
          union ._68 D.19697;
        } &) this = {CLOBBER};
      }
  }
  <D.82986>:;
   >>>;


;; Function constexpr typename std::remove_reference< <template-parameter-1-1> >::type&& std::move(_Tp&&) [with _Tp = std::allocator<wchar_t>&; typename std::remove_reference< <template-parameter-1-1> >::type = std::allocator<wchar_t>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct type &) (struct type *) NON_LVALUE_EXPR <(struct type &) __t>
   >>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&&) [with _CharT = wchar_t; _Traits = std::char_traits<wchar_t>; _Alloc = std::allocator<wchar_t>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<wchar_t>::_Alloc_hider::_Alloc_hider (&((struct basic_string *) this)->_M_dataplus, std::__cxx11::basic_string<wchar_t>::_M_local_data (this), (const struct allocator &) (const struct allocator *) std::move<std::allocator<wchar_t>&> ((struct allocator &) (struct allocator_type *) std::__cxx11::basic_string<wchar_t>::_M_get_allocator ((struct basic_string *) __str))) >>>>>;
    try
      {
        if (<<cleanup_point std::__cxx11::basic_string<wchar_t>::_M_is_local ((struct basic_string *) __str)>>)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::char_traits<wchar_t>::copy ((wchar_t *) &((struct basic_string *) this)->D.18784._M_local_buf, (const char_type *) &__str->D.18784._M_local_buf, 4) >>>>>;
          }
        else
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<wchar_t>::_M_data (this, std::__cxx11::basic_string<wchar_t>::_M_data ((struct basic_string *) __str)) >>>>>;
            <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<wchar_t>::_M_capacity (this, __str->D.18784._M_allocated_capacity) >>>>>;
          }
        <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<wchar_t>::_M_length (this, std::__cxx11::basic_string<wchar_t>::length ((struct basic_string *) __str)) >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<wchar_t>::_M_data ((struct basic_string *) __str, std::__cxx11::basic_string<wchar_t>::_M_local_data ((struct basic_string *) __str)) >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<wchar_t>::_M_set_length ((struct basic_string *) __str, 0) >>>>>;
      }
    catch
      {
        std::__cxx11::basic_string<wchar_t>::_Alloc_hider::~_Alloc_hider (&((struct basic_string *) this)->_M_dataplus);
      }
  }
   >>>;


;; Function static std::size_t std::_Hash_impl::hash(const _Tp&) [with _Tp = float; std::size_t = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = std::_Hash_impl::hash ((const void *) (const float *) __val, 4, 3339675911)>>;


;; Function static std::size_t std::_Hash_impl::hash(const _Tp&) [with _Tp = double; std::size_t = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = std::_Hash_impl::hash ((const void *) (const double *) __val, 8, 3339675911)>>;


;; Function const _CharT* std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::data() const [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (const char *) std::__cxx11::basic_string<char>::_M_data (this)>>
   >>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::length() const [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (size_type) ((const struct basic_string *) this)->_M_string_length
   >>>;


;; Function const _CharT* std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::data() const [with _CharT = wchar_t; _Traits = std::char_traits<wchar_t>; _Alloc = std::allocator<wchar_t>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (const wchar_t *) std::__cxx11::basic_string<wchar_t>::_M_data (this)>>
   >>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::length() const [with _CharT = wchar_t; _Traits = std::char_traits<wchar_t>; _Alloc = std::allocator<wchar_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (size_type) ((const struct basic_string *) this)->_M_string_length
   >>>;


;; Function const _CharT* std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::data() const [with _CharT = char16_t; _Traits = std::char_traits<char16_t>; _Alloc = std::allocator<char16_t>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (const char16_t *) std::__cxx11::basic_string<char16_t>::_M_data (this)>>
   >>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::length() const [with _CharT = char16_t; _Traits = std::char_traits<char16_t>; _Alloc = std::allocator<char16_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (size_type) ((const struct basic_string *) this)->_M_string_length
   >>>;


;; Function const _CharT* std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::data() const [with _CharT = char32_t; _Traits = std::char_traits<char32_t>; _Alloc = std::allocator<char32_t>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (const char32_t *) std::__cxx11::basic_string<char32_t>::_M_data (this)>>
   >>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::length() const [with _CharT = char32_t; _Traits = std::char_traits<char32_t>; _Alloc = std::allocator<char32_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (size_type) ((const struct basic_string *) this)->_M_string_length
   >>>;


;; Function std::allocator< <template-parameter-1-1> >::allocator() [with _Tp = char] (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<char>::new_allocator ((struct new_allocator *) this) >>>>>;
    try
      {
        
      }
    catch
      {
        __gnu_cxx::new_allocator<char>::~new_allocator ((struct new_allocator *) this);
      }
  }
   >>>;


;; Function std::allocator< <template-parameter-1-1> >::~allocator() [with _Tp = char] (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  {
    try
      {
        
      }
    finally
      {
        __gnu_cxx::new_allocator<char>::~new_allocator ((struct new_allocator *) this);
      }
  }
  <D.83050>:;
   >>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const _CharT*, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_Alloc_hider::_Alloc_hider (&((struct basic_string *) this)->_M_dataplus, std::__cxx11::basic_string<char>::_M_local_data (this), (const struct allocator &) (const struct allocator *) __a) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_M_construct<const char*> (this, __s, __s + (sizetype) NON_LVALUE_EXPR <__n>) >>>>>;
    }
  catch
    {
      std::__cxx11::basic_string<char>::_Alloc_hider::~_Alloc_hider (&((struct basic_string *) this)->_M_dataplus);
    }
}


;; Function std::allocator< <template-parameter-1-1> >::allocator() [with _Tp = wchar_t] (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<wchar_t>::new_allocator ((struct new_allocator *) this) >>>>>;
    try
      {
        
      }
    catch
      {
        __gnu_cxx::new_allocator<wchar_t>::~new_allocator ((struct new_allocator *) this);
      }
  }
   >>>;


;; Function std::allocator< <template-parameter-1-1> >::~allocator() [with _Tp = wchar_t] (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  {
    try
      {
        
      }
    finally
      {
        __gnu_cxx::new_allocator<wchar_t>::~new_allocator ((struct new_allocator *) this);
      }
  }
  <D.83067>:;
   >>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const _CharT*, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, const _Alloc&) [with _CharT = wchar_t; _Traits = std::char_traits<wchar_t>; _Alloc = std::allocator<wchar_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<wchar_t>::_Alloc_hider::_Alloc_hider (&((struct basic_string *) this)->_M_dataplus, std::__cxx11::basic_string<wchar_t>::_M_local_data (this), (const struct allocator &) (const struct allocator *) __a) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<wchar_t>::_M_construct<const wchar_t*> (this, __s, __s + (sizetype) (__n * 4)) >>>>>;
    }
  catch
    {
      std::__cxx11::basic_string<wchar_t>::_Alloc_hider::~_Alloc_hider (&((struct basic_string *) this)->_M_dataplus);
    }
}


;; Function std::allocator< <template-parameter-1-1> >::allocator() [with _Tp = char16_t] (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<char16_t>::new_allocator ((struct new_allocator *) this) >>>>>;
    try
      {
        
      }
    catch
      {
        __gnu_cxx::new_allocator<char16_t>::~new_allocator ((struct new_allocator *) this);
      }
  }
   >>>;


;; Function std::allocator< <template-parameter-1-1> >::~allocator() [with _Tp = char16_t] (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  {
    try
      {
        
      }
    finally
      {
        __gnu_cxx::new_allocator<char16_t>::~new_allocator ((struct new_allocator *) this);
      }
  }
  <D.83084>:;
   >>>;


;; Function std::__cxx11::basic_string<char16_t>::_Alloc_hider::~_Alloc_hider() (null)
;; enabled by -tree-original


{
  try
    {
      try
        {
          
        }
      finally
        {
          std::allocator<char16_t>::~allocator ((struct allocator *) this);
        }
    }
  finally
    {
      *(struct 
      {
        char16_t * _M_p;
      } &) this = {CLOBBER};
    }
}
<D.83119>:;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const _CharT*, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, const _Alloc&) [with _CharT = char16_t; _Traits = std::char_traits<char16_t>; _Alloc = std::allocator<char16_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char16_t>::_Alloc_hider::_Alloc_hider (&((struct basic_string *) this)->_M_dataplus, std::__cxx11::basic_string<char16_t>::_M_local_data (this), (const struct allocator &) (const struct allocator *) __a) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char16_t>::_M_construct<const char16_t*> (this, __s, __s + (sizetype) (__n * 2)) >>>>>;
    }
  catch
    {
      std::__cxx11::basic_string<char16_t>::_Alloc_hider::~_Alloc_hider (&((struct basic_string *) this)->_M_dataplus);
    }
}


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::~basic_string() [with _CharT = char16_t; _Traits = std::char_traits<char16_t>; _Alloc = std::allocator<char16_t>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    try
      {
        try
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char16_t>::_M_dispose (this) >>>>>;
          }
        finally
          {
            std::__cxx11::basic_string<char16_t>::_Alloc_hider::~_Alloc_hider (&((struct basic_string *) this)->_M_dataplus);
          }
      }
    finally
      {
        *(struct 
        {
          struct _Alloc_hider _M_dataplus;
          size_type _M_string_length;
          union ._68 D.21467;
        } &) this = {CLOBBER};
      }
  }
  <D.83132>:;
   >>>;


;; Function constexpr typename std::remove_reference< <template-parameter-1-1> >::type&& std::move(_Tp&&) [with _Tp = std::allocator<char16_t>&; typename std::remove_reference< <template-parameter-1-1> >::type = std::allocator<char16_t>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct type &) (struct type *) NON_LVALUE_EXPR <(struct type &) __t>
   >>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&&) [with _CharT = char16_t; _Traits = std::char_traits<char16_t>; _Alloc = std::allocator<char16_t>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char16_t>::_Alloc_hider::_Alloc_hider (&((struct basic_string *) this)->_M_dataplus, std::__cxx11::basic_string<char16_t>::_M_local_data (this), (const struct allocator &) (const struct allocator *) std::move<std::allocator<char16_t>&> ((struct allocator &) (struct allocator_type *) std::__cxx11::basic_string<char16_t>::_M_get_allocator ((struct basic_string *) __str))) >>>>>;
    try
      {
        if (<<cleanup_point std::__cxx11::basic_string<char16_t>::_M_is_local ((struct basic_string *) __str)>>)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::char_traits<char16_t>::copy ((char16_t *) &((struct basic_string *) this)->D.20554._M_local_buf, (const char_type *) &__str->D.20554._M_local_buf, 8) >>>>>;
          }
        else
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char16_t>::_M_data (this, std::__cxx11::basic_string<char16_t>::_M_data ((struct basic_string *) __str)) >>>>>;
            <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char16_t>::_M_capacity (this, __str->D.20554._M_allocated_capacity) >>>>>;
          }
        <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char16_t>::_M_length (this, std::__cxx11::basic_string<char16_t>::length ((struct basic_string *) __str)) >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char16_t>::_M_data ((struct basic_string *) __str, std::__cxx11::basic_string<char16_t>::_M_local_data ((struct basic_string *) __str)) >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char16_t>::_M_set_length ((struct basic_string *) __str, 0) >>>>>;
      }
    catch
      {
        std::__cxx11::basic_string<char16_t>::_Alloc_hider::~_Alloc_hider (&((struct basic_string *) this)->_M_dataplus);
      }
  }
   >>>;


;; Function std::allocator< <template-parameter-1-1> >::allocator() [with _Tp = char32_t] (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<char32_t>::new_allocator ((struct new_allocator *) this) >>>>>;
    try
      {
        
      }
    catch
      {
        __gnu_cxx::new_allocator<char32_t>::~new_allocator ((struct new_allocator *) this);
      }
  }
   >>>;


;; Function std::allocator< <template-parameter-1-1> >::~allocator() [with _Tp = char32_t] (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  {
    try
      {
        
      }
    finally
      {
        __gnu_cxx::new_allocator<char32_t>::~new_allocator ((struct new_allocator *) this);
      }
  }
  <D.83152>:;
   >>>;


;; Function std::__cxx11::basic_string<char32_t>::_Alloc_hider::~_Alloc_hider() (null)
;; enabled by -tree-original


{
  try
    {
      try
        {
          
        }
      finally
        {
          std::allocator<char32_t>::~allocator ((struct allocator *) this);
        }
    }
  finally
    {
      *(struct 
      {
        char32_t * _M_p;
      } &) this = {CLOBBER};
    }
}
<D.83187>:;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const _CharT*, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, const _Alloc&) [with _CharT = char32_t; _Traits = std::char_traits<char32_t>; _Alloc = std::allocator<char32_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char32_t>::_Alloc_hider::_Alloc_hider (&((struct basic_string *) this)->_M_dataplus, std::__cxx11::basic_string<char32_t>::_M_local_data (this), (const struct allocator &) (const struct allocator *) __a) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char32_t>::_M_construct<const char32_t*> (this, __s, __s + (sizetype) (__n * 4)) >>>>>;
    }
  catch
    {
      std::__cxx11::basic_string<char32_t>::_Alloc_hider::~_Alloc_hider (&((struct basic_string *) this)->_M_dataplus);
    }
}


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::~basic_string() [with _CharT = char32_t; _Traits = std::char_traits<char32_t>; _Alloc = std::allocator<char32_t>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    try
      {
        try
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char32_t>::_M_dispose (this) >>>>>;
          }
        finally
          {
            std::__cxx11::basic_string<char32_t>::_Alloc_hider::~_Alloc_hider (&((struct basic_string *) this)->_M_dataplus);
          }
      }
    finally
      {
        *(struct 
        {
          struct _Alloc_hider _M_dataplus;
          size_type _M_string_length;
          union ._68 D.22753;
        } &) this = {CLOBBER};
      }
  }
  <D.83200>:;
   >>>;


;; Function constexpr typename std::remove_reference< <template-parameter-1-1> >::type&& std::move(_Tp&&) [with _Tp = std::allocator<char32_t>&; typename std::remove_reference< <template-parameter-1-1> >::type = std::allocator<char32_t>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct type &) (struct type *) NON_LVALUE_EXPR <(struct type &) __t>
   >>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&&) [with _CharT = char32_t; _Traits = std::char_traits<char32_t>; _Alloc = std::allocator<char32_t>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char32_t>::_Alloc_hider::_Alloc_hider (&((struct basic_string *) this)->_M_dataplus, std::__cxx11::basic_string<char32_t>::_M_local_data (this), (const struct allocator &) (const struct allocator *) std::move<std::allocator<char32_t>&> ((struct allocator &) (struct allocator_type *) std::__cxx11::basic_string<char32_t>::_M_get_allocator ((struct basic_string *) __str))) >>>>>;
    try
      {
        if (<<cleanup_point std::__cxx11::basic_string<char32_t>::_M_is_local ((struct basic_string *) __str)>>)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::char_traits<char32_t>::copy ((char32_t *) &((struct basic_string *) this)->D.21840._M_local_buf, (const char_type *) &__str->D.21840._M_local_buf, 4) >>>>>;
          }
        else
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char32_t>::_M_data (this, std::__cxx11::basic_string<char32_t>::_M_data ((struct basic_string *) __str)) >>>>>;
            <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char32_t>::_M_capacity (this, __str->D.21840._M_allocated_capacity) >>>>>;
          }
        <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char32_t>::_M_length (this, std::__cxx11::basic_string<char32_t>::length ((struct basic_string *) __str)) >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char32_t>::_M_data ((struct basic_string *) __str, std::__cxx11::basic_string<char32_t>::_M_local_data ((struct basic_string *) __str)) >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char32_t>::_M_set_length ((struct basic_string *) __str, 0) >>>>>;
      }
    catch
      {
        std::__cxx11::basic_string<char32_t>::_Alloc_hider::~_Alloc_hider (&((struct basic_string *) this)->_M_dataplus);
      }
  }
   >>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc> std::operator+(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, const _CharT*) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>] (null)
;; enabled by -tree-original


{
  struct basic_string __str [value-expr: *<retval>];

  (void) 0;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::basic_string ((struct basic_string *) <retval>, (const struct basic_string &) (const struct basic_string *) __lhs) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::__cxx11::basic_string<char>::append ((struct basic_string *) <retval>, __rhs) >>>>>;
      <<cleanup_point return <retval>>>;
    }
  catch
    {
      std::__cxx11::basic_string<char>::~basic_string ((struct basic_string *) <retval>);
    }
}


;; Function constexpr typename std::remove_reference< <template-parameter-1-1> >::type&& std::move(_Tp&&) [with _Tp = std::__cxx11::basic_string<char>&; typename std::remove_reference< <template-parameter-1-1> >::type = std::__cxx11::basic_string<char>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct type &) (struct type *) NON_LVALUE_EXPR <(struct type &) __t>
   >>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc> std::operator+(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&&, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>] (null)
;; enabled by -tree-original


{
  const long unsigned int __size;
  const bool __cond;

    const long unsigned int __size;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__size = std::__cxx11::basic_string<char>::size ((struct basic_string *) __lhs) + std::__cxx11::basic_string<char>::size ((struct basic_string *) __rhs)) >>>>>;
    const bool __cond;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__cond = std::__cxx11::basic_string<char>::capacity ((struct basic_string *) __lhs) < (long unsigned int) __size && std::__cxx11::basic_string<char>::capacity ((struct basic_string *) __rhs) >= (long unsigned int) __size) >>>>>;
  <<cleanup_point return *<retval> = TARGET_EXPR <D.83440, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.83440
  (struct basic_string *) <<< Unknown tree: void_cst >>>
  (struct basic_string &) ((bool) __cond ? (struct type *) std::move<std::__cxx11::basic_string<char>&> ((struct basic_string &) (struct basic_string *) std::__cxx11::basic_string<char>::insert ((struct basic_string *) __rhs, 0, (const struct basic_string &) (const struct basic_string *) __lhs)) : (struct type *) std::move<std::__cxx11::basic_string<char>&> ((struct basic_string &) (struct basic_string *) std::__cxx11::basic_string<char>::append ((struct basic_string *) __lhs, (const struct basic_string &) (const struct basic_string *) __rhs))) >>>>>>;
}


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc> std::operator+(const _CharT*, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>] (null)
;; enabled by -tree-original


<<cleanup_point return *<retval> = TARGET_EXPR <D.83442, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.83442
  (struct basic_string *) <<< Unknown tree: void_cst >>>
  (struct basic_string &) (struct type *) std::move<std::__cxx11::basic_string<char>&> ((struct basic_string &) (struct basic_string *) std::__cxx11::basic_string<char>::insert ((struct basic_string *) __rhs, 0, __lhs)) >>>>>>;


;; Function static std::size_t std::_Hash_impl::hash(const _Tp&) [with _Tp = int; std::size_t = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = std::_Hash_impl::hash ((const void *) (const int *) __val, 4, 3339675911)>>;


;; Function static std::size_t std::_Hash_impl::__hash_combine(const _Tp&, std::size_t) [with _Tp = const std::_V2::error_category*; std::size_t = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = std::_Hash_impl::hash ((const void *) (const struct error_category * const *) __val, 8, __hash)>>;


;; Function long int std::_Sp_counted_base<_Lp>::_M_get_use_count() const [with __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (long int) (int) __atomic_load_4 ((const void *) &((const struct _Sp_counted_base *) this)->_M_use_count, 0)>>
   >>>;


;; Function void std::_Sp_counted_base<_Lp>::_M_destroy() [with __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)0u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  if ((struct _Sp_counted_base *) this != 0B)
    {
      OBJ_TYPE_REF(*(((struct _Sp_counted_base *) this)->_vptr._Sp_counted_base + 8);(struct _Sp_counted_base)this->1) (this);
    }
  else
    {
      <<< Unknown tree: void_cst >>>
    } >>>>>
   >>>;


;; Function constexpr typename std::remove_reference< <template-parameter-1-1> >::type&& std::move(_Tp&&) [with _Tp = std::thread::id&; typename std::remove_reference< <template-parameter-1-1> >::type = std::thread::id] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct type &) (struct type *) NON_LVALUE_EXPR <(struct type &) __t>
   >>>;


;; Function void std::swap(_Tp&, _Tp&) [with _Tp = std::thread::id] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    struct id __tmp;

        struct id __tmp;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__tmp = *(struct id &) (struct type *) std::move<std::thread::id&> ((struct id &) (struct id *) __a)) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*(struct id *) __a = *(struct id &) (struct type *) std::move<std::thread::id&> ((struct id &) (struct id *) __b)) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*(struct id *) __b = *(struct id &) (struct type *) std::move<std::thread::id&> ((struct id &) &__tmp)) >>>>>;
  }
   >>>;


;; Function std::__shared_count<_Lp>::~__shared_count() [with __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    try
      {
        if (((struct __shared_count *) this)->_M_pi != 0B)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2u>::_M_release (NON_LVALUE_EXPR <((struct __shared_count *) this)->_M_pi>) >>>>>;
          }
      }
    finally
      {
        *(struct 
        {
          struct _Sp_counted_base * _M_pi;
        } &) this = {CLOBBER};
      }
  }
  <D.83458>:;
   >>>;


;; Function static std::size_t std::_Hash_impl::hash(const _Tp&) [with _Tp = long unsigned int; std::size_t = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = std::_Hash_impl::hash ((const void *) (const long unsigned int *) __val, 8, 3339675911)>>;


;; Function std::__atomic_base<_IntTp>::__int_type std::__atomic_base<_IntTp>::operator=(std::__atomic_base<_IntTp>::__int_type) [with _ITp = bool; std::__atomic_base<_IntTp>::__int_type = bool] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__atomic_base<bool>::store (this, (int) __i, 5) >>>>>;
  return <retval> = __i;
   >>>;


;; Function std::__atomic_base<_IntTp>::__int_type std::__atomic_base<_IntTp>::operator=(std::__atomic_base<_IntTp>::__int_type) volatile [with _ITp = bool; std::__atomic_base<_IntTp>::__int_type = bool] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__atomic_base<bool>::store (this, (int) __i, 5) >>>>>;
  return <retval> = __i;
   >>>;


;; Function std::__atomic_base<_IntTp>::__int_type std::__atomic_base<_IntTp>::load(std::memory_order) const [with _ITp = bool; std::__atomic_base<_IntTp>::__int_type = bool; std::memory_order = std::memory_order] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    memory_order __b;

        memory_order __b;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__b = std::operator& (__m, 65535)) >>>>>;
    <<cleanup_point return <retval> = __atomic_load_1 ((const void *) &((const struct __atomic_base *) this)->_M_i, (int) __m) != 0>>;
  }
   >>>;


;; Function std::__atomic_base<_IntTp>::__int_type std::__atomic_base<_IntTp>::load(std::memory_order) const volatile [with _ITp = bool; std::__atomic_base<_IntTp>::__int_type = bool; std::memory_order = std::memory_order] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    memory_order __b;

        memory_order __b;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__b = std::operator& (__m, 65535)) >>>>>;
    <<cleanup_point return <retval> = __atomic_load_1 ((const void *) &((const volatile struct __atomic_base *) this)->_M_i, (int) __m) != 0>>;
  }
   >>>;


;; Function bool std::__atomic_base<_IntTp>::is_lock_free() const [with _ITp = bool] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = __atomic_is_lock_free (1, -1B)
   >>>;


;; Function bool std::__atomic_base<_IntTp>::is_lock_free() const volatile [with _ITp = bool] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = __atomic_is_lock_free (1, -1B)
   >>>;


;; Function void std::__atomic_base<_IntTp>::store(std::__atomic_base<_IntTp>::__int_type, std::memory_order) [with _ITp = bool; std::__atomic_base<_IntTp>::__int_type = bool; std::memory_order = std::memory_order] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    memory_order __b;

        memory_order __b;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__b = std::operator& (__m, 65535)) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  __atomic_store_1 ((volatile void *) &((struct __atomic_base *) this)->_M_i, (int) __i, (int) __m) >>>>>;
  }
   >>>;


;; Function void std::__atomic_base<_IntTp>::store(std::__atomic_base<_IntTp>::__int_type, std::memory_order) volatile [with _ITp = bool; std::__atomic_base<_IntTp>::__int_type = bool; std::memory_order = std::memory_order] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    memory_order __b;

        memory_order __b;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__b = std::operator& (__m, 65535)) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  __atomic_store_1 ((volatile void *) &((volatile struct __atomic_base *) this)->_M_i, (int) __i, (int) __m) >>>>>;
  }
   >>>;


;; Function std::__atomic_base<_IntTp>::__int_type std::__atomic_base<_IntTp>::exchange(std::__atomic_base<_IntTp>::__int_type, std::memory_order) [with _ITp = bool; std::__atomic_base<_IntTp>::__int_type = bool; std::memory_order = std::memory_order] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = __atomic_exchange_1 ((volatile void *) &((struct __atomic_base *) this)->_M_i, (int) __i, (int) __m) != 0>>
   >>>;


;; Function std::__atomic_base<_IntTp>::__int_type std::__atomic_base<_IntTp>::exchange(std::__atomic_base<_IntTp>::__int_type, std::memory_order) volatile [with _ITp = bool; std::__atomic_base<_IntTp>::__int_type = bool; std::memory_order = std::memory_order] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = __atomic_exchange_1 ((volatile void *) &((volatile struct __atomic_base *) this)->_M_i, (int) __i, (int) __m) != 0>>
   >>>;


;; Function bool std::__atomic_base<_IntTp>::compare_exchange_weak(std::__atomic_base<_IntTp>::__int_type&, std::__atomic_base<_IntTp>::__int_type, std::memory_order, std::memory_order) [with _ITp = bool; std::__atomic_base<_IntTp>::__int_type = bool; std::memory_order = std::memory_order] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    memory_order __b2;
    memory_order __b1;

        memory_order __b2;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__b2 = std::operator& (__m2, 65535)) >>>>>;
        memory_order __b1;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__b1 = std::operator& (__m1, 65535)) >>>>>;
    <<cleanup_point return <retval> = __atomic_compare_exchange_1 ((volatile void *) &((struct __atomic_base *) this)->_M_i, (void *) (__int_type *) __i1, (int) __i2, 1, (int) __m1, (int) __m2)>>;
  }
   >>>;


;; Function bool std::__atomic_base<_IntTp>::compare_exchange_weak(std::__atomic_base<_IntTp>::__int_type&, std::__atomic_base<_IntTp>::__int_type, std::memory_order, std::memory_order) volatile [with _ITp = bool; std::__atomic_base<_IntTp>::__int_type = bool; std::memory_order = std::memory_order] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    memory_order __b2;
    memory_order __b1;

        memory_order __b2;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__b2 = std::operator& (__m2, 65535)) >>>>>;
        memory_order __b1;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__b1 = std::operator& (__m1, 65535)) >>>>>;
    <<cleanup_point return <retval> = __atomic_compare_exchange_1 ((volatile void *) &((volatile struct __atomic_base *) this)->_M_i, (void *) (__int_type *) __i1, (int) __i2, 1, (int) __m1, (int) __m2)>>;
  }
   >>>;


;; Function bool std::__atomic_base<_IntTp>::compare_exchange_weak(std::__atomic_base<_IntTp>::__int_type&, std::__atomic_base<_IntTp>::__int_type, std::memory_order) [with _ITp = bool; std::__atomic_base<_IntTp>::__int_type = bool; std::memory_order = std::memory_order] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::__atomic_base<bool>::compare_exchange_weak (this, (__int_type &) (__int_type *) __i1, (int) __i2, __m, std::__cmpexch_failure_order (__m))>>
   >>>;


;; Function bool std::__atomic_base<_IntTp>::compare_exchange_weak(std::__atomic_base<_IntTp>::__int_type&, std::__atomic_base<_IntTp>::__int_type, std::memory_order) volatile [with _ITp = bool; std::__atomic_base<_IntTp>::__int_type = bool; std::memory_order = std::memory_order] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::__atomic_base<bool>::compare_exchange_weak (this, (__int_type &) (__int_type *) __i1, (int) __i2, __m, std::__cmpexch_failure_order (__m))>>
   >>>;


;; Function bool std::__atomic_base<_IntTp>::compare_exchange_strong(std::__atomic_base<_IntTp>::__int_type&, std::__atomic_base<_IntTp>::__int_type, std::memory_order, std::memory_order) [with _ITp = bool; std::__atomic_base<_IntTp>::__int_type = bool; std::memory_order = std::memory_order] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    memory_order __b2;
    memory_order __b1;

        memory_order __b2;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__b2 = std::operator& (__m2, 65535)) >>>>>;
        memory_order __b1;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__b1 = std::operator& (__m1, 65535)) >>>>>;
    <<cleanup_point return <retval> = __atomic_compare_exchange_1 ((volatile void *) &((struct __atomic_base *) this)->_M_i, (void *) (__int_type *) __i1, (int) __i2, 0, (int) __m1, (int) __m2)>>;
  }
   >>>;


;; Function bool std::__atomic_base<_IntTp>::compare_exchange_strong(std::__atomic_base<_IntTp>::__int_type&, std::__atomic_base<_IntTp>::__int_type, std::memory_order, std::memory_order) volatile [with _ITp = bool; std::__atomic_base<_IntTp>::__int_type = bool; std::memory_order = std::memory_order] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    memory_order __b2;
    memory_order __b1;

        memory_order __b2;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__b2 = std::operator& (__m2, 65535)) >>>>>;
        memory_order __b1;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__b1 = std::operator& (__m1, 65535)) >>>>>;
    <<cleanup_point return <retval> = __atomic_compare_exchange_1 ((volatile void *) &((volatile struct __atomic_base *) this)->_M_i, (void *) (__int_type *) __i1, (int) __i2, 0, (int) __m1, (int) __m2)>>;
  }
   >>>;


;; Function bool std::__atomic_base<_IntTp>::compare_exchange_strong(std::__atomic_base<_IntTp>::__int_type&, std::__atomic_base<_IntTp>::__int_type, std::memory_order) [with _ITp = bool; std::__atomic_base<_IntTp>::__int_type = bool; std::memory_order = std::memory_order] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::__atomic_base<bool>::compare_exchange_strong (this, (__int_type &) (__int_type *) __i1, (int) __i2, __m, std::__cmpexch_failure_order (__m))>>
   >>>;


;; Function bool std::__atomic_base<_IntTp>::compare_exchange_strong(std::__atomic_base<_IntTp>::__int_type&, std::__atomic_base<_IntTp>::__int_type, std::memory_order) volatile [with _ITp = bool; std::__atomic_base<_IntTp>::__int_type = bool; std::memory_order = std::memory_order] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::__atomic_base<bool>::compare_exchange_strong (this, (__int_type &) (__int_type *) __i1, (int) __i2, __m, std::__cmpexch_failure_order (__m))>>
   >>>;


;; Function std::shared_ptr<_Tp1> std::make_shared(_Args&& ...) [with _Tp = std::mutex; _Args = {}] (null)
;; enabled by -tree-original


{
  typedef struct _Tp_nc _Tp_nc;

  <<cleanup_point return *<retval> = TARGET_EXPR <D.83670, <<< Unknown tree: aggr_init_expr
  4
  allocate_shared
  D.83670
  (const struct allocator &) (const struct allocator *) &TARGET_EXPR <D.83667, <<< Unknown tree: aggr_init_expr
  4
  __comp_ctor 
  D.83667
  (struct allocator *) <<< Unknown tree: void_cst >>> >>>> >>>>>>;
}


;; Function constexpr typename std::remove_reference< <template-parameter-1-1> >::type&& std::move(_Tp&&) [with _Tp = std::shared_ptr<std::mutex>&; typename std::remove_reference< <template-parameter-1-1> >::type = std::shared_ptr<std::mutex>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct type &) (struct type *) NON_LVALUE_EXPR <(struct type &) __t>
   >>>;


;; Function std::shared_ptr<_Tp>::shared_ptr(std::shared_ptr<_Tp>&&) [with _Tp = std::mutex] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__shared_ptr<std::mutex, (__gnu_cxx::_Lock_policy)2u>::__shared_ptr (&((struct shared_ptr *) this)->D.61009, (struct __shared_ptr &) (struct __shared_ptr *) NON_LVALUE_EXPR <(struct __shared_ptr &) &((struct type *) std::move<std::shared_ptr<std::mutex>&> ((struct shared_ptr &) (struct shared_ptr *) __r))->D.61009>) >>>>>;
    try
      {
        
      }
    catch
      {
        std::__shared_ptr<std::mutex, (__gnu_cxx::_Lock_policy)2u>::~__shared_ptr (&((struct shared_ptr *) this)->D.61009);
      }
  }
   >>>;


;; Function typename std::add_lvalue_reference<_Tp>::type std::__shared_ptr<_Tp, _Lp>::operator*() const [with _Tp = std::mutex; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u; typename std::add_lvalue_reference<_Tp>::type = std::mutex&] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct mutex &) (struct mutex *) ((const struct __shared_ptr *) this)->_M_ptr
   >>>;


;; Function std::lock_guard<_Mutex>::lock_guard(std::lock_guard<_Mutex>::mutex_type&) [with _Mutex = std::mutex; std::lock_guard<_Mutex>::mutex_type = std::mutex] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct lock_guard *) this)->_M_device = (struct mutex_type &) (struct mutex_type *) __m) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::mutex::lock ((struct mutex_type *) ((struct lock_guard *) this)->_M_device) >>>>>;
}


;; Function std::lock_guard<_Mutex>::~lock_guard() [with _Mutex = std::mutex] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    try
      {
        <<cleanup_point <<< Unknown tree: expr_stmt
  std::mutex::unlock ((struct mutex_type *) ((struct lock_guard *) this)->_M_device) >>>>>;
      }
    finally
      {
        *(struct 
        {
          struct mutex_type & _M_device;
        } &) this = {CLOBBER};
      }
  }
  <D.83695>:;
   >>>;


;; Function static constexpr _Head& std::_Head_base<_Idx, _Head, false>::_M_head(std::_Head_base<_Idx, _Head, false>&) [with long unsigned int _Idx = 0ul; _Head = std::__future_base::_Result_base*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct _Result_base * &) &__b->_M_head_impl
   >>>;


;; Function static constexpr _Head& std::_Tuple_impl<_Idx, _Head, _Tail ...>::_M_head(std::_Tuple_impl<_Idx, _Head, _Tail ...>&) [with long unsigned int _Idx = 0ul; _Head = std::__future_base::_Result_base*; _Tail = {std::__future_base::_Result_base::_Deleter}] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct _Result_base * &) (struct _Result_base * *) std::_Head_base<0ul, std::__future_base::_Result_base*, false>::_M_head ((struct _Head_base &) &((struct _Tuple_impl *) __t)->D.63461)>>
   >>>;


;; Function constexpr _Head& std::__get_helper(std::_Tuple_impl<_Idx, _Head, _Tail ...>&) [with long unsigned int __i = 0ul; _Head = std::__future_base::_Result_base*; _Tail = {std::__future_base::_Result_base::_Deleter}] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct _Result_base * &) (struct _Result_base * *) std::_Tuple_impl<0ul, std::__future_base::_Result_base*, std::__future_base::_Result_base::_Deleter>::_M_head ((struct _Tuple_impl &) (struct _Tuple_impl *) __t)>>
   >>>;


;; Function constexpr std::__tuple_element_t<__i, std::tuple<_Elements ...> >& std::get(std::tuple<_Elements ...>&) [with long unsigned int __i = 0ul; _Elements = {std::__future_base::_Result_base*, std::__future_base::_Result_base::_Deleter}; std::__tuple_element_t<__i, std::tuple<_Elements ...> > = std::__future_base::_Result_base*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct _Result_base * &) (struct _Result_base * *) std::__get_helper<0ul, std::__future_base::_Result_base*, std::__future_base::_Result_base::_Deleter> ((struct _Tuple_impl &) &((struct tuple *) __t)->D.64132)>>
   >>>;


;; Function std::unique_ptr<_Tp, _Dp>::~unique_ptr() [with _Tp = std::__future_base::_Result_base; _Dp = std::__future_base::_Result_base::_Deleter] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    try
      {
        {
          struct _Result_base * & __ptr;

                    struct _Result_base * & __ptr;
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__ptr = (struct _Result_base * &) (struct _Result_base * *) std::get<0ul, std::__future_base::_Result_base*, std::__future_base::_Result_base::_Deleter> ((struct tuple &) &((struct unique_ptr *) this)->_M_t)) >>>>>;
          if (*__ptr != 0B)
            {
              <<cleanup_point <<< Unknown tree: expr_stmt
  std::__future_base::_Result_base::_Deleter::operator() ((struct deleter_type *) std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>::get_deleter (this), *__ptr) >>>>>;
            }
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__ptr = 0B) >>>>>;
        }
      }
    finally
      {
        *(struct 
        {
          struct __tuple_type _M_t;
        } &) this = {CLOBBER};
      }
  }
  <D.83702>:;
   >>>;


;; Function constexpr std::__atomic_futex_unsigned_base::__atomic_futex_unsigned_base() (null)
;; enabled by -tree-original


{
  
}


;; Function std::__atomic_futex_unsigned<_Waiter_bit>::__atomic_futex_unsigned(unsigned int) [with unsigned int _Waiter_bit = 2147483648u] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__atomic_futex_unsigned_base::__atomic_futex_unsigned_base ((struct __atomic_futex_unsigned_base *) this) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::atomic<unsigned int>::atomic (&((struct __atomic_futex_unsigned *) this)->_M_data, __data) >>>>>;
}


;; Function void std::__atomic_futex_unsigned<_Waiter_bit>::_M_load_when_equal(unsigned int, std::memory_order) [with unsigned int _Waiter_bit = 2147483648u; std::memory_order = std::memory_order] (null)
;; enabled by -tree-original


{
  unsigned int __i;

    unsigned int __i;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__i = std::__atomic_futex_unsigned<>::_M_load (this, __mo)) >>>>>;
  if ((__i & 2147483647) == __val)
    {
      return;
    }
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::__atomic_futex_unsigned<>::_M_load_and_test (this, __i, __val, 1, __mo) >>>>>;
}


;; Function typename std::add_lvalue_reference<_Tp>::type std::unique_ptr<_Tp, _Dp>::operator*() const [with _Tp = std::__future_base::_Result_base; _Dp = std::__future_base::_Result_base::_Deleter; typename std::add_lvalue_reference<_Tp>::type = std::__future_base::_Result_base&] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (struct _Result_base &) std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>::get (this)>>;


;; Function _Tp* std::__addressof(_Tp&) [with _Tp = std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct function *) __r
   >>>;


;; Function _Tp* std::__addressof(_Tp&) [with _Tp = bool] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (bool *) __r
   >>>;


;; Function constexpr _Tp&& std::forward(typename std::remove_reference<_From>::type&) [with _Tp = void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*); typename std::remove_reference<_From>::type = void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct 
  {
    void _State_baseV2::<Tc8fa> (struct _State_baseV2 *, struct function *, bool *) * __pfn;
    long int __delta;
  } &) (struct 
  {
    void _State_baseV2::<Tc8fa> (struct _State_baseV2 *, struct function *, bool *) * __pfn;
    long int __delta;
  } *) (struct 
  {
    void _State_baseV2::<Tc8fa> (struct _State_baseV2 *, struct function *, bool *) * __pfn;
    long int __delta;
  } &) __t
   >>>;


;; Function constexpr _Tp&& std::forward(typename std::remove_reference<_From>::type&) [with _Tp = std::__future_base::_State_baseV2*; typename std::remove_reference<_From>::type = std::__future_base::_State_baseV2*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct _State_baseV2 * &) (struct _State_baseV2 * *) (struct _State_baseV2 * &) __t
   >>>;


;; Function constexpr _Tp&& std::forward(typename std::remove_reference<_From>::type&) [with _Tp = std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*; typename std::remove_reference<_From>::type = std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct function * &) (struct function * *) (struct function * &) __t
   >>>;


;; Function constexpr _Tp&& std::forward(typename std::remove_reference<_From>::type&) [with _Tp = bool*; typename std::remove_reference<_From>::type = bool*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (bool * &) (bool * *) (bool * &) __t
   >>>;


;; Function static constexpr _Head& std::_Head_base<_Idx, _Head, false>::_M_head(std::_Head_base<_Idx, _Head, false>&) [with long unsigned int _Idx = 3ul; _Head = bool*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (bool * &) &__b->_M_head_impl
   >>>;


;; Function static constexpr _Head& std::_Tuple_impl<_Idx, _Head>::_M_head(std::_Tuple_impl<_Idx, _Head>&) [with long unsigned int _Idx = 3ul; _Head = bool*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (bool * &) (bool * *) std::_Head_base<3ul, bool*, false>::_M_head ((struct _Head_base &) &((struct _Tuple_impl *) __t)->D.85250)>>
   >>>;


;; Function constexpr std::_Head_base<_Idx, _Head, false>::_Head_base(_UHead&&) [with _UHead = bool*; long unsigned int _Idx = 3ul; _Head = bool*] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Head_base *) this)->_M_head_impl = *std::forward<bool*> ((bool * &) (bool * *) __h)) >>>>>;
}


;; Function constexpr std::_Tuple_impl<_Idx, _Head>::_Tuple_impl(std::_Tuple_impl<_Idx, _Head>&&) [with long unsigned int _Idx = 3ul; _Head = bool*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Head_base<3ul, bool*, false>::_Head_base<bool*> (&((struct _Tuple_impl *) this)->D.85250, (bool * &) (bool * *) std::forward<bool*> ((bool * &) (bool * *) std::_Tuple_impl<3ul, bool*>::_M_head ((struct _Tuple_impl &) (struct _Tuple_impl *) __in))) >>>>>;
  }
   >>>;


;; Function static constexpr std::_Tuple_impl<_Idx, _Head, _Tail ...>::_Inherited& std::_Tuple_impl<_Idx, _Head, _Tail ...>::_M_tail(std::_Tuple_impl<_Idx, _Head, _Tail ...>&) [with long unsigned int _Idx = 2ul; _Head = std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*; _Tail = {bool*}; std::_Tuple_impl<_Idx, _Head, _Tail ...>::_Inherited = std::_Tuple_impl<3ul, bool*>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct _Inherited &) &((struct _Tuple_impl *) __t)->D.85972
   >>>;


;; Function constexpr typename std::remove_reference< <template-parameter-1-1> >::type&& std::move(_Tp&&) [with _Tp = std::_Tuple_impl<3ul, bool*>&; typename std::remove_reference< <template-parameter-1-1> >::type = std::_Tuple_impl<3ul, bool*>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct type &) (struct type *) NON_LVALUE_EXPR <(struct type &) __t>
   >>>;


;; Function static constexpr _Head& std::_Head_base<_Idx, _Head, false>::_M_head(std::_Head_base<_Idx, _Head, false>&) [with long unsigned int _Idx = 2ul; _Head = std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct function * &) &__b->_M_head_impl
   >>>;


;; Function static constexpr _Head& std::_Tuple_impl<_Idx, _Head, _Tail ...>::_M_head(std::_Tuple_impl<_Idx, _Head, _Tail ...>&) [with long unsigned int _Idx = 2ul; _Head = std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*; _Tail = {bool*}] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct function * &) (struct function * *) std::_Head_base<2ul, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, false>::_M_head ((struct _Head_base &) &((struct _Tuple_impl *) __t)->D.85973)>>
   >>>;


;; Function constexpr std::_Head_base<_Idx, _Head, false>::_Head_base(_UHead&&) [with _UHead = std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*; long unsigned int _Idx = 2ul; _Head = std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Head_base *) this)->_M_head_impl = *std::forward<std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*> ((struct function * &) (struct function * *) __h)) >>>>>;
}


;; Function constexpr std::_Tuple_impl<_Idx, _Head, _Tail ...>::_Tuple_impl(std::_Tuple_impl<_Idx, _Head, _Tail ...>&&) [with long unsigned int _Idx = 2ul; _Head = std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*; _Tail = {bool*}] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Tuple_impl<3ul, bool*>::_Tuple_impl (&((struct _Tuple_impl *) this)->D.85972, (struct _Tuple_impl &) (struct type *) std::move<std::_Tuple_impl<3ul, bool*>&> ((struct _Tuple_impl &) (struct _Inherited *) std::_Tuple_impl<2ul, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*>::_M_tail ((struct _Tuple_impl &) (struct _Tuple_impl *) __in))) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Head_base<2ul, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, false>::_Head_base<std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*> (&((struct _Tuple_impl *) this)->D.85973, (struct function * &) (struct function * *) std::forward<std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*> ((struct function * &) (struct function * *) std::_Tuple_impl<2ul, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*>::_M_head ((struct _Tuple_impl &) (struct _Tuple_impl *) __in))) >>>>>;
  }
   >>>;


;; Function static constexpr std::_Tuple_impl<_Idx, _Head, _Tail ...>::_Inherited& std::_Tuple_impl<_Idx, _Head, _Tail ...>::_M_tail(std::_Tuple_impl<_Idx, _Head, _Tail ...>&) [with long unsigned int _Idx = 1ul; _Head = std::__future_base::_State_baseV2*; _Tail = {std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*}; std::_Tuple_impl<_Idx, _Head, _Tail ...>::_Inherited = std::_Tuple_impl<2ul, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct _Inherited &) &((struct _Tuple_impl *) __t)->D.86699
   >>>;


;; Function constexpr typename std::remove_reference< <template-parameter-1-1> >::type&& std::move(_Tp&&) [with _Tp = std::_Tuple_impl<2ul, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*>&; typename std::remove_reference< <template-parameter-1-1> >::type = std::_Tuple_impl<2ul, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct type &) (struct type *) NON_LVALUE_EXPR <(struct type &) __t>
   >>>;


;; Function static constexpr _Head& std::_Head_base<_Idx, _Head, false>::_M_head(std::_Head_base<_Idx, _Head, false>&) [with long unsigned int _Idx = 1ul; _Head = std::__future_base::_State_baseV2*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct _State_baseV2 * &) &__b->_M_head_impl
   >>>;


;; Function static constexpr _Head& std::_Tuple_impl<_Idx, _Head, _Tail ...>::_M_head(std::_Tuple_impl<_Idx, _Head, _Tail ...>&) [with long unsigned int _Idx = 1ul; _Head = std::__future_base::_State_baseV2*; _Tail = {std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*}] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct _State_baseV2 * &) (struct _State_baseV2 * *) std::_Head_base<1ul, std::__future_base::_State_baseV2*, false>::_M_head ((struct _Head_base &) &((struct _Tuple_impl *) __t)->D.86700)>>
   >>>;


;; Function constexpr std::_Head_base<_Idx, _Head, false>::_Head_base(_UHead&&) [with _UHead = std::__future_base::_State_baseV2*; long unsigned int _Idx = 1ul; _Head = std::__future_base::_State_baseV2*] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Head_base *) this)->_M_head_impl = *std::forward<std::__future_base::_State_baseV2*> ((struct _State_baseV2 * &) (struct _State_baseV2 * *) __h)) >>>>>;
}


;; Function constexpr std::_Tuple_impl<_Idx, _Head, _Tail ...>::_Tuple_impl(std::_Tuple_impl<_Idx, _Head, _Tail ...>&&) [with long unsigned int _Idx = 1ul; _Head = std::__future_base::_State_baseV2*; _Tail = {std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*}] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Tuple_impl<2ul, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*>::_Tuple_impl (&((struct _Tuple_impl *) this)->D.86699, (struct _Tuple_impl &) (struct type *) std::move<std::_Tuple_impl<2ul, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*>&> ((struct _Tuple_impl &) (struct _Inherited *) std::_Tuple_impl<1ul, std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*>::_M_tail ((struct _Tuple_impl &) (struct _Tuple_impl *) __in))) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Head_base<1ul, std::__future_base::_State_baseV2*, false>::_Head_base<std::__future_base::_State_baseV2*> (&((struct _Tuple_impl *) this)->D.86700, (struct _State_baseV2 * &) (struct _State_baseV2 * *) std::forward<std::__future_base::_State_baseV2*> ((struct _State_baseV2 * &) (struct _State_baseV2 * *) std::_Tuple_impl<1ul, std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*>::_M_head ((struct _Tuple_impl &) (struct _Tuple_impl *) __in))) >>>>>;
  }
   >>>;


;; Function static constexpr std::_Tuple_impl<_Idx, _Head, _Tail ...>::_Inherited& std::_Tuple_impl<_Idx, _Head, _Tail ...>::_M_tail(std::_Tuple_impl<_Idx, _Head, _Tail ...>&) [with long unsigned int _Idx = 0ul; _Head = std::_Mem_fn<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)>; _Tail = {std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*}; std::_Tuple_impl<_Idx, _Head, _Tail ...>::_Inherited = std::_Tuple_impl<1ul, std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct _Inherited &) &((struct _Tuple_impl *) __t)->D.87475
   >>>;


;; Function constexpr typename std::remove_reference< <template-parameter-1-1> >::type&& std::move(_Tp&&) [with _Tp = std::_Tuple_impl<1ul, std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*>&; typename std::remove_reference< <template-parameter-1-1> >::type = std::_Tuple_impl<1ul, std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct type &) (struct type *) NON_LVALUE_EXPR <(struct type &) __t>
   >>>;


;; Function static constexpr _Head& std::_Head_base<_Idx, _Head, false>::_M_head(std::_Head_base<_Idx, _Head, false>&) [with long unsigned int _Idx = 0ul; _Head = std::_Mem_fn<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct _Mem_fn &) &__b->_M_head_impl
   >>>;


;; Function static constexpr _Head& std::_Tuple_impl<_Idx, _Head, _Tail ...>::_M_head(std::_Tuple_impl<_Idx, _Head, _Tail ...>&) [with long unsigned int _Idx = 0ul; _Head = std::_Mem_fn<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)>; _Tail = {std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*}] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct _Mem_fn &) (struct _Mem_fn *) std::_Head_base<0ul, std::_Mem_fn<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)>, false>::_M_head ((struct _Head_base &) &((struct _Tuple_impl *) __t)->D.87476)>>
   >>>;


;; Function constexpr _Tp&& std::forward(typename std::remove_reference<_From>::type&) [with _Tp = std::_Mem_fn<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)>; typename std::remove_reference<_From>::type = std::_Mem_fn<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct _Mem_fn &) (struct _Mem_fn *) NON_LVALUE_EXPR <(struct _Mem_fn &) __t>
   >>>;


;; Function constexpr std::_Head_base<_Idx, _Head, false>::_Head_base(_UHead&&) [with _UHead = std::_Mem_fn<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)>; long unsigned int _Idx = 0ul; _Head = std::_Mem_fn<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)>] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Head_base *) this)->_M_head_impl = *(struct _Mem_fn &) (struct _Mem_fn *) std::forward<std::_Mem_fn<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)> > ((struct type &) (struct _Mem_fn *) __h)) >>>>>;
}


;; Function constexpr std::_Tuple_impl<_Idx, _Head, _Tail ...>::_Tuple_impl(std::_Tuple_impl<_Idx, _Head, _Tail ...>&&) [with long unsigned int _Idx = 0ul; _Head = std::_Mem_fn<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)>; _Tail = {std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*}] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Tuple_impl<1ul, std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*>::_Tuple_impl (&((struct _Tuple_impl *) this)->D.87475, (struct _Tuple_impl &) (struct type *) std::move<std::_Tuple_impl<1ul, std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*>&> ((struct _Tuple_impl &) (struct _Inherited *) std::_Tuple_impl<0ul, std::_Mem_fn<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)>, std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*>::_M_tail ((struct _Tuple_impl &) (struct _Tuple_impl *) __in))) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Head_base<0ul, std::_Mem_fn<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)>, false>::_Head_base<std::_Mem_fn<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)> > (&((struct _Tuple_impl *) this)->D.87476, (struct _Mem_fn &) (struct _Mem_fn *) std::forward<std::_Mem_fn<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)> > ((struct type &) (struct _Mem_fn *) std::_Tuple_impl<0ul, std::_Mem_fn<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)>, std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*>::_M_head ((struct _Tuple_impl &) (struct _Tuple_impl *) __in))) >>>>>;
  }
   >>>;


;; Function constexpr std::tuple< <template-parameter-1-1> >::tuple(std::tuple< <template-parameter-1-1> >&&) [with _Elements = {std::_Mem_fn<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)>, std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*}] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Tuple_impl<0ul, std::_Mem_fn<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)>, std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*>::_Tuple_impl (&((struct tuple *) this)->D.87947, (struct _Tuple_impl &) (struct _Tuple_impl *) NON_LVALUE_EXPR <(struct _Tuple_impl &) &((struct tuple *) D.87515)->D.87947>) >>>>>;
}


;; Function std::_Bind_simple<_Callable(_Args ...)>::_Bind_simple(std::_Bind_simple<_Callable(_Args ...)>&&) [with _Callable = std::_Mem_fn<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)>; _Args = {std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*}] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::tuple<std::_Mem_fn<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)>, std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*>::tuple (&((struct _Bind_simple *) this)->_M_bound, (struct tuple &) (struct tuple *) NON_LVALUE_EXPR <(struct tuple &) &D.84563->_M_bound>) >>>>>;
}


;; Function void std::call_once(std::once_flag&, _Callable&&, _Args&& ...) [with _Callable = void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*); _Args = {std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*}] (null)
;; enabled by -tree-original


{
  struct _Bind_simple __bound_functor;
  int __e;

    struct _Bind_simple __bound_functor;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__bound_functor = <<< Unknown tree: aggr_init_expr
  7
  __bind_simple
  D.88520
  (struct 
  {
    void _State_baseV2::<Tc8fa> (struct _State_baseV2 *, struct function *, bool *) * __pfn;
    long int __delta;
  } &) (struct 
  {
    void _State_baseV2::<Tc8fa> (struct _State_baseV2 *, struct function *, bool *) * __pfn;
    long int __delta;
  } *) std::forward<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)> ((struct type &) (struct 
  {
    void _State_baseV2::<Tc8fa> (struct _State_baseV2 *, struct function *, bool *) * __pfn;
    long int __delta;
  } *) __f)
  (struct _State_baseV2 * &) (struct _State_baseV2 * *) std::forward<std::__future_base::_State_baseV2*> ((struct _State_baseV2 * &) (struct _State_baseV2 * *) __args#0)
  (struct function * &) (struct function * *) std::forward<std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*> ((struct function * &) (struct function * *) __args#1)
  (bool * &) (bool * *) std::forward<bool*> ((bool * &) (bool * *) __args#2) >>>) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__once_callable = (void *) std::__addressof<std::_Bind_simple<std::_Mem_fn<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)>(std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)> > ((struct _Bind_simple &) &__bound_functor)) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__once_call = __once_call_impl) >>>>>;
    int __e;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__e = __gthread_once (&__once->_M_once, __once_proxy)) >>>>>;
  if (__e != 0)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_system_error (__e) >>>>>;
    }
}


;; Function void std::__atomic_futex_unsigned<_Waiter_bit>::_M_store_notify_all(unsigned int, std::memory_order) [with unsigned int _Waiter_bit = 2147483648u; std::memory_order = std::memory_order] (null)
;; enabled by -tree-original


{
  unsigned int * __futex = (unsigned int *) (void *) &((struct __atomic_futex_unsigned *) this)->_M_data;

    unsigned int * __futex = (unsigned int *) (void *) &((struct __atomic_futex_unsigned *) this)->_M_data;
  if (<<cleanup_point (signed int) std::__atomic_base<unsigned int>::exchange (&((struct __atomic_futex_unsigned *) this)->_M_data.D.56070, __val, __mo) < 0>>)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__atomic_futex_unsigned_base::_M_futex_notify_all (__futex) >>>>>;
    }
}


;; Function std::__weak_count<_Lp>::~__weak_count() [with __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    try
      {
        if (((struct __weak_count *) this)->_M_pi != 0B)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2u>::_M_weak_release (NON_LVALUE_EXPR <((struct __weak_count *) this)->_M_pi>) >>>>>;
          }
      }
    finally
      {
        *(struct 
        {
          struct _Sp_counted_base * _M_pi;
        } &) this = {CLOBBER};
      }
  }
  <D.90290>:;
   >>>;


;; Function constexpr std::default_delete<_Tp>::default_delete() [with _Tp = std::__future_base::_State_baseV2::_Make_ready] (null)
;; enabled by -tree-original


{
  
}


;; Function constexpr _Tp&& std::forward(typename std::remove_reference<_From>::type&) [with _Tp = std::__future_base::_State_baseV2::_Make_ready*&; typename std::remove_reference<_From>::type = std::__future_base::_State_baseV2::_Make_ready*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct _Make_ready * &) (struct _Make_ready * *) (struct _Make_ready * &) (struct _Make_ready * *) __t
   >>>;


;; Function constexpr _Tp&& std::forward(typename std::remove_reference<_From>::type&) [with _Tp = std::default_delete<std::__future_base::_State_baseV2::_Make_ready>; typename std::remove_reference<_From>::type = std::default_delete<std::__future_base::_State_baseV2::_Make_ready>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct default_delete &) (struct default_delete *) NON_LVALUE_EXPR <(struct default_delete &) __t>
   >>>;


;; Function constexpr std::_Head_base<_Idx, _Head, true>::_Head_base(_UHead&&) [with _UHead = std::default_delete<std::__future_base::_State_baseV2::_Make_ready>; long unsigned int _Idx = 1ul; _Head = std::default_delete<std::__future_base::_State_baseV2::_Make_ready>] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*(struct default_delete *) this = *(struct default_delete &) (struct default_delete *) std::forward<std::default_delete<std::__future_base::_State_baseV2::_Make_ready> > ((struct type &) (struct default_delete *) __h)) >>>>>;
}


;; Function constexpr std::_Tuple_impl<_Idx, _Head>::_Tuple_impl(_UHead&&) [with _UHead = std::default_delete<std::__future_base::_State_baseV2::_Make_ready>; long unsigned int _Idx = 1ul; _Head = std::default_delete<std::__future_base::_State_baseV2::_Make_ready>] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Head_base<1ul, std::default_delete<std::__future_base::_State_baseV2::_Make_ready>, true>::_Head_base<std::default_delete<std::__future_base::_State_baseV2::_Make_ready> > ((struct _Head_base *) this, (struct default_delete &) (struct default_delete *) std::forward<std::default_delete<std::__future_base::_State_baseV2::_Make_ready> > ((struct type &) (struct default_delete *) __head)) >>>>>;
}


;; Function constexpr std::_Head_base<_Idx, _Head, false>::_Head_base(_UHead&&) [with _UHead = std::__future_base::_State_baseV2::_Make_ready*&; long unsigned int _Idx = 0ul; _Head = std::__future_base::_State_baseV2::_Make_ready*] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Head_base *) this)->_M_head_impl = *std::forward<std::__future_base::_State_baseV2::_Make_ready*&> ((struct _Make_ready * &) (struct _Make_ready * *) __h)) >>>>>;
}


;; Function constexpr std::_Tuple_impl<_Idx, _Head, _Tail ...>::_Tuple_impl(_UHead&&, _UTail&& ...) [with _UHead = std::__future_base::_State_baseV2::_Make_ready*&; _UTail = {std::default_delete<std::__future_base::_State_baseV2::_Make_ready>}; <template-parameter-2-3> = void; long unsigned int _Idx = 0ul; _Head = std::__future_base::_State_baseV2::_Make_ready*; _Tail = {std::default_delete<std::__future_base::_State_baseV2::_Make_ready>}] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Tuple_impl<1ul, std::default_delete<std::__future_base::_State_baseV2::_Make_ready> >::_Tuple_impl<std::default_delete<std::__future_base::_State_baseV2::_Make_ready> > ((struct _Tuple_impl *) this, (struct default_delete &) (struct default_delete *) std::forward<std::default_delete<std::__future_base::_State_baseV2::_Make_ready> > ((struct type &) (struct default_delete *) __tail#0)) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Head_base<0ul, std::__future_base::_State_baseV2::_Make_ready*, false>::_Head_base<std::__future_base::_State_baseV2::_Make_ready*&> (&((struct _Tuple_impl *) this)->D.67320, (struct _Make_ready * &) (struct _Make_ready * *) std::forward<std::__future_base::_State_baseV2::_Make_ready*&> ((struct _Make_ready * &) (struct _Make_ready * *) __head)) >>>>>;
}


;; Function constexpr std::tuple<_T1, _T2>::tuple(_U1&&, _U2&&) [with _U1 = std::__future_base::_State_baseV2::_Make_ready*&; _U2 = std::default_delete<std::__future_base::_State_baseV2::_Make_ready>; <template-parameter-2-3> = void; _T1 = std::__future_base::_State_baseV2::_Make_ready*; _T2 = std::default_delete<std::__future_base::_State_baseV2::_Make_ready>] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Tuple_impl<0ul, std::__future_base::_State_baseV2::_Make_ready*, std::default_delete<std::__future_base::_State_baseV2::_Make_ready> >::_Tuple_impl<std::__future_base::_State_baseV2::_Make_ready*&, std::default_delete<std::__future_base::_State_baseV2::_Make_ready>, void> (&((struct tuple *) this)->D.67990, (struct _Make_ready * &) (struct _Make_ready * *) std::forward<std::__future_base::_State_baseV2::_Make_ready*&> ((struct _Make_ready * &) (struct _Make_ready * *) __a1), (struct default_delete &) (struct default_delete *) std::forward<std::default_delete<std::__future_base::_State_baseV2::_Make_ready> > ((struct type &) (struct default_delete *) __a2)) >>>>>;
}


;; Function std::unique_ptr<_Tp, _Dp>::unique_ptr(std::unique_ptr<_Tp, _Dp>::pointer) [with _Tp = std::__future_base::_State_baseV2::_Make_ready; _Dp = std::default_delete<std::__future_base::_State_baseV2::_Make_ready>; std::unique_ptr<_Tp, _Dp>::pointer = std::__future_base::_State_baseV2::_Make_ready*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::tuple<std::__future_base::_State_baseV2::_Make_ready*, std::default_delete<std::__future_base::_State_baseV2::_Make_ready> >::tuple<std::__future_base::_State_baseV2::_Make_ready*&, std::default_delete<std::__future_base::_State_baseV2::_Make_ready>, void> (&((struct unique_ptr *) this)->_M_t, (struct _Make_ready * &) &__p, (struct default_delete &) &TARGET_EXPR <D.90301, {}>) >>>>>;
  }
   >>>;


;; Function static constexpr _Head& std::_Head_base<_Idx, _Head, false>::_M_head(std::_Head_base<_Idx, _Head, false>&) [with long unsigned int _Idx = 0ul; _Head = std::__future_base::_State_baseV2::_Make_ready*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct _Make_ready * &) &__b->_M_head_impl
   >>>;


;; Function static constexpr _Head& std::_Tuple_impl<_Idx, _Head, _Tail ...>::_M_head(std::_Tuple_impl<_Idx, _Head, _Tail ...>&) [with long unsigned int _Idx = 0ul; _Head = std::__future_base::_State_baseV2::_Make_ready*; _Tail = {std::default_delete<std::__future_base::_State_baseV2::_Make_ready>}] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct _Make_ready * &) (struct _Make_ready * *) std::_Head_base<0ul, std::__future_base::_State_baseV2::_Make_ready*, false>::_M_head ((struct _Head_base &) &((struct _Tuple_impl *) __t)->D.67320)>>
   >>>;


;; Function constexpr _Head& std::__get_helper(std::_Tuple_impl<_Idx, _Head, _Tail ...>&) [with long unsigned int __i = 0ul; _Head = std::__future_base::_State_baseV2::_Make_ready*; _Tail = {std::default_delete<std::__future_base::_State_baseV2::_Make_ready>}] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct _Make_ready * &) (struct _Make_ready * *) std::_Tuple_impl<0ul, std::__future_base::_State_baseV2::_Make_ready*, std::default_delete<std::__future_base::_State_baseV2::_Make_ready> >::_M_head ((struct _Tuple_impl &) (struct _Tuple_impl *) __t)>>
   >>>;


;; Function constexpr std::__tuple_element_t<__i, std::tuple<_Elements ...> >& std::get(std::tuple<_Elements ...>&) [with long unsigned int __i = 0ul; _Elements = {std::__future_base::_State_baseV2::_Make_ready*, std::default_delete<std::__future_base::_State_baseV2::_Make_ready>}; std::__tuple_element_t<__i, std::tuple<_Elements ...> > = std::__future_base::_State_baseV2::_Make_ready*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct _Make_ready * &) (struct _Make_ready * *) std::__get_helper<0ul, std::__future_base::_State_baseV2::_Make_ready*, std::default_delete<std::__future_base::_State_baseV2::_Make_ready> > ((struct _Tuple_impl &) &((struct tuple *) __t)->D.67990)>>
   >>>;


;; Function std::unique_ptr<_Tp, _Dp>::~unique_ptr() [with _Tp = std::__future_base::_State_baseV2::_Make_ready; _Dp = std::default_delete<std::__future_base::_State_baseV2::_Make_ready>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    try
      {
        {
          struct _Make_ready * & __ptr;

                    struct _Make_ready * & __ptr;
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__ptr = (struct _Make_ready * &) (struct _Make_ready * *) std::get<0ul, std::__future_base::_State_baseV2::_Make_ready*, std::default_delete<std::__future_base::_State_baseV2::_Make_ready> > ((struct tuple &) &((struct unique_ptr *) this)->_M_t)) >>>>>;
          if (*__ptr != 0B)
            {
              <<cleanup_point <<< Unknown tree: expr_stmt
  std::default_delete<std::__future_base::_State_baseV2::_Make_ready>::operator() ((struct deleter_type *) std::unique_ptr<std::__future_base::_State_baseV2::_Make_ready>::get_deleter (this), *__ptr) >>>>>;
            }
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__ptr = 0B) >>>>>;
        }
      }
    finally
      {
        *(struct 
        {
          struct __tuple_type _M_t;
        } &) this = {CLOBBER};
      }
  }
  <D.90613>:;
   >>>;


;; Function std::unique_ptr<_Tp, _Dp>::pointer std::unique_ptr<_Tp, _Dp>::operator->() const [with _Tp = std::__future_base::_State_baseV2::_Make_ready; _Dp = std::default_delete<std::__future_base::_State_baseV2::_Make_ready>; std::unique_ptr<_Tp, _Dp>::pointer = std::__future_base::_State_baseV2::_Make_ready*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::unique_ptr<std::__future_base::_State_baseV2::_Make_ready>::get (this)>>
   >>>;


;; Function constexpr typename std::remove_reference< <template-parameter-1-1> >::type&& std::move(_Tp&&) [with _Tp = std::__weak_count<(__gnu_cxx::_Lock_policy)2u>&; typename std::remove_reference< <template-parameter-1-1> >::type = std::__weak_count<(__gnu_cxx::_Lock_policy)2u>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct type &) (struct type *) NON_LVALUE_EXPR <(struct type &) __t>
   >>>;


;; Function std::__weak_ptr<_Tp, _Lp>& std::__weak_ptr<_Tp, _Lp>::operator=(std::__weak_ptr<_Tp, _Lp>&&) [with _Tp = std::__future_base::_State_baseV2; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __weak_ptr *) this)->_M_ptr = __r->_M_ptr) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::__weak_count<(__gnu_cxx::_Lock_policy)2u>::operator= (&((struct __weak_ptr *) this)->_M_refcount, (struct __weak_count &) (struct type *) std::move<std::__weak_count<(__gnu_cxx::_Lock_policy)2u>&> ((struct __weak_count &) &__r->_M_refcount)) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__r->_M_ptr = 0B) >>>>>;
  return <retval> = (struct __weak_ptr &) (struct __weak_ptr *) this;
   >>>;


;; Function std::unique_ptr<_Tp, _Dp>::pointer std::unique_ptr<_Tp, _Dp>::release() [with _Tp = std::__future_base::_State_baseV2::_Make_ready; _Dp = std::default_delete<std::__future_base::_State_baseV2::_Make_ready>; std::unique_ptr<_Tp, _Dp>::pointer = std::__future_base::_State_baseV2::_Make_ready*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    struct _Make_ready * __p;

        struct _Make_ready * __p;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__p = std::unique_ptr<std::__future_base::_State_baseV2::_Make_ready>::get (this)) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*std::get<0ul, std::__future_base::_State_baseV2::_Make_ready*, std::default_delete<std::__future_base::_State_baseV2::_Make_ready> > ((struct tuple &) &((struct unique_ptr *) this)->_M_t) = 0B) >>>>>;
    return <retval> = __p;
  }
   >>>;


;; Function std::unique_ptr<_Tp, _Dp>::operator bool() const [with _Tp = std::__future_base::_Result_base; _Dp = std::__future_base::_Result_base::_Deleter] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>::get (this) != 0B>>
   >>>;


;; Function std::unique_ptr<_Tp, _Dp>::pointer std::unique_ptr<_Tp, _Dp>::operator->() const [with _Tp = std::__future_base::_Result_base; _Dp = std::__future_base::_Result_base::_Deleter; std::unique_ptr<_Tp, _Dp>::pointer = std::__future_base::_Result_base*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>::get (this)>>
   >>>;


;; Function std::__exception_ptr::exception_ptr std::make_exception_ptr(_Ex) [with _Ex = std::future_error] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<< Unknown tree: try_block
  <<cleanup_point <<< Unknown tree: expr_stmt
  <<< Unknown tree: throw_expr
  <<cleanup_point TARGET_EXPR <D.90655, __cxa_allocate_exception (32)>;, std::future_error::future_error ((struct future_error *) D.90655, (const struct future_error &) (const struct future_error *) (struct future_error *) __ex);>>;, __cxa_throw (D.90655, (void *) &_ZTISt12future_error, __comp_dtor ); >>> >>>>>
  <<< Unknown tree: handler
  
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) __cxa_begin_catch (__builtin_eh_pointer (0)) >>>>>;
      <<cleanup_point return *<retval> = TARGET_EXPR <D.90656, <<< Unknown tree: aggr_init_expr
  3
  current_exception
  D.90656 >>>>>>;
    }
  finally
    {
      __cxa_end_catch ();
    } >>> >>>
   >>>;


;; Function static constexpr std::_Tuple_impl<_Idx, _Head, _Tail ...>::_Inherited& std::_Tuple_impl<_Idx, _Head, _Tail ...>::_M_tail(std::_Tuple_impl<_Idx, _Head, _Tail ...>&) [with long unsigned int _Idx = 0ul; _Head = std::__future_base::_Result_base*; _Tail = {std::__future_base::_Result_base::_Deleter}; std::_Tuple_impl<_Idx, _Head, _Tail ...>::_Inherited = std::_Tuple_impl<1ul, std::__future_base::_Result_base::_Deleter>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct _Inherited &) (struct _Tuple_impl *) (struct _Tuple_impl *) __t
   >>>;


;; Function void std::unique_ptr<_Tp, _Dp>::swap(std::unique_ptr<_Tp, _Dp>&) [with _Tp = std::__future_base::_Result_base; _Dp = std::__future_base::_Result_base::_Deleter] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    (void) 0;
    (void) 0;
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::swap<std::__future_base::_Result_base*, std::__future_base::_Result_base::_Deleter> ((struct tuple &) &((struct unique_ptr *) this)->_M_t, (struct tuple &) &__u->_M_t) >>>>>;
  }
   >>>;


;; Function _Res std::function<_Res(_ArgTypes ...)>::operator()(_ArgTypes ...) const [with _Res = std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>; _ArgTypes = {}] (null)
;; enabled by -tree-original


if (<<cleanup_point std::_Function_base::_M_empty (&((const struct function *) this)->D.65694)>>)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_bad_function_call () >>>>>;
  }
<<cleanup_point return *<retval> = TARGET_EXPR <D.91226, <<< Unknown tree: aggr_init_expr
  4
  (struct unique_ptr (*_Invoker_type) (const union _Any_data &)) ((const struct function *) this)->_M_invoker
  D.91226
  (const union _Any_data &) &((const struct function *) this)->D.65694._M_functor >>>>>>;


;; Function constexpr _Tp&& std::forward(typename std::remove_reference<_From>::type&) [with _Tp = std::__future_base::_Result_base::_Deleter; typename std::remove_reference<_From>::type = std::__future_base::_Result_base::_Deleter] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct _Deleter &) (struct _Deleter *) NON_LVALUE_EXPR <(struct _Deleter &) __t>
   >>>;


;; Function constexpr _Tp&& std::forward(typename std::remove_reference<_From>::type&) [with _Tp = std::__future_base::_Result_base*; typename std::remove_reference<_From>::type = std::__future_base::_Result_base*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct _Result_base * &) (struct _Result_base * *) (struct _Result_base * &) __t
   >>>;


;; Function constexpr std::_Head_base<_Idx, _Head, true>::_Head_base(_UHead&&) [with _UHead = std::__future_base::_Result_base::_Deleter; long unsigned int _Idx = 1ul; _Head = std::__future_base::_Result_base::_Deleter] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*(struct _Deleter *) this = *(struct _Deleter &) (struct _Deleter *) std::forward<std::__future_base::_Result_base::_Deleter> ((struct type &) (struct _Deleter *) __h)) >>>>>;
}


;; Function constexpr std::_Tuple_impl<_Idx, _Head>::_Tuple_impl(_UHead&&) [with _UHead = std::__future_base::_Result_base::_Deleter; long unsigned int _Idx = 1ul; _Head = std::__future_base::_Result_base::_Deleter] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Head_base<1ul, std::__future_base::_Result_base::_Deleter, true>::_Head_base<std::__future_base::_Result_base::_Deleter> ((struct _Head_base *) this, (struct _Deleter &) (struct _Deleter *) std::forward<std::__future_base::_Result_base::_Deleter> ((struct type &) (struct _Deleter *) __head)) >>>>>;
}


;; Function constexpr std::_Head_base<_Idx, _Head, false>::_Head_base(_UHead&&) [with _UHead = std::__future_base::_Result_base*; long unsigned int _Idx = 0ul; _Head = std::__future_base::_Result_base*] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Head_base *) this)->_M_head_impl = *std::forward<std::__future_base::_Result_base*> ((struct _Result_base * &) (struct _Result_base * *) __h)) >>>>>;
}


;; Function constexpr std::_Tuple_impl<_Idx, _Head, _Tail ...>::_Tuple_impl(_UHead&&, _UTail&& ...) [with _UHead = std::__future_base::_Result_base*; _UTail = {std::__future_base::_Result_base::_Deleter}; <template-parameter-2-3> = void; long unsigned int _Idx = 0ul; _Head = std::__future_base::_Result_base*; _Tail = {std::__future_base::_Result_base::_Deleter}] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Tuple_impl<1ul, std::__future_base::_Result_base::_Deleter>::_Tuple_impl<std::__future_base::_Result_base::_Deleter> ((struct _Tuple_impl *) this, (struct _Deleter &) (struct _Deleter *) std::forward<std::__future_base::_Result_base::_Deleter> ((struct type &) (struct _Deleter *) __tail#0)) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Head_base<0ul, std::__future_base::_Result_base*, false>::_Head_base<std::__future_base::_Result_base*> (&((struct _Tuple_impl *) this)->D.63461, (struct _Result_base * &) (struct _Result_base * *) std::forward<std::__future_base::_Result_base*> ((struct _Result_base * &) (struct _Result_base * *) __head)) >>>>>;
}


;; Function constexpr std::tuple<_T1, _T2>::tuple(_U1&&, _U2&&) [with _U1 = std::__future_base::_Result_base*; _U2 = std::__future_base::_Result_base::_Deleter; <template-parameter-2-3> = void; _T1 = std::__future_base::_Result_base*; _T2 = std::__future_base::_Result_base::_Deleter] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Tuple_impl<0ul, std::__future_base::_Result_base*, std::__future_base::_Result_base::_Deleter>::_Tuple_impl<std::__future_base::_Result_base*, std::__future_base::_Result_base::_Deleter, void> (&((struct tuple *) this)->D.64132, (struct _Result_base * &) (struct _Result_base * *) std::forward<std::__future_base::_Result_base*> ((struct _Result_base * &) (struct _Result_base * *) __a1), (struct _Deleter &) (struct _Deleter *) std::forward<std::__future_base::_Result_base::_Deleter> ((struct type &) (struct _Deleter *) __a2)) >>>>>;
}


;; Function std::unique_ptr<_Tp, _Dp>::unique_ptr(std::unique_ptr<_Tp, _Dp>&&) [with _Tp = std::__future_base::_Result_base; _Dp = std::__future_base::_Result_base::_Deleter] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::tuple<std::__future_base::_Result_base*, std::__future_base::_Result_base::_Deleter>::tuple<std::__future_base::_Result_base*, std::__future_base::_Result_base::_Deleter, void> (&((struct unique_ptr *) this)->_M_t, (struct _Result_base * &) &TARGET_EXPR <D.91249, std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>::release ((struct unique_ptr *) __u)>, (struct _Deleter &) (struct _Deleter *) std::forward<std::__future_base::_Result_base::_Deleter> ((struct type &) (struct deleter_type *) std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>::get_deleter ((struct unique_ptr *) __u))) >>>>>;
  }
   >>>;


;; Function std::__shared_ptr<_Tp, _Lp>::__shared_ptr(const std::__shared_ptr<_Tp, _Lp>&) [with _Tp = std::__future_base::_State_baseV2; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __shared_ptr *) this)->_M_ptr = (struct _State_baseV2 *) D.68853->_M_ptr) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__shared_count<>::__shared_count (&((struct __shared_ptr *) this)->_M_refcount, (const struct __shared_count &) &D.68853->_M_refcount) >>>>>;
  try
    {
      
    }
  catch
    {
      std::__shared_count<>::~__shared_count (&((struct __shared_ptr *) this)->_M_refcount);
    }
}


;; Function std::shared_ptr<_Tp>::shared_ptr(const std::shared_ptr<_Tp>&) [with _Tp = std::__future_base::_State_baseV2] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__shared_ptr<std::__future_base::_State_baseV2, (__gnu_cxx::_Lock_policy)2u>::__shared_ptr (&((struct shared_ptr *) this)->D.69901, (const struct __shared_ptr &) &((const struct shared_ptr *) D.69410)->D.69901) >>>>>;
  try
    {
      
    }
  catch
    {
      std::__shared_ptr<std::__future_base::_State_baseV2, (__gnu_cxx::_Lock_policy)2u>::~__shared_ptr (&((struct shared_ptr *) this)->D.69901);
    }
}


;; Function std::__basic_future<_Res>::__basic_future(const __state_type&) [with _Res = void; std::__basic_future<_Res>::__state_type = std::shared_ptr<std::__future_base::_State_baseV2>] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__future_base::__future_base ((struct __future_base *) this) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::shared_ptr<std::__future_base::_State_baseV2>::shared_ptr (&((struct __basic_future *) this)->_M_state, (const struct shared_ptr &) (const struct __state_type *) __state) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__future_base::_State_baseV2::_S_check<std::__future_base::_State_baseV2> ((const struct shared_ptr &) (const struct shared_ptr *) &((struct __basic_future *) this)->_M_state) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__future_base::_State_baseV2::_M_set_retrieved_flag (std::__shared_ptr<std::__future_base::_State_baseV2, (__gnu_cxx::_Lock_policy)2u>::operator-> (&((struct __basic_future *) this)->_M_state.D.69901)) >>>>>;
    }
  catch
    {
      std::shared_ptr<std::__future_base::_State_baseV2>::~shared_ptr (&((struct __basic_future *) this)->_M_state);
    }
}


;; Function std::__basic_future<_Res>::__basic_future(std::future<_Res>&&) [with _Res = void] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__future_base::__future_base ((struct __future_base *) this) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::shared_ptr<std::__future_base::_State_baseV2>::shared_ptr (&((struct __basic_future *) this)->_M_state, (struct shared_ptr &) (struct type *) std::move<std::shared_ptr<std::__future_base::_State_baseV2>&> ((struct shared_ptr &) &((struct future *) __uf)->D.70272._M_state)) >>>>>;
    try
      {
        
      }
    catch
      {
        std::shared_ptr<std::__future_base::_State_baseV2>::~shared_ptr (&((struct __basic_future *) this)->_M_state);
      }
  }
   >>>;


;; Function void std::__basic_future<_Res>::_M_swap(std::__basic_future<_Res>&) [with _Res = void] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__shared_ptr<std::__future_base::_State_baseV2, (__gnu_cxx::_Lock_policy)2u>::swap (&((struct __basic_future *) this)->_M_state.D.69901, (struct __shared_ptr &) &__that->_M_state.D.69901) >>>>>
   >>>;


;; Function std::__basic_future<_Res>::_Reset::_Reset(std::__basic_future<_Res>&) [with _Res = void] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Reset *) this)->_M_fut = (struct __basic_future &) (struct __basic_future *) __fut) >>>>>;
  }
   >>>;


;; Function std::__basic_future<_Res>::_Reset::~_Reset() [with _Res = void] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    try
      {
        <<cleanup_point <<< Unknown tree: expr_stmt
  std::__shared_ptr<std::__future_base::_State_baseV2, (__gnu_cxx::_Lock_policy)2u>::reset (&((struct _Reset *) this)->_M_fut->_M_state.D.69901) >>>>>;
      }
    finally
      {
        *(struct 
        {
          struct __basic_future & _M_fut;
        } &) this = {CLOBBER};
      }
  }
  <D.91331>:;
   >>>;


;; Function std::__future_base::_Result<_Res>& std::__basic_future<_Res>::_M_get_result() const [with _Res = void; std::__basic_future<_Res>::__result_type = std::__future_base::_Result<void>&] (null)
;; enabled by -tree-original


{
  struct _Result_base & __res;

  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__future_base::_State_baseV2::_S_check<std::__future_base::_State_baseV2> ((const struct shared_ptr &) &((const struct __basic_future *) this)->_M_state) >>>>>;
    struct _Result_base & __res;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__res = (struct _Result_base &) (struct _Result_base *) std::__future_base::_State_baseV2::wait (std::__shared_ptr<std::__future_base::_State_baseV2, (__gnu_cxx::_Lock_policy)2u>::operator-> (&((const struct __basic_future *) this)->_M_state.D.69901))) >>>>>;
  if (<<cleanup_point !std::__exception_ptr::operator== ((const struct exception_ptr &) (const struct exception_ptr *) &__res->_M_error, (const struct exception_ptr &) &TARGET_EXPR <D.91339, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.91339
  (const struct exception_ptr *) <<< Unknown tree: void_cst >>>
  0 >>>>)>>)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::rethrow_exception (&TARGET_EXPR <D.91340, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.91340
  (struct exception_ptr *) <<< Unknown tree: void_cst >>>
  (const struct exception_ptr &) (const struct exception_ptr *) &__res->_M_error >>>>) >>>>>;
    }
  return <retval> = (struct _Result &) (struct _Result *) NON_LVALUE_EXPR <(struct _Result &) __res>;
}


;; Function std::__basic_future<_Res>::__basic_future(const std::shared_future<_Res>&) [with _Res = void] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__future_base::__future_base ((struct __future_base *) this) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::shared_ptr<std::__future_base::_State_baseV2>::shared_ptr (&((struct __basic_future *) this)->_M_state, (const struct shared_ptr &) &((const struct shared_future *) __sf)->D.70553._M_state) >>>>>;
    try
      {
        
      }
    catch
      {
        std::shared_ptr<std::__future_base::_State_baseV2>::~shared_ptr (&((struct __basic_future *) this)->_M_state);
      }
  }
   >>>;


;; Function std::__basic_future<_Res>::__basic_future(std::shared_future<_Res>&&) [with _Res = void] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__future_base::__future_base ((struct __future_base *) this) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::shared_ptr<std::__future_base::_State_baseV2>::shared_ptr (&((struct __basic_future *) this)->_M_state, (struct shared_ptr &) (struct type *) std::move<std::shared_ptr<std::__future_base::_State_baseV2>&> ((struct shared_ptr &) &((struct shared_future *) __sf)->D.70553._M_state)) >>>>>;
    try
      {
        
      }
    catch
      {
        std::shared_ptr<std::__future_base::_State_baseV2>::~shared_ptr (&((struct __basic_future *) this)->_M_state);
      }
  }
   >>>;


;; Function std::shared_ptr<_Tp1> std::make_shared(_Args&& ...) [with _Tp = std::__future_base::_State_baseV2; _Args = {}] (null)
;; enabled by -tree-original


{
  typedef struct _Tp_nc _Tp_nc;

  <<cleanup_point return *<retval> = TARGET_EXPR <D.91522, <<< Unknown tree: aggr_init_expr
  4
  allocate_shared
  D.91522
  (const struct allocator &) (const struct allocator *) &TARGET_EXPR <D.91519, <<< Unknown tree: aggr_init_expr
  4
  __comp_ctor 
  D.91519
  (struct allocator *) <<< Unknown tree: void_cst >>> >>>> >>>>>>;
}


;; Function std::shared_ptr<_Tp>::shared_ptr(std::shared_ptr<_Tp>&&) [with _Tp = std::__future_base::_State_baseV2] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__shared_ptr<std::__future_base::_State_baseV2, (__gnu_cxx::_Lock_policy)2u>::__shared_ptr (&((struct shared_ptr *) this)->D.69901, (struct __shared_ptr &) (struct __shared_ptr *) NON_LVALUE_EXPR <(struct __shared_ptr &) &((struct type *) std::move<std::shared_ptr<std::__future_base::_State_baseV2>&> ((struct shared_ptr &) (struct shared_ptr *) __r))->D.69901>) >>>>>;
    try
      {
        
      }
    catch
      {
        std::__shared_ptr<std::__future_base::_State_baseV2, (__gnu_cxx::_Lock_policy)2u>::~__shared_ptr (&((struct shared_ptr *) this)->D.69901);
      }
  }
   >>>;


;; Function constexpr _Tp&& std::forward(typename std::remove_reference<_From>::type&) [with _Tp = std::__future_base::_Result<void>*&; typename std::remove_reference<_From>::type = std::__future_base::_Result<void>*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct _Result * &) (struct _Result * *) (struct _Result * &) (struct _Result * *) __t
   >>>;


;; Function constexpr std::_Head_base<_Idx, _Head, false>::_Head_base(_UHead&&) [with _UHead = std::__future_base::_Result<void>*&; long unsigned int _Idx = 0ul; _Head = std::__future_base::_Result<void>*] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Head_base *) this)->_M_head_impl = *std::forward<std::__future_base::_Result<void>*&> ((struct _Result * &) (struct _Result * *) __h)) >>>>>;
}


;; Function constexpr std::_Tuple_impl<_Idx, _Head, _Tail ...>::_Tuple_impl(_UHead&&, _UTail&& ...) [with _UHead = std::__future_base::_Result<void>*&; _UTail = {std::__future_base::_Result_base::_Deleter}; <template-parameter-2-3> = void; long unsigned int _Idx = 0ul; _Head = std::__future_base::_Result<void>*; _Tail = {std::__future_base::_Result_base::_Deleter}] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Tuple_impl<1ul, std::__future_base::_Result_base::_Deleter>::_Tuple_impl<std::__future_base::_Result_base::_Deleter> ((struct _Tuple_impl *) this, (struct _Deleter &) (struct _Deleter *) std::forward<std::__future_base::_Result_base::_Deleter> ((struct type &) (struct _Deleter *) __tail#0)) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Head_base<0ul, std::__future_base::_Result<void>*, false>::_Head_base<std::__future_base::_Result<void>*&> (&((struct _Tuple_impl *) this)->D.71551, (struct _Result * &) (struct _Result * *) std::forward<std::__future_base::_Result<void>*&> ((struct _Result * &) (struct _Result * *) __head)) >>>>>;
}


;; Function constexpr std::tuple<_T1, _T2>::tuple(_U1&&, _U2&&) [with _U1 = std::__future_base::_Result<void>*&; _U2 = std::__future_base::_Result_base::_Deleter; <template-parameter-2-3> = void; _T1 = std::__future_base::_Result<void>*; _T2 = std::__future_base::_Result_base::_Deleter] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Tuple_impl<0ul, std::__future_base::_Result<void>*, std::__future_base::_Result_base::_Deleter>::_Tuple_impl<std::__future_base::_Result<void>*&, std::__future_base::_Result_base::_Deleter, void> (&((struct tuple *) this)->D.72219, (struct _Result * &) (struct _Result * *) std::forward<std::__future_base::_Result<void>*&> ((struct _Result * &) (struct _Result * *) __a1), (struct _Deleter &) (struct _Deleter *) std::forward<std::__future_base::_Result_base::_Deleter> ((struct type &) (struct _Deleter *) __a2)) >>>>>;
}


;; Function std::unique_ptr<_Tp, _Dp>::unique_ptr(std::unique_ptr<_Tp, _Dp>::pointer) [with _Tp = std::__future_base::_Result<void>; _Dp = std::__future_base::_Result_base::_Deleter; std::unique_ptr<_Tp, _Dp>::pointer = std::__future_base::_Result<void>*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::tuple<std::__future_base::_Result<void>*, std::__future_base::_Result_base::_Deleter>::tuple<std::__future_base::_Result<void>*&, std::__future_base::_Result_base::_Deleter, void> (&((struct unique_ptr *) this)->_M_t, (struct _Result * &) &__p, (struct _Deleter &) &TARGET_EXPR <D.91536, {}>) >>>>>;
  }
   >>>;


;; Function static constexpr _Head& std::_Head_base<_Idx, _Head, false>::_M_head(std::_Head_base<_Idx, _Head, false>&) [with long unsigned int _Idx = 0ul; _Head = std::__future_base::_Result<void>*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct _Result * &) &__b->_M_head_impl
   >>>;


;; Function static constexpr _Head& std::_Tuple_impl<_Idx, _Head, _Tail ...>::_M_head(std::_Tuple_impl<_Idx, _Head, _Tail ...>&) [with long unsigned int _Idx = 0ul; _Head = std::__future_base::_Result<void>*; _Tail = {std::__future_base::_Result_base::_Deleter}] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct _Result * &) (struct _Result * *) std::_Head_base<0ul, std::__future_base::_Result<void>*, false>::_M_head ((struct _Head_base &) &((struct _Tuple_impl *) __t)->D.71551)>>
   >>>;


;; Function constexpr _Head& std::__get_helper(std::_Tuple_impl<_Idx, _Head, _Tail ...>&) [with long unsigned int __i = 0ul; _Head = std::__future_base::_Result<void>*; _Tail = {std::__future_base::_Result_base::_Deleter}] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct _Result * &) (struct _Result * *) std::_Tuple_impl<0ul, std::__future_base::_Result<void>*, std::__future_base::_Result_base::_Deleter>::_M_head ((struct _Tuple_impl &) (struct _Tuple_impl *) __t)>>
   >>>;


;; Function constexpr std::__tuple_element_t<__i, std::tuple<_Elements ...> >& std::get(std::tuple<_Elements ...>&) [with long unsigned int __i = 0ul; _Elements = {std::__future_base::_Result<void>*, std::__future_base::_Result_base::_Deleter}; std::__tuple_element_t<__i, std::tuple<_Elements ...> > = std::__future_base::_Result<void>*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct _Result * &) (struct _Result * *) std::__get_helper<0ul, std::__future_base::_Result<void>*, std::__future_base::_Result_base::_Deleter> ((struct _Tuple_impl &) &((struct tuple *) __t)->D.72219)>>
   >>>;


;; Function std::unique_ptr<_Tp, _Dp>::~unique_ptr() [with _Tp = std::__future_base::_Result<void>; _Dp = std::__future_base::_Result_base::_Deleter] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    try
      {
        {
          struct _Result * & __ptr;

                    struct _Result * & __ptr;
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__ptr = (struct _Result * &) (struct _Result * *) std::get<0ul, std::__future_base::_Result<void>*, std::__future_base::_Result_base::_Deleter> ((struct tuple &) &((struct unique_ptr *) this)->_M_t)) >>>>>;
          if (*__ptr != 0B)
            {
              <<cleanup_point <<< Unknown tree: expr_stmt
  std::__future_base::_Result_base::_Deleter::operator() ((struct deleter_type *) std::unique_ptr<std::__future_base::_Result<void>, std::__future_base::_Result_base::_Deleter>::get_deleter (this), (struct _Result_base *) *__ptr) >>>>>;
            }
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__ptr = 0B) >>>>>;
        }
      }
    finally
      {
        *(struct 
        {
          struct __tuple_type _M_t;
        } &) this = {CLOBBER};
      }
  }
  <D.91712>:;
   >>>;


;; Function constexpr _Tp&& std::forward(typename std::remove_reference<_From>::type&) [with _Tp = std::__future_base::_Result<void>*; typename std::remove_reference<_From>::type = std::__future_base::_Result<void>*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct _Result * &) (struct _Result * *) (struct _Result * &) __t
   >>>;


;; Function constexpr std::_Head_base<_Idx, _Head, false>::_Head_base(_UHead&&) [with _UHead = std::__future_base::_Result<void>*; long unsigned int _Idx = 0ul; _Head = std::__future_base::_Result<void>*] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Head_base *) this)->_M_head_impl = *std::forward<std::__future_base::_Result<void>*> ((struct _Result * &) (struct _Result * *) __h)) >>>>>;
}


;; Function constexpr std::_Tuple_impl<_Idx, _Head, _Tail ...>::_Tuple_impl(_UHead&&, _UTail&& ...) [with _UHead = std::__future_base::_Result<void>*; _UTail = {std::__future_base::_Result_base::_Deleter}; <template-parameter-2-3> = void; long unsigned int _Idx = 0ul; _Head = std::__future_base::_Result<void>*; _Tail = {std::__future_base::_Result_base::_Deleter}] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Tuple_impl<1ul, std::__future_base::_Result_base::_Deleter>::_Tuple_impl<std::__future_base::_Result_base::_Deleter> ((struct _Tuple_impl *) this, (struct _Deleter &) (struct _Deleter *) std::forward<std::__future_base::_Result_base::_Deleter> ((struct type &) (struct _Deleter *) __tail#0)) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Head_base<0ul, std::__future_base::_Result<void>*, false>::_Head_base<std::__future_base::_Result<void>*> (&((struct _Tuple_impl *) this)->D.71551, (struct _Result * &) (struct _Result * *) std::forward<std::__future_base::_Result<void>*> ((struct _Result * &) (struct _Result * *) __head)) >>>>>;
}


;; Function constexpr std::tuple<_T1, _T2>::tuple(_U1&&, _U2&&) [with _U1 = std::__future_base::_Result<void>*; _U2 = std::__future_base::_Result_base::_Deleter; <template-parameter-2-3> = void; _T1 = std::__future_base::_Result<void>*; _T2 = std::__future_base::_Result_base::_Deleter] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Tuple_impl<0ul, std::__future_base::_Result<void>*, std::__future_base::_Result_base::_Deleter>::_Tuple_impl<std::__future_base::_Result<void>*, std::__future_base::_Result_base::_Deleter, void> (&((struct tuple *) this)->D.72219, (struct _Result * &) (struct _Result * *) std::forward<std::__future_base::_Result<void>*> ((struct _Result * &) (struct _Result * *) __a1), (struct _Deleter &) (struct _Deleter *) std::forward<std::__future_base::_Result_base::_Deleter> ((struct type &) (struct _Deleter *) __a2)) >>>>>;
}


;; Function std::unique_ptr<_Tp, _Dp>::unique_ptr(std::unique_ptr<_Tp, _Dp>&&) [with _Tp = std::__future_base::_Result<void>; _Dp = std::__future_base::_Result_base::_Deleter] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::tuple<std::__future_base::_Result<void>*, std::__future_base::_Result_base::_Deleter>::tuple<std::__future_base::_Result<void>*, std::__future_base::_Result_base::_Deleter, void> (&((struct unique_ptr *) this)->_M_t, (struct _Result * &) &TARGET_EXPR <D.91759, std::unique_ptr<std::__future_base::_Result<void>, std::__future_base::_Result_base::_Deleter>::release ((struct unique_ptr *) __u)>, (struct _Deleter &) (struct _Deleter *) std::forward<std::__future_base::_Result_base::_Deleter> ((struct type &) (struct deleter_type *) std::unique_ptr<std::__future_base::_Result<void>, std::__future_base::_Result_base::_Deleter>::get_deleter ((struct unique_ptr *) __u))) >>>>>;
  }
   >>>;


;; Function std::__shared_ptr<_Tp, _Lp>::operator bool() const [with _Tp = std::__future_base::_State_baseV2; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


return <retval> = (struct _State_baseV2 *) ((const struct __shared_ptr *) this)->_M_ptr != 0B;


;; Function bool std::__shared_ptr<_Tp, _Lp>::unique() const [with _Tp = std::__future_base::_State_baseV2; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::__shared_count<>::_M_unique (&((const struct __shared_ptr *) this)->_M_refcount)>>
   >>>;


;; Function _Tp* std::__shared_ptr<_Tp, _Lp>::operator->() const [with _Tp = std::__future_base::_State_baseV2; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct _State_baseV2 *) ((const struct __shared_ptr *) this)->_M_ptr
   >>>;


;; Function constexpr std::_Head_base<_Idx, _Head, false>::_Head_base(_UHead&&) [with _UHead = std::__future_base::_Result<void>*; long unsigned int _Idx = 0ul; _Head = std::__future_base::_Result_base*] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Head_base *) this)->_M_head_impl = (struct _Result_base *) *std::forward<std::__future_base::_Result<void>*> ((struct _Result * &) (struct _Result * *) __h)) >>>>>;
}


;; Function constexpr std::_Tuple_impl<_Idx, _Head, _Tail ...>::_Tuple_impl(_UHead&&, _UTail&& ...) [with _UHead = std::__future_base::_Result<void>*; _UTail = {std::__future_base::_Result_base::_Deleter}; <template-parameter-2-3> = void; long unsigned int _Idx = 0ul; _Head = std::__future_base::_Result_base*; _Tail = {std::__future_base::_Result_base::_Deleter}] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Tuple_impl<1ul, std::__future_base::_Result_base::_Deleter>::_Tuple_impl<std::__future_base::_Result_base::_Deleter> ((struct _Tuple_impl *) this, (struct _Deleter &) (struct _Deleter *) std::forward<std::__future_base::_Result_base::_Deleter> ((struct type &) (struct _Deleter *) __tail#0)) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Head_base<0ul, std::__future_base::_Result_base*, false>::_Head_base<std::__future_base::_Result<void>*> (&((struct _Tuple_impl *) this)->D.63461, (struct _Result * &) (struct _Result * *) std::forward<std::__future_base::_Result<void>*> ((struct _Result * &) (struct _Result * *) __head)) >>>>>;
}


;; Function constexpr std::tuple<_T1, _T2>::tuple(_U1&&, _U2&&) [with _U1 = std::__future_base::_Result<void>*; _U2 = std::__future_base::_Result_base::_Deleter; <template-parameter-2-3> = void; _T1 = std::__future_base::_Result_base*; _T2 = std::__future_base::_Result_base::_Deleter] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Tuple_impl<0ul, std::__future_base::_Result_base*, std::__future_base::_Result_base::_Deleter>::_Tuple_impl<std::__future_base::_Result<void>*, std::__future_base::_Result_base::_Deleter, void> (&((struct tuple *) this)->D.64132, (struct _Result * &) (struct _Result * *) std::forward<std::__future_base::_Result<void>*> ((struct _Result * &) (struct _Result * *) __a1), (struct _Deleter &) (struct _Deleter *) std::forward<std::__future_base::_Result_base::_Deleter> ((struct type &) (struct _Deleter *) __a2)) >>>>>;
}


;; Function std::unique_ptr<_Tp, _Dp>::unique_ptr(std::unique_ptr<_Up, _Ep>&&) [with _Up = std::__future_base::_Result<void>; _Ep = std::__future_base::_Result_base::_Deleter; <template-parameter-2-3> = void; _Tp = std::__future_base::_Result_base; _Dp = std::__future_base::_Result_base::_Deleter] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::tuple<std::__future_base::_Result_base*, std::__future_base::_Result_base::_Deleter>::tuple<std::__future_base::_Result<void>*, std::__future_base::_Result_base::_Deleter, void> (&((struct unique_ptr *) this)->_M_t, (struct _Result * &) &TARGET_EXPR <D.91822, std::unique_ptr<std::__future_base::_Result<void>, std::__future_base::_Result_base::_Deleter>::release ((struct unique_ptr *) __u)>, (struct _Deleter &) (struct _Deleter *) std::forward<std::__future_base::_Result_base::_Deleter> ((struct type &) (struct deleter_type *) std::unique_ptr<std::__future_base::_Result<void>, std::__future_base::_Result_base::_Deleter>::get_deleter ((struct unique_ptr *) __u))) >>>>>;
  }
   >>>;


;; Function void std::__shared_ptr<_Tp, _Lp>::swap(std::__shared_ptr<_Tp, _Lp>&) [with _Tp = std::__future_base::_State_baseV2; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::swap<std::__future_base::_State_baseV2*> ((struct _State_baseV2 * &) &((struct __shared_ptr *) this)->_M_ptr, (struct _State_baseV2 * &) &__other->_M_ptr) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__shared_count<>::_M_swap (&((struct __shared_ptr *) this)->_M_refcount, (struct __shared_count &) &__other->_M_refcount) >>>>>;
   >>>;


;; Function static constexpr std::_Tuple_impl<_Idx, _Head, _Tail ...>::_Inherited& std::_Tuple_impl<_Idx, _Head, _Tail ...>::_M_tail(std::_Tuple_impl<_Idx, _Head, _Tail ...>&) [with long unsigned int _Idx = 0ul; _Head = std::__future_base::_Result<void>*; _Tail = {std::__future_base::_Result_base::_Deleter}; std::_Tuple_impl<_Idx, _Head, _Tail ...>::_Inherited = std::_Tuple_impl<1ul, std::__future_base::_Result_base::_Deleter>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct _Inherited &) (struct _Tuple_impl *) (struct _Tuple_impl *) __t
   >>>;


;; Function void std::unique_ptr<_Tp, _Dp>::swap(std::unique_ptr<_Tp, _Dp>&) [with _Tp = std::__future_base::_Result<void>; _Dp = std::__future_base::_Result_base::_Deleter] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    (void) 0;
    (void) 0;
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::swap<std::__future_base::_Result<void>*, std::__future_base::_Result_base::_Deleter> ((struct tuple &) &((struct unique_ptr *) this)->_M_t, (struct tuple &) &__u->_M_t) >>>>>;
  }
   >>>;


;; Function static std::__future_base::_State_baseV2::_Setter<_Res, std::__future_base::_State_baseV2::__exception_ptr_tag> std::__future_base::_State_baseV2::__setter(std::__exception_ptr::exception_ptr&, std::promise<_Res>*) [with _Res = void] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = TARGET_EXPR <D.92197, {._M_promise=__prom, ._M_ex=(struct exception_ptr *) __ex}>>>;


;; Function constexpr std::_Maybe_unary_or_binary_function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> >::_Maybe_unary_or_binary_function() (null)
;; enabled by -tree-original


{
  
}


;; Function constexpr typename std::remove_reference< <template-parameter-1-1> >::type&& std::move(_Tp&&) [with _Tp = std::__future_base::_State_baseV2::_Setter<void, std::__future_base::_State_baseV2::__exception_ptr_tag>&; typename std::remove_reference< <template-parameter-1-1> >::type = std::__future_base::_State_baseV2::_Setter<void, std::__future_base::_State_baseV2::__exception_ptr_tag>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct type &) (struct type *) NON_LVALUE_EXPR <(struct type &) __t>
   >>>;


;; Function std::function<_Res(_ArgTypes ...)>::function(_Functor) [with _Functor = std::__future_base::_State_baseV2::_Setter<void, std::__future_base::_State_baseV2::__exception_ptr_tag>; <template-parameter-2-2> = void; <template-parameter-2-3> = void; _Res = std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>; _ArgTypes = {}] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Maybe_unary_or_binary_function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> >::_Maybe_unary_or_binary_function ((struct _Maybe_unary_or_binary_function *) this) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Function_base::_Function_base (&((struct function *) this)->D.65694) >>>>>;
  try
    {
      {
        typedef struct _My_handler _My_handler;

        if (<<cleanup_point std::_Function_base::_Base_manager<std::__future_base::_State_baseV2::_Setter<void, std::__future_base::_State_baseV2::__exception_ptr_tag> >::_M_not_empty_function<std::__future_base::_State_baseV2::_Setter<void, std::__future_base::_State_baseV2::__exception_ptr_tag> > ((const struct _Setter &) (const struct _Setter *) &__f)>>)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Function_base::_Base_manager<std::__future_base::_State_baseV2::_Setter<void, std::__future_base::_State_baseV2::__exception_ptr_tag> >::_M_init_functor ((union _Any_data &) &((struct function *) this)->D.65694._M_functor, (struct _Setter &) (struct type *) std::move<std::__future_base::_State_baseV2::_Setter<void, std::__future_base::_State_baseV2::__exception_ptr_tag>&> ((struct _Setter &) &__f)) >>>>>;
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct function *) this)->_M_invoker = _M_invoke) >>>>>;
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct function *) this)->D.65694._M_manager = _M_manager) >>>>>;
          }
      }
    }
  catch
    {
      std::_Function_base::~_Function_base (&((struct function *) this)->D.65694);
    }
}


;; Function std::function<_Res(_ArgTypes ...)>::function(std::function<_Res(_ArgTypes ...)>&&) [with _Res = std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>; _ArgTypes = {}] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Maybe_unary_or_binary_function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> >::_Maybe_unary_or_binary_function ((struct _Maybe_unary_or_binary_function *) this) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Function_base::_Function_base (&((struct function *) this)->D.65694) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>::swap ((struct function *) __x, (struct function &) (struct function *) this) >>>>>;
    }
  catch
    {
      std::_Function_base::~_Function_base (&((struct function *) this)->D.65694);
    }
}


;; Function std::weak_ptr<_Tp>::weak_ptr(const std::shared_ptr<_Tp1>&) [with _Tp1 = std::__future_base::_State_baseV2; <template-parameter-2-2> = void; _Tp = std::__future_base::_State_baseV2] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__weak_ptr<std::__future_base::_State_baseV2, (__gnu_cxx::_Lock_policy)2u>::__weak_ptr<std::__future_base::_State_baseV2, void> (&((struct weak_ptr *) this)->D.65219, (const struct __shared_ptr &) &((const struct shared_ptr *) __r)->D.69901) >>>>>;
    try
      {
        
      }
    catch
      {
        std::__weak_ptr<std::__future_base::_State_baseV2, (__gnu_cxx::_Lock_policy)2u>::~__weak_ptr (&((struct weak_ptr *) this)->D.65219);
      }
  }
   >>>;


;; Function std::__weak_ptr<_Tp, _Lp>::__weak_ptr(std::__weak_ptr<_Tp, _Lp>&&) [with _Tp = std::__future_base::_State_baseV2; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __weak_ptr *) this)->_M_ptr = __r->_M_ptr) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__weak_count<(__gnu_cxx::_Lock_policy)2u>::__weak_count (&((struct __weak_ptr *) this)->_M_refcount, (struct __weak_count &) (struct type *) std::move<std::__weak_count<(__gnu_cxx::_Lock_policy)2u>&> ((struct __weak_count &) &__r->_M_refcount)) >>>>>;
    try
      {
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__r->_M_ptr = 0B) >>>>>;
      }
    catch
      {
        std::__weak_count<(__gnu_cxx::_Lock_policy)2u>::~__weak_count (&((struct __weak_ptr *) this)->_M_refcount);
      }
  }
   >>>;


;; Function static void std::__future_base::_State_baseV2::_S_check(const std::shared_ptr<_Tp1>&) [with _Tp = std::__future_base::_State_baseV2] (null)
;; enabled by -tree-original


if (<<cleanup_point !std::__shared_ptr<std::__future_base::_State_baseV2, (__gnu_cxx::_Lock_policy)2u>::operator bool (&((const struct shared_ptr *) __p)->D.69901)>>)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_future_error (3) >>>>>;
  }


;; Function constexpr typename std::remove_reference< <template-parameter-1-1> >::type&& std::move(_Tp&&) [with _Tp = std::__future_base::_State_baseV2::_Setter<void, void>&; typename std::remove_reference< <template-parameter-1-1> >::type = std::__future_base::_State_baseV2::_Setter<void, void>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct type &) (struct type *) NON_LVALUE_EXPR <(struct type &) __t>
   >>>;


;; Function std::function<_Res(_ArgTypes ...)>::function(_Functor) [with _Functor = std::__future_base::_State_baseV2::_Setter<void, void>; <template-parameter-2-2> = void; <template-parameter-2-3> = void; _Res = std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>; _ArgTypes = {}] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Maybe_unary_or_binary_function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> >::_Maybe_unary_or_binary_function ((struct _Maybe_unary_or_binary_function *) this) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Function_base::_Function_base (&((struct function *) this)->D.65694) >>>>>;
  try
    {
      {
        typedef struct _My_handler _My_handler;

        if (<<cleanup_point std::_Function_base::_Base_manager<std::__future_base::_State_baseV2::_Setter<void, void> >::_M_not_empty_function<std::__future_base::_State_baseV2::_Setter<void, void> > ((const struct _Setter &) (const struct _Setter *) &__f)>>)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Function_base::_Base_manager<std::__future_base::_State_baseV2::_Setter<void, void> >::_M_init_functor ((union _Any_data &) &((struct function *) this)->D.65694._M_functor, (struct _Setter &) (struct type *) std::move<std::__future_base::_State_baseV2::_Setter<void, void>&> ((struct _Setter &) &__f)) >>>>>;
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct function *) this)->_M_invoker = _M_invoke) >>>>>;
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct function *) this)->D.65694._M_manager = _M_manager) >>>>>;
          }
      }
    }
  catch
    {
      std::_Function_base::~_Function_base (&((struct function *) this)->D.65694);
    }
}


;; Function std::reference_wrapper<_Tp> std::ref(_Tp&) [with _Tp = std::thread] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = TARGET_EXPR <D.92443, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.92443
  (struct reference_wrapper *) <<< Unknown tree: void_cst >>>
  (struct thread &) (struct thread *) __t >>>>;, D.92443>>
   >>>;


;; Function constexpr _Tp&& std::forward(typename std::remove_reference<_From>::type&) [with _Tp = void (std::thread::*)(); typename std::remove_reference<_From>::type = void (std::thread::*)()] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct 
  {
    void thread::<Ta344> (struct thread *) * __pfn;
    long int __delta;
  } &) (struct 
  {
    void thread::<Ta344> (struct thread *) * __pfn;
    long int __delta;
  } *) (struct 
  {
    void thread::<Ta344> (struct thread *) * __pfn;
    long int __delta;
  } &) __t
   >>>;


;; Function constexpr _Tp&& std::forward(typename std::remove_reference<_From>::type&) [with _Tp = std::reference_wrapper<std::thread>; typename std::remove_reference<_From>::type = std::reference_wrapper<std::thread>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct reference_wrapper &) (struct reference_wrapper *) NON_LVALUE_EXPR <(struct reference_wrapper &) __t>
   >>>;


;; Function static constexpr _Head& std::_Head_base<_Idx, _Head, false>::_M_head(std::_Head_base<_Idx, _Head, false>&) [with long unsigned int _Idx = 1ul; _Head = std::reference_wrapper<std::thread>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct reference_wrapper &) &__b->_M_head_impl
   >>>;


;; Function static constexpr _Head& std::_Tuple_impl<_Idx, _Head>::_M_head(std::_Tuple_impl<_Idx, _Head>&) [with long unsigned int _Idx = 1ul; _Head = std::reference_wrapper<std::thread>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct reference_wrapper &) (struct reference_wrapper *) std::_Head_base<1ul, std::reference_wrapper<std::thread>, false>::_M_head ((struct _Head_base &) &((struct _Tuple_impl *) __t)->D.93793)>>
   >>>;


;; Function constexpr std::_Head_base<_Idx, _Head, false>::_Head_base(_UHead&&) [with _UHead = std::reference_wrapper<std::thread>; long unsigned int _Idx = 1ul; _Head = std::reference_wrapper<std::thread>] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Head_base *) this)->_M_head_impl = *(const struct reference_wrapper &) (const struct reference_wrapper *) std::forward<std::reference_wrapper<std::thread> > ((struct type &) (struct reference_wrapper *) __h)) >>>>>;
}


;; Function constexpr std::_Tuple_impl<_Idx, _Head>::_Tuple_impl(std::_Tuple_impl<_Idx, _Head>&&) [with long unsigned int _Idx = 1ul; _Head = std::reference_wrapper<std::thread>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Head_base<1ul, std::reference_wrapper<std::thread>, false>::_Head_base<std::reference_wrapper<std::thread> > (&((struct _Tuple_impl *) this)->D.93793, (struct reference_wrapper &) (struct reference_wrapper *) std::forward<std::reference_wrapper<std::thread> > ((struct type &) (struct reference_wrapper *) std::_Tuple_impl<1ul, std::reference_wrapper<std::thread> >::_M_head ((struct _Tuple_impl &) (struct _Tuple_impl *) __in))) >>>>>;
  }
   >>>;


;; Function static constexpr std::_Tuple_impl<_Idx, _Head, _Tail ...>::_Inherited& std::_Tuple_impl<_Idx, _Head, _Tail ...>::_M_tail(std::_Tuple_impl<_Idx, _Head, _Tail ...>&) [with long unsigned int _Idx = 0ul; _Head = std::_Mem_fn<void (std::thread::*)()>; _Tail = {std::reference_wrapper<std::thread>}; std::_Tuple_impl<_Idx, _Head, _Tail ...>::_Inherited = std::_Tuple_impl<1ul, std::reference_wrapper<std::thread> >] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct _Inherited &) &((struct _Tuple_impl *) __t)->D.94562
   >>>;


;; Function constexpr typename std::remove_reference< <template-parameter-1-1> >::type&& std::move(_Tp&&) [with _Tp = std::_Tuple_impl<1ul, std::reference_wrapper<std::thread> >&; typename std::remove_reference< <template-parameter-1-1> >::type = std::_Tuple_impl<1ul, std::reference_wrapper<std::thread> >] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct type &) (struct type *) NON_LVALUE_EXPR <(struct type &) __t>
   >>>;


;; Function static constexpr _Head& std::_Head_base<_Idx, _Head, false>::_M_head(std::_Head_base<_Idx, _Head, false>&) [with long unsigned int _Idx = 0ul; _Head = std::_Mem_fn<void (std::thread::*)()>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct _Mem_fn &) &__b->_M_head_impl
   >>>;


;; Function static constexpr _Head& std::_Tuple_impl<_Idx, _Head, _Tail ...>::_M_head(std::_Tuple_impl<_Idx, _Head, _Tail ...>&) [with long unsigned int _Idx = 0ul; _Head = std::_Mem_fn<void (std::thread::*)()>; _Tail = {std::reference_wrapper<std::thread>}] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct _Mem_fn &) (struct _Mem_fn *) std::_Head_base<0ul, std::_Mem_fn<void (std::thread::*)()>, false>::_M_head ((struct _Head_base &) &((struct _Tuple_impl *) __t)->D.94563)>>
   >>>;


;; Function constexpr _Tp&& std::forward(typename std::remove_reference<_From>::type&) [with _Tp = std::_Mem_fn<void (std::thread::*)()>; typename std::remove_reference<_From>::type = std::_Mem_fn<void (std::thread::*)()>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct _Mem_fn &) (struct _Mem_fn *) NON_LVALUE_EXPR <(struct _Mem_fn &) __t>
   >>>;


;; Function constexpr std::_Head_base<_Idx, _Head, false>::_Head_base(_UHead&&) [with _UHead = std::_Mem_fn<void (std::thread::*)()>; long unsigned int _Idx = 0ul; _Head = std::_Mem_fn<void (std::thread::*)()>] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Head_base *) this)->_M_head_impl = *(struct _Mem_fn &) (struct _Mem_fn *) std::forward<std::_Mem_fn<void (std::thread::*)()> > ((struct type &) (struct _Mem_fn *) __h)) >>>>>;
}


;; Function constexpr std::_Tuple_impl<_Idx, _Head, _Tail ...>::_Tuple_impl(std::_Tuple_impl<_Idx, _Head, _Tail ...>&&) [with long unsigned int _Idx = 0ul; _Head = std::_Mem_fn<void (std::thread::*)()>; _Tail = {std::reference_wrapper<std::thread>}] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Tuple_impl<1ul, std::reference_wrapper<std::thread> >::_Tuple_impl (&((struct _Tuple_impl *) this)->D.94562, (struct _Tuple_impl &) (struct type *) std::move<std::_Tuple_impl<1ul, std::reference_wrapper<std::thread> >&> ((struct _Tuple_impl &) (struct _Inherited *) std::_Tuple_impl<0ul, std::_Mem_fn<void (std::thread::*)()>, std::reference_wrapper<std::thread> >::_M_tail ((struct _Tuple_impl &) (struct _Tuple_impl *) __in))) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Head_base<0ul, std::_Mem_fn<void (std::thread::*)()>, false>::_Head_base<std::_Mem_fn<void (std::thread::*)()> > (&((struct _Tuple_impl *) this)->D.94563, (struct _Mem_fn &) (struct _Mem_fn *) std::forward<std::_Mem_fn<void (std::thread::*)()> > ((struct type &) (struct _Mem_fn *) std::_Tuple_impl<0ul, std::_Mem_fn<void (std::thread::*)()>, std::reference_wrapper<std::thread> >::_M_head ((struct _Tuple_impl &) (struct _Tuple_impl *) __in))) >>>>>;
  }
   >>>;


;; Function constexpr std::tuple<_T1, _T2>::tuple(std::tuple<_T1, _T2>&&) [with _T1 = std::_Mem_fn<void (std::thread::*)()>; _T2 = std::reference_wrapper<std::thread>] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Tuple_impl<0ul, std::_Mem_fn<void (std::thread::*)()>, std::reference_wrapper<std::thread> >::_Tuple_impl (&((struct tuple *) this)->D.95234, (struct _Tuple_impl &) (struct _Tuple_impl *) NON_LVALUE_EXPR <(struct _Tuple_impl &) &((struct tuple *) D.94612)->D.95234>) >>>>>;
}


;; Function std::_Bind_simple<_Callable(_Args ...)>::_Bind_simple(std::_Bind_simple<_Callable(_Args ...)>&&) [with _Callable = std::_Mem_fn<void (std::thread::*)()>; _Args = {std::reference_wrapper<std::thread>}] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::tuple<std::_Mem_fn<void (std::thread::*)()>, std::reference_wrapper<std::thread> >::tuple (&((struct _Bind_simple *) this)->_M_bound, (struct tuple &) (struct tuple *) NON_LVALUE_EXPR <(struct tuple &) &D.93130->_M_bound>) >>>>>;
}


;; Function void std::call_once(std::once_flag&, _Callable&&, _Args&& ...) [with _Callable = void (std::thread::*)(); _Args = {std::reference_wrapper<std::thread>}] (null)
;; enabled by -tree-original


{
  struct _Bind_simple __bound_functor;
  int __e;

    struct _Bind_simple __bound_functor;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__bound_functor = <<< Unknown tree: aggr_init_expr
  5
  __bind_simple
  D.95630
  (struct 
  {
    void thread::<Ta344> (struct thread *) * __pfn;
    long int __delta;
  } &) (struct 
  {
    void thread::<Ta344> (struct thread *) * __pfn;
    long int __delta;
  } *) std::forward<void (std::thread::*)()> ((struct type &) (struct 
  {
    void thread::<Ta344> (struct thread *) * __pfn;
    long int __delta;
  } *) __f)
  (struct reference_wrapper &) (struct reference_wrapper *) std::forward<std::reference_wrapper<std::thread> > ((struct type &) (struct reference_wrapper *) __args#0) >>>) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__once_callable = (void *) std::__addressof<std::_Bind_simple<std::_Mem_fn<void (std::thread::*)()>(std::reference_wrapper<std::thread>)> > ((struct _Bind_simple &) &__bound_functor)) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__once_call = __once_call_impl) >>>>>;
    int __e;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__e = __gthread_once (&__once->_M_once, __once_proxy)) >>>>>;
  if (__e != 0)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_system_error (__e) >>>>>;
    }
}


;; Function void std::fill(_ForwardIterator, _ForwardIterator, const _Tp&) [with _ForwardIterator = long unsigned int*; _Tp = int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::__fill_a<long unsigned int*, int> (std::__niter_base<long unsigned int*> (__first), std::__niter_base<long unsigned int*> (__last), (const int &) (const int *) __value) >>>>>;


;; Function std::basic_ostream<char, _Traits>& std::operator<<(std::basic_ostream<char, _Traits>&, const char*) [with _Traits = std::char_traits<char>] (null)
;; enabled by -tree-original


if (__s == 0B)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::basic_ios<char>::setstate ((struct basic_ios *) (struct basic_ostream *) __out + (sizetype) *(long int *) (((struct basic_ostream *) __out)->_vptr.basic_ostream + 18446744073709551592), 1) >>>>>;
  }
else
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::__ostream_insert<char, std::char_traits<char> > ((struct basic_ostream &) (struct basic_ostream *) __out, __s, (streamsize) std::char_traits<char>::length (__s)) >>>>>;
  }
return <retval> = (struct basic_ostream &) (struct basic_ostream *) __out;


;; Function std::basic_ostream<_CharT, _Traits>& std::endl(std::basic_ostream<_CharT, _Traits>&) [with _CharT = char; _Traits = std::char_traits<char>] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (struct basic_ostream &) (struct basic_ostream *) std::flush<char, std::char_traits<char> > ((struct basic_ostream &) (struct basic_ostream *) std::basic_ostream<char>::put ((struct basic_ostream *) __os, (int) std::basic_ios<char>::widen ((struct basic_ios *) (struct basic_ostream *) __os + (sizetype) *(long int *) (((struct basic_ostream *) __os)->_vptr.basic_ostream + 18446744073709551592), 10)))>>;


;; Function std::basic_ostream<_CharT, _Traits>::__ostream_type& std::basic_ostream<_CharT, _Traits>::operator<<(std::basic_ostream<_CharT, _Traits>::__ostream_type& (*)(std::basic_ostream<_CharT, _Traits>::__ostream_type&)) [with _CharT = char; _Traits = std::char_traits<char>; std::basic_ostream<_CharT, _Traits>::__ostream_type = std::basic_ostream<char>] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (struct __ostream_type &) (struct __ostream_type *) __pf ((struct __ostream_type &) (struct __ostream_type *) this)>>;


;; Function std::vector<_Tp, _Alloc>::vector() [with _Tp = std::packaged_task<long int(int, int)>; _Alloc = std::allocator<std::packaged_task<long int(int, int)> >] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Vector_base<std::packaged_task<long int(int, int)>, std::allocator<std::packaged_task<long int(int, int)> > >::_Vector_base (&((struct vector *) this)->D.78390) >>>>>;
    try
      {
        
      }
    catch
      {
        std::_Vector_base<std::packaged_task<long int(int, int)>, std::allocator<std::packaged_task<long int(int, int)> > >::~_Vector_base (&((struct vector *) this)->D.78390);
      }
  }
   >>>;


;; Function std::vector<_Tp, _Alloc>::~vector() [with _Tp = std::packaged_task<long int(int, int)>; _Alloc = std::allocator<std::packaged_task<long int(int, int)> >] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    try
      {
        try
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Destroy<std::packaged_task<long int(int, int)>*, std::packaged_task<long int(int, int)> > (((struct vector *) this)->D.78390._M_impl._M_start, ((struct vector *) this)->D.78390._M_impl._M_finish, (struct allocator &) (struct _Tp_alloc_type *) std::_Vector_base<std::packaged_task<long int(int, int)>, std::allocator<std::packaged_task<long int(int, int)> > >::_M_get_Tp_allocator (&((struct vector *) this)->D.78390)) >>>>>;
          }
        finally
          {
            std::_Vector_base<std::packaged_task<long int(int, int)>, std::allocator<std::packaged_task<long int(int, int)> > >::~_Vector_base (&((struct vector *) this)->D.78390);
          }
      }
    finally
      {
        *(struct 
        {
          struct 
          {
            struct _Vector_impl _M_impl;
          } D.78391;
        } &) this = {CLOBBER};
      }
  }
  <D.96582>:;
   >>>;


;; Function std::vector<_Tp, _Alloc>::vector() [with _Tp = std::future<long int>; _Alloc = std::allocator<std::future<long int> >] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Vector_base<std::future<long int>, std::allocator<std::future<long int> > >::_Vector_base (&((struct vector *) this)->D.79511) >>>>>;
    try
      {
        
      }
    catch
      {
        std::_Vector_base<std::future<long int>, std::allocator<std::future<long int> > >::~_Vector_base (&((struct vector *) this)->D.79511);
      }
  }
   >>>;


;; Function std::vector<_Tp, _Alloc>::~vector() [with _Tp = std::future<long int>; _Alloc = std::allocator<std::future<long int> >] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    try
      {
        try
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Destroy<std::future<long int>*, std::future<long int> > (((struct vector *) this)->D.79511._M_impl._M_start, ((struct vector *) this)->D.79511._M_impl._M_finish, (struct allocator &) (struct _Tp_alloc_type *) std::_Vector_base<std::future<long int>, std::allocator<std::future<long int> > >::_M_get_Tp_allocator (&((struct vector *) this)->D.79511)) >>>>>;
          }
        finally
          {
            std::_Vector_base<std::future<long int>, std::allocator<std::future<long int> > >::~_Vector_base (&((struct vector *) this)->D.79511);
          }
      }
    finally
      {
        *(struct 
        {
          struct 
          {
            struct _Vector_impl _M_impl;
          } D.79512;
        } &) this = {CLOBBER};
      }
  }
  <D.96645>:;
   >>>;


;; Function std::vector<_Tp, _Alloc>::vector() [with _Tp = std::thread*; _Alloc = std::allocator<std::thread*>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Vector_base<std::thread*, std::allocator<std::thread*> >::_Vector_base (&((struct vector *) this)->D.80632) >>>>>;
    try
      {
        
      }
    catch
      {
        std::_Vector_base<std::thread*, std::allocator<std::thread*> >::~_Vector_base (&((struct vector *) this)->D.80632);
      }
  }
   >>>;


;; Function std::vector<_Tp, _Alloc>::~vector() [with _Tp = std::thread*; _Alloc = std::allocator<std::thread*>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    try
      {
        try
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Destroy<std::thread**, std::thread*> (((struct vector *) this)->D.80632._M_impl._M_start, ((struct vector *) this)->D.80632._M_impl._M_finish, (struct allocator &) (struct _Tp_alloc_type *) std::_Vector_base<std::thread*, std::allocator<std::thread*> >::_M_get_Tp_allocator (&((struct vector *) this)->D.80632)) >>>>>;
          }
        finally
          {
            std::_Vector_base<std::thread*, std::allocator<std::thread*> >::~_Vector_base (&((struct vector *) this)->D.80632);
          }
      }
    finally
      {
        *(struct 
        {
          struct 
          {
            struct _Vector_impl _M_impl;
          } D.80633;
        } &) this = {CLOBBER};
      }
  }
  <D.96708>:;
   >>>;


;; Function constexpr _Tp&& std::forward(typename std::remove_reference<_From>::type&) [with _Tp = long int (&)(int, int); typename std::remove_reference<_From>::type = long int(int, int)] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (long int (&<T105d3>) (int, int)) (long int (*<T105d2>) (int, int)) (long int (&<T105d3>) (int, int)) (long int (*<T15f42>) (int, int)) __t
   >>>;


;; Function std::packaged_task<_Res(_ArgTypes ...)>::packaged_task(_Fn&&) [with _Fn = long int (&)(int, int); <template-parameter-2-2> = void; _Res = long int; _ArgTypes = {int, int}] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::packaged_task<long int(int, int)>::packaged_task<long int (&)(int, int), std::allocator<int>, void> (this, TARGET_EXPR <D.96913, allocator_arg>;, <<< Unknown tree: empty_class_expr >>>;, (const struct allocator &) (const struct allocator *) &TARGET_EXPR <D.96892, <<< Unknown tree: aggr_init_expr
  4
  __comp_ctor 
  D.96892
  (struct allocator *) <<< Unknown tree: void_cst >>> >>>>, (long int (&<T105d3>) (int, int)) (long int (*<T105d2>) (int, int)) std::forward<long int (&)(int, int)> ((long int (&<T15f36>) (int, int)) (long int (*<T105d2>) (int, int)) __fn)) >>>>>;
  try
    {
      
    }
  catch
    {
      std::packaged_task<long int(int, int)>::~packaged_task (this);
    }
}


;; Function std::__shared_ptr<_Tp, _Lp>::~__shared_ptr() [with _Tp = std::__future_base::_Task_state_base<long int(int, int)>; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


{
  try
    {
      try
        {
          
        }
      finally
        {
          std::__shared_count<>::~__shared_count (&((struct __shared_ptr *) this)->_M_refcount);
        }
    }
  finally
    {
      *(struct 
      {
        struct _Task_state_base * _M_ptr;
        struct __shared_count _M_refcount;
      } &) this = {CLOBBER};
    }
}
<D.96923>:;


;; Function std::shared_ptr<std::__future_base::_Task_state_base<long int(int, int)> >::~shared_ptr() (null)
;; enabled by -tree-original


{
  try
    {
      try
        {
          
        }
      finally
        {
          std::__shared_ptr<std::__future_base::_Task_state_base<long int(int, int)>, (__gnu_cxx::_Lock_policy)2u>::~__shared_ptr (&((struct shared_ptr *) this)->D.82011);
        }
    }
  finally
    {
      *(struct 
      {
        struct 
        {
          struct _Task_state_base * _M_ptr;
          struct __shared_count _M_refcount;
        } D.82012;
      } &) this = {CLOBBER};
    }
}
<D.96921>:;


;; Function constexpr typename std::remove_reference< <template-parameter-1-1> >::type&& std::move(_Tp&&) [with _Tp = std::unique_ptr<std::__future_base::_Result<long int>, std::__future_base::_Result_base::_Deleter>&; typename std::remove_reference< <template-parameter-1-1> >::type = std::unique_ptr<std::__future_base::_Result<long int>, std::__future_base::_Result_base::_Deleter>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct type &) (struct type *) NON_LVALUE_EXPR <(struct type &) __t>
   >>>;


;; Function std::packaged_task<_Res(_ArgTypes ...)>::~packaged_task() [with _Res = long int; _ArgTypes = {int, int}] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    try
      {
        try
          {
            if (<<cleanup_point std::__shared_ptr<std::__future_base::_Task_state_base<long int(int, int)>, (__gnu_cxx::_Lock_policy)2u>::operator bool (&((struct packaged_task *) this)->_M_state.D.82011) && !std::__shared_ptr<std::__future_base::_Task_state_base<long int(int, int)>, (__gnu_cxx::_Lock_policy)2u>::unique (&((struct packaged_task *) this)->_M_state.D.82011)>>)
              {
                <<cleanup_point <<< Unknown tree: expr_stmt
  std::__future_base::_State_baseV2::_M_break_promise (&std::__shared_ptr<std::__future_base::_Task_state_base<long int(int, int)>, (__gnu_cxx::_Lock_policy)2u>::operator-> (&((struct packaged_task *) this)->_M_state.D.82011)->D.98645, &TARGET_EXPR <D.98988, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.98988
  (struct _Ptr_type *) <<< Unknown tree: void_cst >>>
  (struct unique_ptr &) (struct type *) std::move<std::unique_ptr<std::__future_base::_Result<long int>, std::__future_base::_Result_base::_Deleter>&> ((struct unique_ptr &) &std::__shared_ptr<std::__future_base::_Task_state_base<long int(int, int)>, (__gnu_cxx::_Lock_policy)2u>::operator-> (&((struct packaged_task *) this)->_M_state.D.82011)->_M_result) >>>>) >>>>>;
              }
          }
        finally
          {
            std::shared_ptr<std::__future_base::_Task_state_base<long int(int, int)> >::~shared_ptr (&((struct packaged_task *) this)->_M_state);
          }
      }
    finally
      {
        *(struct 
        {
          struct shared_ptr _M_state;
        } &) this = {CLOBBER};
      }
  }
  <D.96919>:;
   >>>;


;; Function constexpr _Tp&& std::forward(typename std::remove_reference<_From>::type&) [with _Tp = std::packaged_task<long int(int, int)>; typename std::remove_reference<_From>::type = std::packaged_task<long int(int, int)>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct packaged_task &) (struct packaged_task *) NON_LVALUE_EXPR <(struct packaged_task &) __t>
   >>>;


;; Function void std::vector<_Tp, _Alloc>::emplace_back(_Args&& ...) [with _Args = {std::packaged_task<long int(int, int)>}; _Tp = std::packaged_task<long int(int, int)>; _Alloc = std::allocator<std::packaged_task<long int(int, int)> >] (null)
;; enabled by -tree-original


if (((struct vector *) this)->D.78390._M_impl._M_finish != ((struct vector *) this)->D.78390._M_impl._M_end_of_storage)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator_traits<std::allocator<std::packaged_task<long int(int, int)> > >::construct<std::packaged_task<long int(int, int)>, std::packaged_task<long int(int, int)> > ((struct allocator_type &) (struct allocator *) &((struct vector *) this)->D.78390._M_impl, ((struct vector *) this)->D.78390._M_impl._M_finish, (struct packaged_task &) (struct packaged_task *) std::forward<std::packaged_task<long int(int, int)> > ((struct type &) (struct packaged_task *) __args#0)) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void)  ++((struct vector *) this)->D.78390._M_impl._M_finish >>>>>;
  }
else
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::vector<std::packaged_task<long int(int, int)> >::_M_emplace_back_aux<std::packaged_task<long int(int, int)> > (this, (struct packaged_task &) (struct packaged_task *) std::forward<std::packaged_task<long int(int, int)> > ((struct type &) (struct packaged_task *) __args#0)) >>>>>;
  }


;; Function std::vector<_Tp, _Alloc>::reference std::vector<_Tp, _Alloc>::operator[](std::vector<_Tp, _Alloc>::size_type) [with _Tp = std::packaged_task<long int(int, int)>; _Alloc = std::allocator<std::packaged_task<long int(int, int)> >; std::vector<_Tp, _Alloc>::reference = std::packaged_task<long int(int, int)>&; std::vector<_Tp, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct value_type &) (((struct vector *) this)->D.78390._M_impl._M_start + (sizetype) (__n * 16))
   >>>;


;; Function std::future<_Res> std::packaged_task<_Res(_ArgTypes ...)>::get_future() [with _Res = long int; _ArgTypes = {int, int}] (null)
;; enabled by -tree-original


<<cleanup_point return *<retval> = TARGET_EXPR <D.99105, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.99105
  (struct future *) <<< Unknown tree: void_cst >>>
  (const struct __state_type &) &TARGET_EXPR <D.99104, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.99104
  (const struct __state_type *) <<< Unknown tree: void_cst >>>
  (const struct shared_ptr &) (const struct shared_ptr *) &((struct packaged_task *) this)->_M_state >>>> >>>>>>;


;; Function constexpr typename std::remove_reference< <template-parameter-1-1> >::type&& std::move(_Tp&&) [with _Tp = std::future<long int>&; typename std::remove_reference< <template-parameter-1-1> >::type = std::future<long int>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct type &) (struct type *) NON_LVALUE_EXPR <(struct type &) __t>
   >>>;


;; Function std::future<_Res>::future(std::future<_Res>&&) [with _Res = long int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__basic_future<long int>::__basic_future (&((struct future *) this)->D.82467, (struct future &) (struct type *) std::move<std::future<long int>&> ((struct future &) (struct future *) __uf)) >>>>>;
    try
      {
        
      }
    catch
      {
        std::__basic_future<long int>::~__basic_future (&((struct future *) this)->D.82467);
      }
  }
   >>>;


;; Function constexpr _Tp&& std::forward(typename std::remove_reference<_From>::type&) [with _Tp = std::future<long int>; typename std::remove_reference<_From>::type = std::future<long int>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct future &) (struct future *) NON_LVALUE_EXPR <(struct future &) __t>
   >>>;


;; Function void std::vector<_Tp, _Alloc>::emplace_back(_Args&& ...) [with _Args = {std::future<long int>}; _Tp = std::future<long int>; _Alloc = std::allocator<std::future<long int> >] (null)
;; enabled by -tree-original


if (((struct vector *) this)->D.79511._M_impl._M_finish != ((struct vector *) this)->D.79511._M_impl._M_end_of_storage)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator_traits<std::allocator<std::future<long int> > >::construct<std::future<long int>, std::future<long int> > ((struct allocator_type &) (struct allocator *) &((struct vector *) this)->D.79511._M_impl, ((struct vector *) this)->D.79511._M_impl._M_finish, (struct future &) (struct future *) std::forward<std::future<long int> > ((struct type &) (struct future *) __args#0)) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void)  ++((struct vector *) this)->D.79511._M_impl._M_finish >>>>>;
  }
else
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::vector<std::future<long int> >::_M_emplace_back_aux<std::future<long int> > (this, (struct future &) (struct future *) std::forward<std::future<long int> > ((struct type &) (struct future *) __args#0)) >>>>>;
  }


;; Function constexpr _Tp&& std::forward(typename std::remove_reference<_From>::type&) [with _Tp = int&; typename std::remove_reference<_From>::type = int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (int &) (int *) (int &) (type *) __t
   >>>;


;; Function constexpr _Tp&& std::forward(typename std::remove_reference<_From>::type&) [with _Tp = int; typename std::remove_reference<_From>::type = int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (int &) (int *) (int &) __t
   >>>;


;; Function std::_Head_base<0ul, std::packaged_task<long int(int, int)>, false>::~_Head_base() (null)
;; enabled by -tree-original


{
  try
    {
      try
        {
          
        }
      finally
        {
          std::packaged_task<long int(int, int)>::~packaged_task (&((struct _Head_base *) this)->_M_head_impl);
        }
    }
  finally
    {
      *(struct 
      {
        struct packaged_task _M_head_impl;
      } &) this = {CLOBBER};
    }
}
<D.102337>:;


;; Function std::_Tuple_impl<0ul, std::packaged_task<long int(int, int)>, int, int>::~_Tuple_impl() (null)
;; enabled by -tree-original


{
  try
    {
      try
        {
          
        }
      finally
        {
          std::_Head_base<0ul, std::packaged_task<long int(int, int)>, false>::~_Head_base (&((struct _Tuple_impl *) this)->D.101576);
        }
    }
  finally
    {
      *(struct 
      {
        struct 
        {
          struct 
          {
            struct 
            {
              int _M_head_impl;
            } D.100102;
          } D.100821;
          struct 
          {
            int _M_head_impl;
          } D.100822;
        } D.101577;
        struct 
        {
          struct packaged_task _M_head_impl;
        } D.101578;
      } &) this = {CLOBBER};
    }
}
<D.102335>:;


;; Function std::tuple<std::packaged_task<long int(int, int)>, int, int>::~tuple() (null)
;; enabled by -tree-original


{
  try
    {
      try
        {
          
        }
      finally
        {
          std::_Tuple_impl<0ul, std::packaged_task<long int(int, int)>, int, int>::~_Tuple_impl (&((struct tuple *) this)->D.102039);
        }
    }
  finally
    {
      *(struct 
      {
        struct 
        {
          struct 
          {
            struct 
            {
              struct 
              {
                int _M_head_impl;
              } D.100102;
            } D.100821;
            struct 
            {
              int _M_head_impl;
            } D.100822;
          } D.101577;
          struct 
          {
            struct packaged_task _M_head_impl;
          } D.101578;
        } D.102040;
      } &) this = {CLOBBER};
    }
}
<D.102333>:;


;; Function std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)>::~_Bind_simple() (null)
;; enabled by -tree-original


{
  try
    {
      try
        {
          
        }
      finally
        {
          std::tuple<std::packaged_task<long int(int, int)>, int, int>::~tuple (&((struct _Bind_simple *) this)->_M_bound);
        }
    }
  finally
    {
      *(struct 
      {
        struct tuple _M_bound;
      } &) this = {CLOBBER};
    }
}
<D.102331>:;


;; Function std::__shared_ptr<_Tp, _Lp>::~__shared_ptr() [with _Tp = std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


{
  try
    {
      try
        {
          
        }
      finally
        {
          std::__shared_count<>::~__shared_count (&((struct __shared_ptr *) this)->_M_refcount);
        }
    }
  finally
    {
      *(struct 
      {
        struct _Impl * _M_ptr;
        struct __shared_count _M_refcount;
      } &) this = {CLOBBER};
    }
}
<D.103694>:;


;; Function std::shared_ptr<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >::~shared_ptr() (null)
;; enabled by -tree-original


{
  try
    {
      try
        {
          
        }
      finally
        {
          std::__shared_ptr<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >, (__gnu_cxx::_Lock_policy)2u>::~__shared_ptr (&((struct shared_ptr *) this)->D.103679);
        }
    }
  finally
    {
      *(struct 
      {
        struct 
        {
          struct _Impl * _M_ptr;
          struct __shared_count _M_refcount;
        } D.103680;
      } &) this = {CLOBBER};
    }
}
<D.103692>:;


;; Function std::thread::thread(_Callable&&, _Args&& ...) [with _Callable = std::packaged_task<long int(int, int)>; _Args = {int&, int}] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::thread::id::id (&((struct thread *) this)->_M_id) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::thread::_M_start_thread (this, &TARGET_EXPR <D.103801, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.103801
  (struct __shared_base_type *) <<< Unknown tree: void_cst >>>
  (struct shared_ptr &) &TARGET_EXPR <D.103681, <<< Unknown tree: aggr_init_expr
  5
  _M_make_routine
  D.103681
  this
  (struct _Bind_simple &) &TARGET_EXPR <D.102320, <<< Unknown tree: aggr_init_expr
  6
  __bind_simple
  D.102320
  (struct packaged_task &) (struct packaged_task *) std::forward<std::packaged_task<long int(int, int)> > ((struct type &) (struct packaged_task *) __f)
  (int &) (int *) std::forward<int&> ((type &) (int *) __args#0)
  (int &) (int *) std::forward<int> ((type &) (int *) __args#1) >>>> >>>> >>>>, (void (*<T791>) (void)) pthread_create) >>>>>;
}


;; Function constexpr typename std::remove_reference< <template-parameter-1-1> >::type&& std::move(_Tp&&) [with _Tp = std::thread*&; typename std::remove_reference< <template-parameter-1-1> >::type = std::thread*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct thread * &) (struct thread * *) (struct thread * &) __t
   >>>;


;; Function void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::thread*; _Alloc = std::allocator<std::thread*>; std::vector<_Tp, _Alloc>::value_type = std::thread*] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::vector<std::thread*>::emplace_back<std::thread*> (this, (struct thread * &) (struct thread * *) std::move<std::thread*&> ((struct thread * &) (struct thread * *) __x)) >>>>>;


;; Function void std::vector<_Tp, _Alloc>::clear() [with _Tp = std::packaged_task<long int(int, int)>; _Alloc = std::allocator<std::packaged_task<long int(int, int)> >] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::vector<std::packaged_task<long int(int, int)> >::_M_erase_at_end (this, ((struct vector *) this)->D.78390._M_impl._M_start) >>>>>
   >>>;


;; Function std::vector<_Tp, _Alloc>::reference std::vector<_Tp, _Alloc>::operator[](std::vector<_Tp, _Alloc>::size_type) [with _Tp = std::thread*; _Alloc = std::allocator<std::thread*>; std::vector<_Tp, _Alloc>::reference = std::thread*&; std::vector<_Tp, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct thread * &) (((struct vector *) this)->D.80632._M_impl._M_start + (sizetype) (__n * 8))
   >>>;


;; Function void std::vector<_Tp, _Alloc>::clear() [with _Tp = std::thread*; _Alloc = std::allocator<std::thread*>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::vector<std::thread*>::_M_erase_at_end (this, ((struct vector *) this)->D.80632._M_impl._M_start) >>>>>
   >>>;


;; Function std::vector<_Tp, _Alloc>::reference std::vector<_Tp, _Alloc>::operator[](std::vector<_Tp, _Alloc>::size_type) [with _Tp = std::future<long int>; _Alloc = std::allocator<std::future<long int> >; std::vector<_Tp, _Alloc>::reference = std::future<long int>&; std::vector<_Tp, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct value_type &) (((struct vector *) this)->D.79511._M_impl._M_start + (sizetype) (__n * 16))
   >>>;


;; Function constexpr typename std::remove_reference< <template-parameter-1-1> >::type&& std::move(_Tp&&) [with _Tp = long int&; typename std::remove_reference< <template-parameter-1-1> >::type = long int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (type &) (type *) (type &) __t
   >>>;


;; Function _Res std::future<_Res>::get() [with _Res = long int] (null)
;; enabled by -tree-original


{
  struct _Reset __reset;

    struct _Reset __reset;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__basic_future<long int>::_Reset::_Reset (&__reset, (struct __basic_future &) &((struct future *) this)->D.82467) >>>>>;
  try
    {
      <<cleanup_point return <retval> = *std::move<long int&> ((long int &) (long int *) std::__future_base::_Result<long int>::_M_value ((struct _Result *) std::__basic_future<long int>::_M_get_result (&((struct future *) this)->D.82467)))>>;
    }
  finally
    {
      std::__basic_future<long int>::_Reset::~_Reset (&__reset);
    }
}


;; Function std::basic_ostream<_CharT, _Traits>::__ostream_type& std::basic_ostream<_CharT, _Traits>::operator<<(long int) [with _CharT = char; _Traits = std::char_traits<char>; std::basic_ostream<_CharT, _Traits>::__ostream_type = std::basic_ostream<char>] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (struct __ostream_type &) (struct basic_ostream *) std::basic_ostream<char>::_M_insert<long int> (this, __n)>>;


;; Function std::basic_ostream<_CharT, _Traits>::__ostream_type& std::basic_ostream<_CharT, _Traits>::operator<<(double) [with _CharT = char; _Traits = std::char_traits<char>; std::basic_ostream<_CharT, _Traits>::__ostream_type = std::basic_ostream<char>] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (struct __ostream_type &) (struct basic_ostream *) std::basic_ostream<char>::_M_insert<double> (this, __f)>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_data() const [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer = char*] (null)
;; enabled by -tree-original


return <retval> = (char *) ((const struct basic_string *) this)->_M_dataplus._M_p;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(_InputIterator, _InputIterator, const _Alloc&) [with _InputIterator = char*; <template-parameter-2-2> = void; _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_Alloc_hider::_Alloc_hider (&((struct basic_string *) this)->_M_dataplus, std::__cxx11::basic_string<char>::_M_local_data (this), (const struct allocator &) (const struct allocator *) __a) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_M_construct<char*> (this, __beg, __end) >>>>>;
    }
  catch
    {
      std::__cxx11::basic_string<char>::_Alloc_hider::~_Alloc_hider (&((struct basic_string *) this)->_M_dataplus);
    }
}


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_dispose() [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>] (null)
;; enabled by -tree-original


if (<<cleanup_point !std::__cxx11::basic_string<char>::_M_is_local (this)>>)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_M_destroy (this, ((struct basic_string *) this)->D.17414._M_allocated_capacity) >>>>>;
  }


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_local_data() [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer = char*] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (char *) std::pointer_traits<char*>::pointer_to ((__type &) (char *) &((struct basic_string *) this)->D.17414._M_local_buf)>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::allocator_type& std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_get_allocator() [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::allocator_type = std::allocator<char>] (null)
;; enabled by -tree-original


return <retval> = (struct allocator_type &) (struct allocator *) &((struct basic_string *) this)->_M_dataplus;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_Alloc_hider::_Alloc_hider(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer = char*] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator<char>::allocator ((struct allocator *) this, (const struct allocator &) (const struct allocator *) __a) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Alloc_hider *) this)->_M_p = __dat) >>>>>;
    }
  catch
    {
      std::allocator<char>::~allocator ((struct allocator *) this);
    }
}


;; Function bool std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_is_local() const [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (const char *) std::__cxx11::basic_string<char>::_M_data (this) == std::__cxx11::basic_string<char>::_M_local_data (this)>>;


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_data(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer = char*] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct basic_string *) this)->_M_dataplus._M_p = __p) >>>>>;


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_capacity(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct basic_string *) this)->D.17414._M_allocated_capacity = __capacity) >>>>>;


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_length(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct basic_string *) this)->_M_string_length = __length) >>>>>;


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_set_length(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_M_length (this, __n) >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  std::char_traits<char>::assign ((char_type &) (std::__cxx11::basic_string<char>::_M_data (this) + (sizetype) NON_LVALUE_EXPR <__n>), (const char_type &) &TARGET_EXPR <D.103931, 0>) >>>>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_data() const [with _CharT = wchar_t; _Traits = std::char_traits<wchar_t>; _Alloc = std::allocator<wchar_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer = wchar_t*] (null)
;; enabled by -tree-original


return <retval> = (wchar_t *) ((const struct basic_string *) this)->_M_dataplus._M_p;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(_InputIterator, _InputIterator, const _Alloc&) [with _InputIterator = wchar_t*; <template-parameter-2-2> = void; _CharT = wchar_t; _Traits = std::char_traits<wchar_t>; _Alloc = std::allocator<wchar_t>] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<wchar_t>::_Alloc_hider::_Alloc_hider (&((struct basic_string *) this)->_M_dataplus, std::__cxx11::basic_string<wchar_t>::_M_local_data (this), (const struct allocator &) (const struct allocator *) __a) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<wchar_t>::_M_construct<wchar_t*> (this, __beg, __end) >>>>>;
    }
  catch
    {
      std::__cxx11::basic_string<wchar_t>::_Alloc_hider::~_Alloc_hider (&((struct basic_string *) this)->_M_dataplus);
    }
}


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_dispose() [with _CharT = wchar_t; _Traits = std::char_traits<wchar_t>; _Alloc = std::allocator<wchar_t>] (null)
;; enabled by -tree-original


if (<<cleanup_point !std::__cxx11::basic_string<wchar_t>::_M_is_local (this)>>)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<wchar_t>::_M_destroy (this, ((struct basic_string *) this)->D.18784._M_allocated_capacity) >>>>>;
  }


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_local_data() [with _CharT = wchar_t; _Traits = std::char_traits<wchar_t>; _Alloc = std::allocator<wchar_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer = wchar_t*] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (wchar_t *) std::pointer_traits<wchar_t*>::pointer_to ((__type &) (wchar_t *) &((struct basic_string *) this)->D.18784._M_local_buf)>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::allocator_type& std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_get_allocator() [with _CharT = wchar_t; _Traits = std::char_traits<wchar_t>; _Alloc = std::allocator<wchar_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::allocator_type = std::allocator<wchar_t>] (null)
;; enabled by -tree-original


return <retval> = (struct allocator_type &) (struct allocator *) &((struct basic_string *) this)->_M_dataplus;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_Alloc_hider::_Alloc_hider(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer, const _Alloc&) [with _CharT = wchar_t; _Traits = std::char_traits<wchar_t>; _Alloc = std::allocator<wchar_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer = wchar_t*] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator<wchar_t>::allocator ((struct allocator *) this, (const struct allocator &) (const struct allocator *) __a) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Alloc_hider *) this)->_M_p = __dat) >>>>>;
    }
  catch
    {
      std::allocator<wchar_t>::~allocator ((struct allocator *) this);
    }
}


;; Function bool std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_is_local() const [with _CharT = wchar_t; _Traits = std::char_traits<wchar_t>; _Alloc = std::allocator<wchar_t>] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (const wchar_t *) std::__cxx11::basic_string<wchar_t>::_M_data (this) == std::__cxx11::basic_string<wchar_t>::_M_local_data (this)>>;


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_data(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer) [with _CharT = wchar_t; _Traits = std::char_traits<wchar_t>; _Alloc = std::allocator<wchar_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer = wchar_t*] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct basic_string *) this)->_M_dataplus._M_p = __p) >>>>>;


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_capacity(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type) [with _CharT = wchar_t; _Traits = std::char_traits<wchar_t>; _Alloc = std::allocator<wchar_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct basic_string *) this)->D.18784._M_allocated_capacity = __capacity) >>>>>;


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_length(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type) [with _CharT = wchar_t; _Traits = std::char_traits<wchar_t>; _Alloc = std::allocator<wchar_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct basic_string *) this)->_M_string_length = __length) >>>>>;


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_set_length(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type) [with _CharT = wchar_t; _Traits = std::char_traits<wchar_t>; _Alloc = std::allocator<wchar_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<wchar_t>::_M_length (this, __n) >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  std::char_traits<wchar_t>::assign ((char_type &) (std::__cxx11::basic_string<wchar_t>::_M_data (this) + (sizetype) (__n * 4)), (const char_type &) &TARGET_EXPR <D.103981, 0>) >>>>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_data() const [with _CharT = char16_t; _Traits = std::char_traits<char16_t>; _Alloc = std::allocator<char16_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer = char16_t*] (null)
;; enabled by -tree-original


return <retval> = (char16_t *) ((const struct basic_string *) this)->_M_dataplus._M_p;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_data() const [with _CharT = char32_t; _Traits = std::char_traits<char32_t>; _Alloc = std::allocator<char32_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer = char32_t*] (null)
;; enabled by -tree-original


return <retval> = (char32_t *) ((const struct basic_string *) this)->_M_dataplus._M_p;


;; Function __gnu_cxx::new_allocator<_Tp>::new_allocator() [with _Tp = char] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    
  }
   >>>;


;; Function __gnu_cxx::new_allocator<_Tp>::~new_allocator() [with _Tp = char] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    
  }
  <D.103988>:;
   >>>;


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_construct(_InIterator, _InIterator) [with _InIterator = const char*; _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>] (null)
;; enabled by -tree-original


{
  typedef struct _Integral _Integral;

  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_M_construct_aux<const char*> (this, __beg, __end, TARGET_EXPR <D.104026, {}>;, <<< Unknown tree: empty_class_expr >>>;) >>>>>;
}


;; Function __gnu_cxx::new_allocator<_Tp>::new_allocator() [with _Tp = wchar_t] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    
  }
   >>>;


;; Function __gnu_cxx::new_allocator<_Tp>::~new_allocator() [with _Tp = wchar_t] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    
  }
  <D.104069>:;
   >>>;


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_construct(_InIterator, _InIterator) [with _InIterator = const wchar_t*; _CharT = wchar_t; _Traits = std::char_traits<wchar_t>; _Alloc = std::allocator<wchar_t>] (null)
;; enabled by -tree-original


{
  typedef struct _Integral _Integral;

  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<wchar_t>::_M_construct_aux<const wchar_t*> (this, __beg, __end, TARGET_EXPR <D.104083, {}>;, <<< Unknown tree: empty_class_expr >>>;) >>>>>;
}


;; Function __gnu_cxx::new_allocator<_Tp>::new_allocator() [with _Tp = char16_t] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    
  }
   >>>;


;; Function __gnu_cxx::new_allocator<_Tp>::~new_allocator() [with _Tp = char16_t] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    
  }
  <D.104093>:;
   >>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_local_data() [with _CharT = char16_t; _Traits = std::char_traits<char16_t>; _Alloc = std::allocator<char16_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer = char16_t*] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (char16_t *) std::pointer_traits<char16_t*>::pointer_to ((__type &) (char16_t *) &((struct basic_string *) this)->D.20554._M_local_buf)>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_Alloc_hider::_Alloc_hider(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer, const _Alloc&) [with _CharT = char16_t; _Traits = std::char_traits<char16_t>; _Alloc = std::allocator<char16_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer = char16_t*] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator<char16_t>::allocator ((struct allocator *) this, (const struct allocator &) (const struct allocator *) __a) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Alloc_hider *) this)->_M_p = __dat) >>>>>;
    }
  catch
    {
      std::allocator<char16_t>::~allocator ((struct allocator *) this);
    }
}


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_construct(_InIterator, _InIterator) [with _InIterator = const char16_t*; _CharT = char16_t; _Traits = std::char_traits<char16_t>; _Alloc = std::allocator<char16_t>] (null)
;; enabled by -tree-original


{
  typedef struct _Integral _Integral;

  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char16_t>::_M_construct_aux<const char16_t*> (this, __beg, __end, TARGET_EXPR <D.104141, {}>;, <<< Unknown tree: empty_class_expr >>>;) >>>>>;
}


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_dispose() [with _CharT = char16_t; _Traits = std::char_traits<char16_t>; _Alloc = std::allocator<char16_t>] (null)
;; enabled by -tree-original


if (<<cleanup_point !std::__cxx11::basic_string<char16_t>::_M_is_local (this)>>)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char16_t>::_M_destroy (this, ((struct basic_string *) this)->D.20554._M_allocated_capacity) >>>>>;
  }


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::allocator_type& std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_get_allocator() [with _CharT = char16_t; _Traits = std::char_traits<char16_t>; _Alloc = std::allocator<char16_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::allocator_type = std::allocator<char16_t>] (null)
;; enabled by -tree-original


return <retval> = (struct allocator_type &) (struct allocator *) &((struct basic_string *) this)->_M_dataplus;


;; Function bool std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_is_local() const [with _CharT = char16_t; _Traits = std::char_traits<char16_t>; _Alloc = std::allocator<char16_t>] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (const char16_t *) std::__cxx11::basic_string<char16_t>::_M_data (this) == std::__cxx11::basic_string<char16_t>::_M_local_data (this)>>;


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_data(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer) [with _CharT = char16_t; _Traits = std::char_traits<char16_t>; _Alloc = std::allocator<char16_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer = char16_t*] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct basic_string *) this)->_M_dataplus._M_p = __p) >>>>>;


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_capacity(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type) [with _CharT = char16_t; _Traits = std::char_traits<char16_t>; _Alloc = std::allocator<char16_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct basic_string *) this)->D.20554._M_allocated_capacity = __capacity) >>>>>;


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_length(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type) [with _CharT = char16_t; _Traits = std::char_traits<char16_t>; _Alloc = std::allocator<char16_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct basic_string *) this)->_M_string_length = __length) >>>>>;


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_set_length(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type) [with _CharT = char16_t; _Traits = std::char_traits<char16_t>; _Alloc = std::allocator<char16_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char16_t>::_M_length (this, __n) >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  std::char_traits<char16_t>::assign ((char_type &) (std::__cxx11::basic_string<char16_t>::_M_data (this) + (sizetype) (__n * 2)), (const char_type &) &TARGET_EXPR <D.104154, 0>) >>>>>;


;; Function __gnu_cxx::new_allocator<_Tp>::new_allocator() [with _Tp = char32_t] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    
  }
   >>>;


;; Function __gnu_cxx::new_allocator<_Tp>::~new_allocator() [with _Tp = char32_t] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    
  }
  <D.104159>:;
   >>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_local_data() [with _CharT = char32_t; _Traits = std::char_traits<char32_t>; _Alloc = std::allocator<char32_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer = char32_t*] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (char32_t *) std::pointer_traits<char32_t*>::pointer_to ((__type &) (char32_t *) &((struct basic_string *) this)->D.21840._M_local_buf)>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_Alloc_hider::_Alloc_hider(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer, const _Alloc&) [with _CharT = char32_t; _Traits = std::char_traits<char32_t>; _Alloc = std::allocator<char32_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer = char32_t*] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator<char32_t>::allocator ((struct allocator *) this, (const struct allocator &) (const struct allocator *) __a) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Alloc_hider *) this)->_M_p = __dat) >>>>>;
    }
  catch
    {
      std::allocator<char32_t>::~allocator ((struct allocator *) this);
    }
}


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_construct(_InIterator, _InIterator) [with _InIterator = const char32_t*; _CharT = char32_t; _Traits = std::char_traits<char32_t>; _Alloc = std::allocator<char32_t>] (null)
;; enabled by -tree-original


{
  typedef struct _Integral _Integral;

  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char32_t>::_M_construct_aux<const char32_t*> (this, __beg, __end, TARGET_EXPR <D.104207, {}>;, <<< Unknown tree: empty_class_expr >>>;) >>>>>;
}


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_dispose() [with _CharT = char32_t; _Traits = std::char_traits<char32_t>; _Alloc = std::allocator<char32_t>] (null)
;; enabled by -tree-original


if (<<cleanup_point !std::__cxx11::basic_string<char32_t>::_M_is_local (this)>>)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char32_t>::_M_destroy (this, ((struct basic_string *) this)->D.21840._M_allocated_capacity) >>>>>;
  }


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::allocator_type& std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_get_allocator() [with _CharT = char32_t; _Traits = std::char_traits<char32_t>; _Alloc = std::allocator<char32_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::allocator_type = std::allocator<char32_t>] (null)
;; enabled by -tree-original


return <retval> = (struct allocator_type &) (struct allocator *) &((struct basic_string *) this)->_M_dataplus;


;; Function bool std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_is_local() const [with _CharT = char32_t; _Traits = std::char_traits<char32_t>; _Alloc = std::allocator<char32_t>] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (const char32_t *) std::__cxx11::basic_string<char32_t>::_M_data (this) == std::__cxx11::basic_string<char32_t>::_M_local_data (this)>>;


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_data(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer) [with _CharT = char32_t; _Traits = std::char_traits<char32_t>; _Alloc = std::allocator<char32_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer = char32_t*] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct basic_string *) this)->_M_dataplus._M_p = __p) >>>>>;


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_capacity(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type) [with _CharT = char32_t; _Traits = std::char_traits<char32_t>; _Alloc = std::allocator<char32_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct basic_string *) this)->D.21840._M_allocated_capacity = __capacity) >>>>>;


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_length(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type) [with _CharT = char32_t; _Traits = std::char_traits<char32_t>; _Alloc = std::allocator<char32_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct basic_string *) this)->_M_string_length = __length) >>>>>;


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_set_length(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type) [with _CharT = char32_t; _Traits = std::char_traits<char32_t>; _Alloc = std::allocator<char32_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char32_t>::_M_length (this, __n) >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  std::char_traits<char32_t>::assign ((char_type &) (std::__cxx11::basic_string<char32_t>::_M_data (this) + (sizetype) (__n * 4)), (const char_type &) &TARGET_EXPR <D.104220, 0>) >>>>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_Alloc_hider::_Alloc_hider (&((struct basic_string *) this)->_M_dataplus, std::__cxx11::basic_string<char>::_M_local_data (this), (const struct allocator &) (const struct allocator_type *) std::__cxx11::basic_string<char>::_M_get_allocator ((const struct basic_string *) __str)) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_M_construct<char*> (this, std::__cxx11::basic_string<char>::_M_data ((const struct basic_string *) __str), std::__cxx11::basic_string<char>::_M_data ((const struct basic_string *) __str) + (sizetype) std::__cxx11::basic_string<char>::length ((const struct basic_string *) __str)) >>>>>;
    }
  catch
    {
      std::__cxx11::basic_string<char>::_Alloc_hider::~_Alloc_hider (&((struct basic_string *) this)->_M_dataplus);
    }
}


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>& std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::append(const _CharT*) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>] (null)
;; enabled by -tree-original


{
  const size_type __n;

    const size_type __n;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__n = std::char_traits<char>::length (__s)) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_M_check_length (this, 0, (size_type) __n, (const char *) "basic_string::append") >>>>>;
  <<cleanup_point return <retval> = (struct basic_string &) (struct basic_string *) std::__cxx11::basic_string<char>::_M_append (this, __s, (size_type) __n)>>;
}


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size() const [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (size_type) ((const struct basic_string *) this)->_M_string_length
   >>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::capacity() const [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::__cxx11::basic_string<char>::_M_is_local (this) ? 15 : (size_type) ((const struct basic_string *) this)->D.17414._M_allocated_capacity>>
   >>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>& std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::insert(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (struct basic_string &) (struct basic_string *) std::__cxx11::basic_string<char>::replace (this, __pos1, 0, (const char *) std::__cxx11::basic_string<char>::_M_data ((const struct basic_string *) __str), std::__cxx11::basic_string<char>::size ((const struct basic_string *) __str))>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>& std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::append(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (struct basic_string &) (struct basic_string *) std::__cxx11::basic_string<char>::_M_append (this, (const char *) std::__cxx11::basic_string<char>::_M_data ((const struct basic_string *) __str), std::__cxx11::basic_string<char>::size ((const struct basic_string *) __str))>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>& std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::insert(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, const _CharT*) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (struct basic_string &) (struct basic_string *) std::__cxx11::basic_string<char>::replace (this, __pos, 0, __s, std::char_traits<char>::length (__s))>>;


;; Function std::_Sp_counted_base<_Lp>::~_Sp_counted_base() [with __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)0u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Sp_counted_base *) this)->_vptr._Sp_counted_base = &_ZTVSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EE + 16) >>>>>;
    try
      {
        
      }
    finally
      {
        *(struct 
        {
          int (*__vtbl_ptr_type) () * _vptr._Sp_counted_base;
          _Atomic_word _M_use_count;
          _Atomic_word _M_weak_count;
        } &) this = {CLOBBER};
      }
  }
  <D.104232>:;
  if ((__in_chrg & 1) != 0)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  operator delete ((void *) this, 16) >>>>>;
    }
   >>>;


;; Function void std::_Sp_counted_base<_Lp>::_M_release() [with __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  if (<<cleanup_point __gnu_cxx::__exchange_and_add_dispatch (&((struct _Sp_counted_base *) this)->_M_use_count, -1) == 1>>)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  OBJ_TYPE_REF(*(((struct _Sp_counted_base *) this)->_vptr._Sp_counted_base + 16);(struct _Sp_counted_base)this->2) (this) >>>>>;
      if (0)
        {
          <<cleanup_point __asm__ __volatile__("":::"memory")>>;
          <<cleanup_point __asm__ __volatile__("":::"memory")>>;
        }
      if (<<cleanup_point __gnu_cxx::__exchange_and_add_dispatch (&((struct _Sp_counted_base *) this)->_M_weak_count, -1) == 1>>)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  OBJ_TYPE_REF(*(((struct _Sp_counted_base *) this)->_vptr._Sp_counted_base + 24);(struct _Sp_counted_base)this->3) (this) >>>>>;
        }
    }
   >>>;


;; Function std::allocator< <template-parameter-1-1> >::allocator() [with _Tp = std::mutex] (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<std::mutex>::new_allocator ((struct new_allocator *) this) >>>>>;
    try
      {
        
      }
    catch
      {
        __gnu_cxx::new_allocator<std::mutex>::~new_allocator ((struct new_allocator *) this);
      }
  }
   >>>;


;; Function std::allocator< <template-parameter-1-1> >::~allocator() [with _Tp = std::mutex] (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  {
    try
      {
        
      }
    finally
      {
        __gnu_cxx::new_allocator<std::mutex>::~new_allocator ((struct new_allocator *) this);
      }
  }
  <D.104254>:;
   >>>;


;; Function std::shared_ptr<_Tp1> std::allocate_shared(const _Alloc&, _Args&& ...) [with _Tp = std::mutex; _Alloc = std::allocator<std::mutex>; _Args = {}] (null)
;; enabled by -tree-original


<<cleanup_point return *<retval> = TARGET_EXPR <D.104680, <<< Unknown tree: aggr_init_expr
  6
  __comp_ctor 
  D.104680
  (struct shared_ptr *) <<< Unknown tree: void_cst >>>
  TARGET_EXPR <D.104261, {}>;, <<< Unknown tree: empty_class_expr >>>;
  (const struct allocator &) (const struct allocator *) __a >>>>>>;


;; Function std::__shared_ptr<_Tp, _Lp>::__shared_ptr(std::__shared_ptr<_Tp, _Lp>&&) [with _Tp = std::mutex; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __shared_ptr *) this)->_M_ptr = __r->_M_ptr) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __shared_ptr *) this)->_M_refcount = <<< Unknown tree: aggr_init_expr
  4
  __comp_ctor 
  D.104682
  (struct __shared_count *) <<< Unknown tree: void_cst >>> >>>) >>>>>;
    try
      {
        <<cleanup_point <<< Unknown tree: expr_stmt
  std::__shared_count<>::_M_swap (&((struct __shared_ptr *) this)->_M_refcount, (struct __shared_count &) &__r->_M_refcount) >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__r->_M_ptr = 0B) >>>>>;
      }
    catch
      {
        std::__shared_count<>::~__shared_count (&((struct __shared_ptr *) this)->_M_refcount);
      }
  }
   >>>;


;; Function static constexpr _Head& std::_Head_base<_Idx, _Head, true>::_M_head(std::_Head_base<_Idx, _Head, true>&) [with long unsigned int _Idx = 1ul; _Head = std::__future_base::_Result_base::_Deleter] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct _Deleter &) (struct _Deleter *) (struct _Head_base *) __b
   >>>;


;; Function static constexpr _Head& std::_Tuple_impl<_Idx, _Head>::_M_head(std::_Tuple_impl<_Idx, _Head>&) [with long unsigned int _Idx = 1ul; _Head = std::__future_base::_Result_base::_Deleter] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct _Deleter &) (struct _Deleter *) std::_Head_base<1ul, std::__future_base::_Result_base::_Deleter, true>::_M_head ((struct _Head_base &) (struct _Head_base *) (struct _Tuple_impl *) __t)>>
   >>>;


;; Function constexpr _Head& std::__get_helper(std::_Tuple_impl<_Idx, _Head, _Tail ...>&) [with long unsigned int __i = 1ul; _Head = std::__future_base::_Result_base::_Deleter; _Tail = {}] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct _Deleter &) (struct _Deleter *) std::_Tuple_impl<1ul, std::__future_base::_Result_base::_Deleter>::_M_head ((struct _Tuple_impl &) (struct _Tuple_impl *) __t)>>
   >>>;


;; Function constexpr std::__tuple_element_t<__i, std::tuple<_Elements ...> >& std::get(std::tuple<_Elements ...>&) [with long unsigned int __i = 1ul; _Elements = {std::__future_base::_Result_base*, std::__future_base::_Result_base::_Deleter}; std::__tuple_element_t<__i, std::tuple<_Elements ...> > = std::__future_base::_Result_base::_Deleter] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct __tuple_element_t &) (struct _Deleter *) std::__get_helper<1ul, std::__future_base::_Result_base::_Deleter> ((struct _Tuple_impl &) (struct _Tuple_impl *) (struct tuple *) __t)>>
   >>>;


;; Function std::unique_ptr<_Tp, _Dp>::deleter_type& std::unique_ptr<_Tp, _Dp>::get_deleter() [with _Tp = std::__future_base::_Result_base; _Dp = std::__future_base::_Result_base::_Deleter; std::unique_ptr<_Tp, _Dp>::deleter_type = std::__future_base::_Result_base::_Deleter] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct deleter_type &) (struct __tuple_element_t *) std::get<1ul, std::__future_base::_Result_base*, std::__future_base::_Result_base::_Deleter> ((struct tuple &) &((struct unique_ptr *) this)->_M_t)>>
   >>>;


;; Function unsigned int std::__atomic_futex_unsigned<_Waiter_bit>::_M_load(std::memory_order) [with unsigned int _Waiter_bit = 2147483648u; std::memory_order = std::memory_order] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = std::__atomic_base<unsigned int>::load (&((struct __atomic_futex_unsigned *) this)->_M_data.D.56070, __mo) & 2147483647>>;


;; Function constexpr std::chrono::duration<_Rep, _Period>::duration() [with _Rep = long int; _Period = std::ratio<1l>] (null)
;; enabled by -tree-original


{
  
}


;; Function constexpr std::chrono::duration<_Rep, _Period>::duration() [with _Rep = long int; _Period = std::ratio<1l, 1000000000l>] (null)
;; enabled by -tree-original


{
  
}


;; Function unsigned int std::__atomic_futex_unsigned<_Waiter_bit>::_M_load_and_test(unsigned int, unsigned int, bool, std::memory_order) [with unsigned int _Waiter_bit = 2147483648u; std::memory_order = std::memory_order] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = std::__atomic_futex_unsigned<>::_M_load_and_test_until (this, __assumed, __operand, (int) __equal, __mo, 0, TARGET_EXPR <D.104720, {.__r=0}>, TARGET_EXPR <D.104725, {.__r=0}>)>>;


;; Function static constexpr const _Head& std::_Head_base<_Idx, _Head, false>::_M_head(const std::_Head_base<_Idx, _Head, false>&) [with long unsigned int _Idx = 0ul; _Head = std::__future_base::_Result_base*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct _Result_base * const &) &__b->_M_head_impl
   >>>;


;; Function static constexpr const _Head& std::_Tuple_impl<_Idx, _Head, _Tail ...>::_M_head(const std::_Tuple_impl<_Idx, _Head, _Tail ...>&) [with long unsigned int _Idx = 0ul; _Head = std::__future_base::_Result_base*; _Tail = {std::__future_base::_Result_base::_Deleter}] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct _Result_base * const &) (struct _Result_base * const *) std::_Head_base<0ul, std::__future_base::_Result_base*, false>::_M_head ((const struct _Head_base &) &((const struct _Tuple_impl *) __t)->D.63461)>>
   >>>;


;; Function constexpr const _Head& std::__get_helper(const std::_Tuple_impl<_Idx, _Head, _Tail ...>&) [with long unsigned int __i = 0ul; _Head = std::__future_base::_Result_base*; _Tail = {std::__future_base::_Result_base::_Deleter}] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct _Result_base * const &) (struct _Result_base * const *) std::_Tuple_impl<0ul, std::__future_base::_Result_base*, std::__future_base::_Result_base::_Deleter>::_M_head ((const struct _Tuple_impl &) (const struct _Tuple_impl *) __t)>>
   >>>;


;; Function constexpr std::__tuple_element_t<__i, std::tuple<_Elements ...> >& std::get(const std::tuple<_Elements ...>&) [with long unsigned int __i = 0ul; _Elements = {std::__future_base::_Result_base*, std::__future_base::_Result_base::_Deleter}; std::__tuple_element_t<__i, std::tuple<_Elements ...> > = std::__future_base::_Result_base*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct _Result_base * const &) (struct _Result_base * const *) std::__get_helper<0ul, std::__future_base::_Result_base*, std::__future_base::_Result_base::_Deleter> ((const struct _Tuple_impl &) &((const struct tuple *) __t)->D.64132)>>
   >>>;


;; Function std::unique_ptr<_Tp, _Dp>::pointer std::unique_ptr<_Tp, _Dp>::get() const [with _Tp = std::__future_base::_Result_base; _Dp = std::__future_base::_Result_base::_Deleter; std::unique_ptr<_Tp, _Dp>::pointer = std::__future_base::_Result_base*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct _Result_base *) *std::get<0ul, std::__future_base::_Result_base*, std::__future_base::_Result_base::_Deleter> ((const struct tuple &) &((const struct unique_ptr *) this)->_M_t)>>
   >>>;


;; Function typename std::_Bind_simple_helper<_Func, _BoundArgs>::__type std::__bind_simple(_Callable&&, _Args&& ...) [with _Callable = void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*); _Args = {std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*}; typename std::_Bind_simple_helper<_Func, _BoundArgs>::__type = std::_Bind_simple<std::_Mem_fn<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)>(std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)>] (null)
;; enabled by -tree-original


{
  typedef struct __helper_type __helper_type;
  typedef struct __maybe_type __maybe_type;
  typedef struct __result_type __result_type;

  <<cleanup_point return *<retval> = TARGET_EXPR <D.104754, <<< Unknown tree: aggr_init_expr
  8
  __comp_ctor 
  D.104754
  (struct _Bind_simple *) <<< Unknown tree: void_cst >>>
  (struct _Mem_fn &) &TARGET_EXPR <D.104735, std::_Maybe_wrap_member_pointer<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)>::__do_wrap (*std::forward<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)> ((struct type &) (struct 
  {
    void _State_baseV2::<Tc8fa> (struct _State_baseV2 *, struct function *, bool *) * __pfn;
    long int __delta;
  } *) __callable))>
  (struct _State_baseV2 * &) (struct _State_baseV2 * *) std::forward<std::__future_base::_State_baseV2*> ((struct _State_baseV2 * &) (struct _State_baseV2 * *) __args#0)
  (struct function * &) (struct function * *) std::forward<std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*> ((struct function * &) (struct function * *) __args#1)
  (bool * &) (bool * *) std::forward<bool*> ((bool * &) (bool * *) __args#2) >>>>>>;
}


;; Function _Tp* std::__addressof(_Tp&) [with _Tp = std::_Bind_simple<std::_Mem_fn<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)>(std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct _Bind_simple *) __r
   >>>;


;; Function void std::__once_call_impl() [with _Callable = std::_Bind_simple<std::_Mem_fn<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)>(std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)>] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::_Bind_simple<std::_Mem_fn<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)>(std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)>::operator() ((struct _Bind_simple *) __once_callable) >>>>>;


;; Function std::__atomic_base<_IntTp>::__int_type std::__atomic_base<_IntTp>::exchange(std::__atomic_base<_IntTp>::__int_type, std::memory_order) [with _ITp = unsigned int; std::__atomic_base<_IntTp>::__int_type = unsigned int; std::memory_order = std::memory_order] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = __atomic_exchange_4 ((volatile void *) &((struct __atomic_base *) this)->_M_i, __i, (int) __m)>>
   >>>;


;; Function void std::_Sp_counted_base<_Lp>::_M_weak_release() [with __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  if (<<cleanup_point __gnu_cxx::__exchange_and_add_dispatch (&((struct _Sp_counted_base *) this)->_M_weak_count, -1) == 1>>)
    {
      if (0)
        {
          <<cleanup_point __asm__ __volatile__("":::"memory")>>;
          <<cleanup_point __asm__ __volatile__("":::"memory")>>;
        }
      <<cleanup_point <<< Unknown tree: expr_stmt
  OBJ_TYPE_REF(*(((struct _Sp_counted_base *) this)->_vptr._Sp_counted_base + 24);(struct _Sp_counted_base)this->3) (this) >>>>>;
    }
   >>>;


;; Function static constexpr _Head& std::_Head_base<_Idx, _Head, true>::_M_head(std::_Head_base<_Idx, _Head, true>&) [with long unsigned int _Idx = 1ul; _Head = std::default_delete<std::__future_base::_State_baseV2::_Make_ready>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct default_delete &) (struct default_delete *) (struct _Head_base *) __b
   >>>;


;; Function static constexpr _Head& std::_Tuple_impl<_Idx, _Head>::_M_head(std::_Tuple_impl<_Idx, _Head>&) [with long unsigned int _Idx = 1ul; _Head = std::default_delete<std::__future_base::_State_baseV2::_Make_ready>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct default_delete &) (struct default_delete *) std::_Head_base<1ul, std::default_delete<std::__future_base::_State_baseV2::_Make_ready>, true>::_M_head ((struct _Head_base &) (struct _Head_base *) (struct _Tuple_impl *) __t)>>
   >>>;


;; Function constexpr _Head& std::__get_helper(std::_Tuple_impl<_Idx, _Head, _Tail ...>&) [with long unsigned int __i = 1ul; _Head = std::default_delete<std::__future_base::_State_baseV2::_Make_ready>; _Tail = {}] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct default_delete &) (struct default_delete *) std::_Tuple_impl<1ul, std::default_delete<std::__future_base::_State_baseV2::_Make_ready> >::_M_head ((struct _Tuple_impl &) (struct _Tuple_impl *) __t)>>
   >>>;


;; Function constexpr std::__tuple_element_t<__i, std::tuple<_Elements ...> >& std::get(std::tuple<_Elements ...>&) [with long unsigned int __i = 1ul; _Elements = {std::__future_base::_State_baseV2::_Make_ready*, std::default_delete<std::__future_base::_State_baseV2::_Make_ready>}; std::__tuple_element_t<__i, std::tuple<_Elements ...> > = std::default_delete<std::__future_base::_State_baseV2::_Make_ready>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct __tuple_element_t &) (struct default_delete *) std::__get_helper<1ul, std::default_delete<std::__future_base::_State_baseV2::_Make_ready> > ((struct _Tuple_impl &) (struct _Tuple_impl *) (struct tuple *) __t)>>
   >>>;


;; Function std::unique_ptr<_Tp, _Dp>::deleter_type& std::unique_ptr<_Tp, _Dp>::get_deleter() [with _Tp = std::__future_base::_State_baseV2::_Make_ready; _Dp = std::default_delete<std::__future_base::_State_baseV2::_Make_ready>; std::unique_ptr<_Tp, _Dp>::deleter_type = std::default_delete<std::__future_base::_State_baseV2::_Make_ready>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct deleter_type &) (struct __tuple_element_t *) std::get<1ul, std::__future_base::_State_baseV2::_Make_ready*, std::default_delete<std::__future_base::_State_baseV2::_Make_ready> > ((struct tuple &) &((struct unique_ptr *) this)->_M_t)>>
   >>>;


;; Function std::__future_base::_State_baseV2::_Make_ready::~_Make_ready() (null)
;; enabled by -tree-original


{
  try
    {
      try
        {
          
        }
      finally
        {
          std::weak_ptr<std::__future_base::_State_baseV2>::~weak_ptr (&((struct _Make_ready *) this)->_M_shared_state);
        }
    }
  finally
    {
      *(struct 
      {
        struct __at_thread_exit_elt D.65275;
        struct weak_ptr _M_shared_state;
      } &) this = {CLOBBER};
    }
}
<D.104793>:;


;; Function void std::default_delete<_Tp>::operator()(_Tp*) const [with _Tp = std::__future_base::_State_baseV2::_Make_ready] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  if (SAVE_EXPR <__ptr> != 0B)
    {
      std::__future_base::_State_baseV2::_Make_ready::~_Make_ready (SAVE_EXPR <__ptr>);, operator delete ((void *) SAVE_EXPR <__ptr>, 32);;
    }
  else
    {
      <<< Unknown tree: void_cst >>>
    } >>>>>;


;; Function static constexpr const _Head& std::_Head_base<_Idx, _Head, false>::_M_head(const std::_Head_base<_Idx, _Head, false>&) [with long unsigned int _Idx = 0ul; _Head = std::__future_base::_State_baseV2::_Make_ready*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct _Make_ready * const &) &__b->_M_head_impl
   >>>;


;; Function static constexpr const _Head& std::_Tuple_impl<_Idx, _Head, _Tail ...>::_M_head(const std::_Tuple_impl<_Idx, _Head, _Tail ...>&) [with long unsigned int _Idx = 0ul; _Head = std::__future_base::_State_baseV2::_Make_ready*; _Tail = {std::default_delete<std::__future_base::_State_baseV2::_Make_ready>}] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct _Make_ready * const &) (struct _Make_ready * const *) std::_Head_base<0ul, std::__future_base::_State_baseV2::_Make_ready*, false>::_M_head ((const struct _Head_base &) &((const struct _Tuple_impl *) __t)->D.67320)>>
   >>>;


;; Function constexpr const _Head& std::__get_helper(const std::_Tuple_impl<_Idx, _Head, _Tail ...>&) [with long unsigned int __i = 0ul; _Head = std::__future_base::_State_baseV2::_Make_ready*; _Tail = {std::default_delete<std::__future_base::_State_baseV2::_Make_ready>}] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct _Make_ready * const &) (struct _Make_ready * const *) std::_Tuple_impl<0ul, std::__future_base::_State_baseV2::_Make_ready*, std::default_delete<std::__future_base::_State_baseV2::_Make_ready> >::_M_head ((const struct _Tuple_impl &) (const struct _Tuple_impl *) __t)>>
   >>>;


;; Function constexpr std::__tuple_element_t<__i, std::tuple<_Elements ...> >& std::get(const std::tuple<_Elements ...>&) [with long unsigned int __i = 0ul; _Elements = {std::__future_base::_State_baseV2::_Make_ready*, std::default_delete<std::__future_base::_State_baseV2::_Make_ready>}; std::__tuple_element_t<__i, std::tuple<_Elements ...> > = std::__future_base::_State_baseV2::_Make_ready*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct _Make_ready * const &) (struct _Make_ready * const *) std::__get_helper<0ul, std::__future_base::_State_baseV2::_Make_ready*, std::default_delete<std::__future_base::_State_baseV2::_Make_ready> > ((const struct _Tuple_impl &) &((const struct tuple *) __t)->D.67990)>>
   >>>;


;; Function std::unique_ptr<_Tp, _Dp>::pointer std::unique_ptr<_Tp, _Dp>::get() const [with _Tp = std::__future_base::_State_baseV2::_Make_ready; _Dp = std::default_delete<std::__future_base::_State_baseV2::_Make_ready>; std::unique_ptr<_Tp, _Dp>::pointer = std::__future_base::_State_baseV2::_Make_ready*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct _Make_ready *) *std::get<0ul, std::__future_base::_State_baseV2::_Make_ready*, std::default_delete<std::__future_base::_State_baseV2::_Make_ready> > ((const struct tuple &) &((const struct unique_ptr *) this)->_M_t)>>
   >>>;


;; Function std::__weak_count<_Lp>& std::__weak_count<_Lp>::operator=(std::__weak_count<_Lp>&&) [with __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  if (((struct __weak_count *) this)->_M_pi != 0B)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2u>::_M_weak_release (NON_LVALUE_EXPR <((struct __weak_count *) this)->_M_pi>) >>>>>;
    }
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __weak_count *) this)->_M_pi = __r->_M_pi) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__r->_M_pi = 0B) >>>>>;
  return <retval> = (struct __weak_count &) (struct __weak_count *) this;
   >>>;


;; Function void std::swap(std::tuple<_Elements ...>&, std::tuple<_Elements ...>&) [with _Elements = {std::__future_base::_Result_base*, std::__future_base::_Result_base::_Deleter}] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::tuple<std::__future_base::_Result_base*, std::__future_base::_Result_base::_Deleter>::swap ((struct tuple *) __x, (struct tuple &) (struct tuple *) __y) >>>>>
   >>>;


;; Function std::unique_ptr<_Tp, _Dp>::pointer std::unique_ptr<_Tp, _Dp>::release() [with _Tp = std::__future_base::_Result_base; _Dp = std::__future_base::_Result_base::_Deleter; std::unique_ptr<_Tp, _Dp>::pointer = std::__future_base::_Result_base*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    struct _Result_base * __p;

        struct _Result_base * __p;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__p = std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>::get (this)) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*std::get<0ul, std::__future_base::_Result_base*, std::__future_base::_Result_base::_Deleter> ((struct tuple &) &((struct unique_ptr *) this)->_M_t) = 0B) >>>>>;
    return <retval> = __p;
  }
   >>>;


;; Function std::__shared_count<_Lp>::__shared_count(const std::__shared_count<_Lp>&) [with __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __shared_count *) this)->_M_pi = (struct _Sp_counted_base *) __r->_M_pi) >>>>>;
    if (((struct __shared_count *) this)->_M_pi != 0B)
      {
        <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2u>::_M_add_ref_copy (NON_LVALUE_EXPR <((struct __shared_count *) this)->_M_pi>) >>>>>;
      }
  }
   >>>;


;; Function void std::__shared_ptr<_Tp, _Lp>::reset() [with _Tp = std::__future_base::_State_baseV2; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__shared_ptr<std::__future_base::_State_baseV2, (__gnu_cxx::_Lock_policy)2u>::swap (&TARGET_EXPR <D.104814, <<< Unknown tree: aggr_init_expr
  4
  __comp_ctor 
  D.104814
  (struct __shared_ptr *) <<< Unknown tree: void_cst >>> >>>>, (struct __shared_ptr &) (struct __shared_ptr *) this) >>>>>
   >>>;


;; Function std::allocator< <template-parameter-1-1> >::allocator() [with _Tp = std::__future_base::_State_baseV2] (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<std::__future_base::_State_baseV2>::new_allocator ((struct new_allocator *) this) >>>>>;
    try
      {
        
      }
    catch
      {
        __gnu_cxx::new_allocator<std::__future_base::_State_baseV2>::~new_allocator ((struct new_allocator *) this);
      }
  }
   >>>;


;; Function std::allocator< <template-parameter-1-1> >::~allocator() [with _Tp = std::__future_base::_State_baseV2] (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  {
    try
      {
        
      }
    finally
      {
        __gnu_cxx::new_allocator<std::__future_base::_State_baseV2>::~new_allocator ((struct new_allocator *) this);
      }
  }
  <D.104819>:;
   >>>;


;; Function std::shared_ptr<_Tp1> std::allocate_shared(const _Alloc&, _Args&& ...) [with _Tp = std::__future_base::_State_baseV2; _Alloc = std::allocator<std::__future_base::_State_baseV2>; _Args = {}] (null)
;; enabled by -tree-original


<<cleanup_point return *<retval> = TARGET_EXPR <D.104839, <<< Unknown tree: aggr_init_expr
  6
  __comp_ctor 
  D.104839
  (struct shared_ptr *) <<< Unknown tree: void_cst >>>
  TARGET_EXPR <D.104826, {}>;, <<< Unknown tree: empty_class_expr >>>;
  (const struct allocator &) (const struct allocator *) __a >>>>>>;


;; Function std::__shared_ptr<_Tp, _Lp>::__shared_ptr(std::__shared_ptr<_Tp, _Lp>&&) [with _Tp = std::__future_base::_State_baseV2; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __shared_ptr *) this)->_M_ptr = __r->_M_ptr) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __shared_ptr *) this)->_M_refcount = <<< Unknown tree: aggr_init_expr
  4
  __comp_ctor 
  D.104841
  (struct __shared_count *) <<< Unknown tree: void_cst >>> >>>) >>>>>;
    try
      {
        <<cleanup_point <<< Unknown tree: expr_stmt
  std::__shared_count<>::_M_swap (&((struct __shared_ptr *) this)->_M_refcount, (struct __shared_count &) &__r->_M_refcount) >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__r->_M_ptr = 0B) >>>>>;
      }
    catch
      {
        std::__shared_count<>::~__shared_count (&((struct __shared_ptr *) this)->_M_refcount);
      }
  }
   >>>;


;; Function constexpr std::__tuple_element_t<__i, std::tuple<_Elements ...> >& std::get(std::tuple<_Elements ...>&) [with long unsigned int __i = 1ul; _Elements = {std::__future_base::_Result<void>*, std::__future_base::_Result_base::_Deleter}; std::__tuple_element_t<__i, std::tuple<_Elements ...> > = std::__future_base::_Result_base::_Deleter] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct __tuple_element_t &) (struct _Deleter *) std::__get_helper<1ul, std::__future_base::_Result_base::_Deleter> ((struct _Tuple_impl &) (struct _Tuple_impl *) (struct tuple *) __t)>>
   >>>;


;; Function std::unique_ptr<_Tp, _Dp>::deleter_type& std::unique_ptr<_Tp, _Dp>::get_deleter() [with _Tp = std::__future_base::_Result<void>; _Dp = std::__future_base::_Result_base::_Deleter; std::unique_ptr<_Tp, _Dp>::deleter_type = std::__future_base::_Result_base::_Deleter] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct deleter_type &) (struct __tuple_element_t *) std::get<1ul, std::__future_base::_Result<void>*, std::__future_base::_Result_base::_Deleter> ((struct tuple &) &((struct unique_ptr *) this)->_M_t)>>
   >>>;


;; Function std::unique_ptr<_Tp, _Dp>::pointer std::unique_ptr<_Tp, _Dp>::release() [with _Tp = std::__future_base::_Result<void>; _Dp = std::__future_base::_Result_base::_Deleter; std::unique_ptr<_Tp, _Dp>::pointer = std::__future_base::_Result<void>*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    struct _Result * __p;

        struct _Result * __p;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__p = std::unique_ptr<std::__future_base::_Result<void>, std::__future_base::_Result_base::_Deleter>::get (this)) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*std::get<0ul, std::__future_base::_Result<void>*, std::__future_base::_Result_base::_Deleter> ((struct tuple &) &((struct unique_ptr *) this)->_M_t) = 0B) >>>>>;
    return <retval> = __p;
  }
   >>>;


;; Function bool std::__shared_count<_Lp>::_M_unique() const [with __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::__shared_count<>::_M_get_use_count (this) == 1>>
   >>>;


;; Function constexpr typename std::remove_reference< <template-parameter-1-1> >::type&& std::move(_Tp&&) [with _Tp = std::__future_base::_State_baseV2*&; typename std::remove_reference< <template-parameter-1-1> >::type = std::__future_base::_State_baseV2*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct _State_baseV2 * &) (struct _State_baseV2 * *) (struct _State_baseV2 * &) __t
   >>>;


;; Function void std::swap(_Tp&, _Tp&) [with _Tp = std::__future_base::_State_baseV2*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    struct _State_baseV2 * __tmp;

        struct _State_baseV2 * __tmp;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__tmp = *std::move<std::__future_base::_State_baseV2*&> ((struct _State_baseV2 * &) (struct _State_baseV2 * *) __a)) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__a = *std::move<std::__future_base::_State_baseV2*&> ((struct _State_baseV2 * &) (struct _State_baseV2 * *) __b)) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__b = *std::move<std::__future_base::_State_baseV2*&> ((struct _State_baseV2 * &) &__tmp)) >>>>>;
  }
   >>>;


;; Function void std::__shared_count<_Lp>::_M_swap(std::__shared_count<_Lp>&) [with __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    struct _Sp_counted_base * __tmp = __r->_M_pi;

        struct _Sp_counted_base * __tmp = __r->_M_pi;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__r->_M_pi = ((struct __shared_count *) this)->_M_pi) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __shared_count *) this)->_M_pi = __tmp) >>>>>;
  }
   >>>;


;; Function void std::swap(std::tuple<_Elements ...>&, std::tuple<_Elements ...>&) [with _Elements = {std::__future_base::_Result<void>*, std::__future_base::_Result_base::_Deleter}] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::tuple<std::__future_base::_Result<void>*, std::__future_base::_Result_base::_Deleter>::swap ((struct tuple *) __x, (struct tuple &) (struct tuple *) __y) >>>>>
   >>>;


;; Function static bool std::_Function_base::_Base_manager<_Functor>::_M_not_empty_function(const _Tp&) [with _Tp = std::__future_base::_State_baseV2::_Setter<void, std::__future_base::_State_baseV2::__exception_ptr_tag>; _Functor = std::__future_base::_State_baseV2::_Setter<void, std::__future_base::_State_baseV2::__exception_ptr_tag>] (null)
;; enabled by -tree-original


return <retval> = 1;


;; Function static void std::_Function_base::_Base_manager<_Functor>::_M_init_functor(std::_Any_data&, _Functor&&) [with _Functor = std::__future_base::_State_baseV2::_Setter<void, std::__future_base::_State_baseV2::__exception_ptr_tag>] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::_Function_base::_Base_manager<std::__future_base::_State_baseV2::_Setter<void, std::__future_base::_State_baseV2::__exception_ptr_tag> >::_M_init_functor ((union _Any_data &) (union _Any_data *) __functor, (struct _Setter &) (struct type *) std::move<std::__future_base::_State_baseV2::_Setter<void, std::__future_base::_State_baseV2::__exception_ptr_tag>&> ((struct _Setter &) (struct _Setter *) __f), TARGET_EXPR <D.104899, {}>;, <<< Unknown tree: empty_class_expr >>>;) >>>>>;


;; Function static _Res std::_Function_handler<_Res(_ArgTypes ...), _Functor>::_M_invoke(const std::_Any_data&, _ArgTypes&& ...) [with _Res = std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>; _Functor = std::__future_base::_State_baseV2::_Setter<void, std::__future_base::_State_baseV2::__exception_ptr_tag>; _ArgTypes = {}] (null)
;; enabled by -tree-original


<<cleanup_point return *<retval> = TARGET_EXPR <D.104935, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.104935
  (struct unique_ptr *) <<< Unknown tree: void_cst >>>
  (struct unique_ptr &) &TARGET_EXPR <D.104934, <<< Unknown tree: aggr_init_expr
  4
  operator()
  D.104934
  std::_Function_base::_Base_manager<std::__future_base::_State_baseV2::_Setter<void, std::__future_base::_State_baseV2::__exception_ptr_tag> >::_M_get_pointer ((const union _Any_data &) (const union _Any_data *) __functor) >>>> >>>>>>;


;; Function static bool std::_Function_base::_Base_manager<_Functor>::_M_manager(std::_Any_data&, const std::_Any_data&, std::_Manager_operation) [with _Functor = std::__future_base::_State_baseV2::_Setter<void, std::__future_base::_State_baseV2::__exception_ptr_tag>] (null)
;; enabled by -tree-original


switch ((int) __op)
  {
    case 0:;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*std::_Any_data::_M_access<const std::type_info*> ((union _Any_data *) __dest) = (const struct type_info *) &_ZTINSt13__future_base13_State_baseV27_SetterIvNS0_19__exception_ptr_tagEEE) >>>>>;
    goto <D.104948>;
    case 1:;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*std::_Any_data::_M_access<std::__future_base::_State_baseV2::_Setter<void, std::__future_base::_State_baseV2::__exception_ptr_tag>*> ((union _Any_data *) __dest) = std::_Function_base::_Base_manager<std::__future_base::_State_baseV2::_Setter<void, std::__future_base::_State_baseV2::__exception_ptr_tag> >::_M_get_pointer ((const union _Any_data &) (const union _Any_data *) __source)) >>>>>;
    goto <D.104948>;
    case 2:;
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Function_base::_Base_manager<std::__future_base::_State_baseV2::_Setter<void, std::__future_base::_State_baseV2::__exception_ptr_tag> >::_M_clone ((union _Any_data &) (union _Any_data *) __dest, (const union _Any_data &) (const union _Any_data *) __source, TARGET_EXPR <D.104945, {}>;, <<< Unknown tree: empty_class_expr >>>;) >>>>>;
    goto <D.104948>;
    case 3:;
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Function_base::_Base_manager<std::__future_base::_State_baseV2::_Setter<void, std::__future_base::_State_baseV2::__exception_ptr_tag> >::_M_destroy ((union _Any_data &) (union _Any_data *) __dest, TARGET_EXPR <D.104947, {}>;, <<< Unknown tree: empty_class_expr >>>;) >>>>>;
    goto <D.104948>;
  }
<D.104948>:;
return <retval> = 0;


;; Function void std::function<_Res(_ArgTypes ...)>::swap(std::function<_Res(_ArgTypes ...)>&) [with _Res = std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>; _ArgTypes = {}] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::swap<std::_Any_data> ((union _Any_data &) &((struct function *) this)->D.65694._M_functor, (union _Any_data &) &((struct function *) __x)->D.65694._M_functor) >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  std::swap<bool (*)(std::_Any_data&, const std::_Any_data&, std::_Manager_operation)> ((bool (*<T8bad>) (union _Any_data &, const union _Any_data &, _Manager_operation) &) &((struct function *) this)->D.65694._M_manager, (bool (*<T8bad>) (union _Any_data &, const union _Any_data &, _Manager_operation) &) &((struct function *) __x)->D.65694._M_manager) >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  std::swap<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> (*)(const std::_Any_data&)> ((struct unique_ptr (*<Tccf1>) (const union _Any_data &) &) &((struct function *) this)->_M_invoker, (struct unique_ptr (*<Tccf1>) (const union _Any_data &) &) &__x->_M_invoker) >>>>>;


;; Function std::__weak_ptr<_Tp, _Lp>::__weak_ptr(const std::__shared_ptr<_Tp1, _Lp>&) [with _Tp1 = std::__future_base::_State_baseV2; <template-parameter-2-2> = void; _Tp = std::__future_base::_State_baseV2; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __weak_ptr *) this)->_M_ptr = (struct _State_baseV2 *) __r->_M_ptr) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__weak_count<(__gnu_cxx::_Lock_policy)2u>::__weak_count (&((struct __weak_ptr *) this)->_M_refcount, (const struct __shared_count &) &__r->_M_refcount) >>>>>;
    try
      {
        
      }
    catch
      {
        std::__weak_count<(__gnu_cxx::_Lock_policy)2u>::~__weak_count (&((struct __weak_ptr *) this)->_M_refcount);
      }
  }
   >>>;


;; Function std::__weak_count<_Lp>::__weak_count(std::__weak_count<_Lp>&&) [with __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __weak_count *) this)->_M_pi = __r->_M_pi) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__r->_M_pi = 0B) >>>>>;
  }
   >>>;


;; Function static bool std::_Function_base::_Base_manager<_Functor>::_M_not_empty_function(const _Tp&) [with _Tp = std::__future_base::_State_baseV2::_Setter<void, void>; _Functor = std::__future_base::_State_baseV2::_Setter<void, void>] (null)
;; enabled by -tree-original


return <retval> = 1;


;; Function static void std::_Function_base::_Base_manager<_Functor>::_M_init_functor(std::_Any_data&, _Functor&&) [with _Functor = std::__future_base::_State_baseV2::_Setter<void, void>] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::_Function_base::_Base_manager<std::__future_base::_State_baseV2::_Setter<void, void> >::_M_init_functor ((union _Any_data &) (union _Any_data *) __functor, (struct _Setter &) (struct type *) std::move<std::__future_base::_State_baseV2::_Setter<void, void>&> ((struct _Setter &) (struct _Setter *) __f), TARGET_EXPR <D.105943, {}>;, <<< Unknown tree: empty_class_expr >>>;) >>>>>;


;; Function static _Res std::_Function_handler<_Res(_ArgTypes ...), _Functor>::_M_invoke(const std::_Any_data&, _ArgTypes&& ...) [with _Res = std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>; _Functor = std::__future_base::_State_baseV2::_Setter<void, void>; _ArgTypes = {}] (null)
;; enabled by -tree-original


<<cleanup_point return *<retval> = TARGET_EXPR <D.105946, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.105946
  (struct unique_ptr *) <<< Unknown tree: void_cst >>>
  (struct unique_ptr &) &TARGET_EXPR <D.105945, <<< Unknown tree: aggr_init_expr
  4
  operator()
  D.105945
  std::_Function_base::_Base_manager<std::__future_base::_State_baseV2::_Setter<void, void> >::_M_get_pointer ((const union _Any_data &) (const union _Any_data *) __functor) >>>> >>>>>>;


;; Function static bool std::_Function_base::_Base_manager<_Functor>::_M_manager(std::_Any_data&, const std::_Any_data&, std::_Manager_operation) [with _Functor = std::__future_base::_State_baseV2::_Setter<void, void>] (null)
;; enabled by -tree-original


switch ((int) __op)
  {
    case 0:;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*std::_Any_data::_M_access<const std::type_info*> ((union _Any_data *) __dest) = (const struct type_info *) &_ZTINSt13__future_base13_State_baseV27_SetterIvvEE) >>>>>;
    goto <D.105959>;
    case 1:;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*std::_Any_data::_M_access<std::__future_base::_State_baseV2::_Setter<void, void>*> ((union _Any_data *) __dest) = std::_Function_base::_Base_manager<std::__future_base::_State_baseV2::_Setter<void, void> >::_M_get_pointer ((const union _Any_data &) (const union _Any_data *) __source)) >>>>>;
    goto <D.105959>;
    case 2:;
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Function_base::_Base_manager<std::__future_base::_State_baseV2::_Setter<void, void> >::_M_clone ((union _Any_data &) (union _Any_data *) __dest, (const union _Any_data &) (const union _Any_data *) __source, TARGET_EXPR <D.105956, {}>;, <<< Unknown tree: empty_class_expr >>>;) >>>>>;
    goto <D.105959>;
    case 3:;
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Function_base::_Base_manager<std::__future_base::_State_baseV2::_Setter<void, void> >::_M_destroy ((union _Any_data &) (union _Any_data *) __dest, TARGET_EXPR <D.105958, {}>;, <<< Unknown tree: empty_class_expr >>>;) >>>>>;
    goto <D.105959>;
  }
<D.105959>:;
return <retval> = 0;


;; Function constexpr std::_Maybe_get_result_type<std::thread, void>::_Maybe_get_result_type() (null)
;; enabled by -tree-original


{
  
}


;; Function constexpr std::_Weak_result_type_impl<std::thread>::_Weak_result_type_impl() (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Maybe_get_result_type<std::thread, void>::_Maybe_get_result_type ((struct _Maybe_get_result_type *) this) >>>>>;
}


;; Function constexpr std::_Weak_result_type<std::thread>::_Weak_result_type() (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Weak_result_type_impl<std::thread>::_Weak_result_type_impl ((struct _Weak_result_type_impl *) this) >>>>>;
}


;; Function constexpr std::_Reference_wrapper_base_impl<false, false, std::thread>::_Reference_wrapper_base_impl() (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Weak_result_type<std::thread>::_Weak_result_type ((struct _Weak_result_type *) this) >>>>>;
}


;; Function constexpr std::_Reference_wrapper_base<std::thread>::_Reference_wrapper_base() (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Reference_wrapper_base_impl<false, false, std::thread>::_Reference_wrapper_base_impl ((struct _Reference_wrapper_base_impl *) this) >>>>>;
}


;; Function std::reference_wrapper<_Tp>::reference_wrapper(_Tp&) [with _Tp = std::thread] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Reference_wrapper_base<std::thread>::_Reference_wrapper_base ((struct _Reference_wrapper_base *) this) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct reference_wrapper *) this)->_M_data = std::__addressof<std::thread> ((struct thread &) (struct thread *) __indata)) >>>>>;
  }
   >>>;


;; Function typename std::_Bind_simple_helper<_Func, _BoundArgs>::__type std::__bind_simple(_Callable&&, _Args&& ...) [with _Callable = void (std::thread::*)(); _Args = {std::reference_wrapper<std::thread>}; typename std::_Bind_simple_helper<_Func, _BoundArgs>::__type = std::_Bind_simple<std::_Mem_fn<void (std::thread::*)()>(std::reference_wrapper<std::thread>)>] (null)
;; enabled by -tree-original


{
  typedef struct __helper_type __helper_type;
  typedef struct __maybe_type __maybe_type;
  typedef struct __result_type __result_type;

  <<cleanup_point return *<retval> = TARGET_EXPR <D.105997, <<< Unknown tree: aggr_init_expr
  6
  __comp_ctor 
  D.105997
  (struct _Bind_simple *) <<< Unknown tree: void_cst >>>
  (struct _Mem_fn &) &TARGET_EXPR <D.105984, std::_Maybe_wrap_member_pointer<void (std::thread::*)()>::__do_wrap (*std::forward<void (std::thread::*)()> ((struct type &) (struct 
  {
    void thread::<Ta344> (struct thread *) * __pfn;
    long int __delta;
  } *) __callable))>
  (struct reference_wrapper &) (struct reference_wrapper *) std::forward<std::reference_wrapper<std::thread> > ((struct type &) (struct reference_wrapper *) __args#0) >>>>>>;
}


;; Function _Tp* std::__addressof(_Tp&) [with _Tp = std::_Bind_simple<std::_Mem_fn<void (std::thread::*)()>(std::reference_wrapper<std::thread>)>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct _Bind_simple *) __r
   >>>;


;; Function void std::__once_call_impl() [with _Callable = std::_Bind_simple<std::_Mem_fn<void (std::thread::*)()>(std::reference_wrapper<std::thread>)>] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::_Bind_simple<std::_Mem_fn<void (std::thread::*)()>(std::reference_wrapper<std::thread>)>::operator() ((struct _Bind_simple *) __once_callable) >>>>>;


;; Function typename std::_Niter_base<_Iterator>::iterator_type std::__niter_base(_Iterator) [with _Iterator = long unsigned int*; typename std::_Niter_base<_Iterator>::iterator_type = long unsigned int*] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = std::_Iter_base<long unsigned int*, false>::_S_base (__it)>>;


;; Function typename __gnu_cxx::__enable_if<std::__is_scalar<_Tp>::__value, void>::__type std::__fill_a(_ForwardIterator, _ForwardIterator, const _Tp&) [with _ForwardIterator = long unsigned int*; _Tp = int; typename __gnu_cxx::__enable_if<std::__is_scalar<_Tp>::__value, void>::__type = void] (null)
;; enabled by -tree-original


{
  const int __tmp = (int) *__value;

    const int __tmp = (int) *__value;
  while (1)
    {
      if (__first == __last) goto <D.106003>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__first = (long unsigned int) __tmp) >>>>>;
      <<cleanup_point (void)  ++__first>>;
    }
  <D.106003>:;
}


;; Function void std::basic_ios<_CharT, _Traits>::setstate(std::ios_base::iostate) [with _CharT = char; _Traits = std::char_traits<char>; std::ios_base::iostate = std::_Ios_Iostate] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::basic_ios<char>::clear (this, std::operator| (std::basic_ios<char>::rdstate (this), __state)) >>>>>;


;; Function std::basic_ios<_CharT, _Traits>::char_type std::basic_ios<_CharT, _Traits>::widen(char) const [with _CharT = char; _Traits = std::char_traits<char>; std::basic_ios<_CharT, _Traits>::char_type = char] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = std::ctype<char>::widen ((const struct ctype *) std::__check_facet<std::ctype<char> > ((const struct __ctype_type *) ((const struct basic_ios *) this)->_M_ctype), (int) __c)>>;


;; Function std::basic_ostream<_CharT, _Traits>& std::flush(std::basic_ostream<_CharT, _Traits>&) [with _CharT = char; _Traits = std::char_traits<char>] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (struct basic_ostream &) (struct basic_ostream *) std::basic_ostream<char>::flush ((struct basic_ostream *) __os)>>;


;; Function std::_Vector_base<std::packaged_task<long int(int, int)>, std::allocator<std::packaged_task<long int(int, int)> > >::_Vector_impl::~_Vector_impl() (null)
;; enabled by -tree-original


{
  try
    {
      try
        {
          
        }
      finally
        {
          std::allocator<std::packaged_task<long int(int, int)> >::~allocator ((struct allocator *) this);
        }
    }
  finally
    {
      *(struct 
      {
        struct packaged_task * _M_start;
        struct packaged_task * _M_finish;
        struct packaged_task * _M_end_of_storage;
      } &) this = {CLOBBER};
    }
}
<D.106013>:;


;; Function std::_Vector_base<_Tp, _Alloc>::_Vector_base() [with _Tp = std::packaged_task<long int(int, int)>; _Alloc = std::allocator<std::packaged_task<long int(int, int)> >] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Vector_base *) this)->_M_impl = <<< Unknown tree: aggr_init_expr
  4
  __comp_ctor 
  D.106011
  (struct _Vector_impl *) <<< Unknown tree: void_cst >>> >>>) >>>>>;
  try
    {
      
    }
  catch
    {
      std::_Vector_base<std::packaged_task<long int(int, int)>, std::allocator<std::packaged_task<long int(int, int)> > >::_Vector_impl::~_Vector_impl (&((struct _Vector_base *) this)->_M_impl);
    }
}


;; Function std::_Vector_base<_Tp, _Alloc>::~_Vector_base() [with _Tp = std::packaged_task<long int(int, int)>; _Alloc = std::allocator<std::packaged_task<long int(int, int)> >] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    try
      {
        try
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Vector_base<std::packaged_task<long int(int, int)>, std::allocator<std::packaged_task<long int(int, int)> > >::_M_deallocate (this, ((struct _Vector_base *) this)->_M_impl._M_start, (size_t) (((long int) ((struct _Vector_base *) this)->_M_impl._M_end_of_storage - (long int) ((struct _Vector_base *) this)->_M_impl._M_start) /[ex] 16)) >>>>>;
          }
        finally
          {
            std::_Vector_base<std::packaged_task<long int(int, int)>, std::allocator<std::packaged_task<long int(int, int)> > >::_Vector_impl::~_Vector_impl (&((struct _Vector_base *) this)->_M_impl);
          }
      }
    finally
      {
        *(struct 
        {
          struct _Vector_impl _M_impl;
        } &) this = {CLOBBER};
      }
  }
  <D.106023>:;
   >>>;


;; Function std::_Vector_base<_Tp, _Alloc>::_Tp_alloc_type& std::_Vector_base<_Tp, _Alloc>::_M_get_Tp_allocator() [with _Tp = std::packaged_task<long int(int, int)>; _Alloc = std::allocator<std::packaged_task<long int(int, int)> >; std::_Vector_base<_Tp, _Alloc>::_Tp_alloc_type = std::allocator<std::packaged_task<long int(int, int)> >] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct _Tp_alloc_type &) (struct _Tp_alloc_type *) (struct allocator *) &((struct _Vector_base *) this)->_M_impl
   >>>;


;; Function void std::_Destroy(_ForwardIterator, _ForwardIterator, std::allocator<_T2>&) [with _ForwardIterator = std::packaged_task<long int(int, int)>*; _Tp = std::packaged_task<long int(int, int)>] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::_Destroy<std::packaged_task<long int(int, int)>*> (__first, __last) >>>>>;


;; Function std::_Vector_base<std::future<long int>, std::allocator<std::future<long int> > >::_Vector_impl::~_Vector_impl() (null)
;; enabled by -tree-original


{
  try
    {
      try
        {
          
        }
      finally
        {
          std::allocator<std::future<long int> >::~allocator ((struct allocator *) this);
        }
    }
  finally
    {
      *(struct 
      {
        struct future * _M_start;
        struct future * _M_finish;
        struct future * _M_end_of_storage;
      } &) this = {CLOBBER};
    }
}
<D.106037>:;


;; Function std::_Vector_base<_Tp, _Alloc>::_Vector_base() [with _Tp = std::future<long int>; _Alloc = std::allocator<std::future<long int> >] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Vector_base *) this)->_M_impl = <<< Unknown tree: aggr_init_expr
  4
  __comp_ctor 
  D.106035
  (struct _Vector_impl *) <<< Unknown tree: void_cst >>> >>>) >>>>>;
  try
    {
      
    }
  catch
    {
      std::_Vector_base<std::future<long int>, std::allocator<std::future<long int> > >::_Vector_impl::~_Vector_impl (&((struct _Vector_base *) this)->_M_impl);
    }
}


;; Function std::_Vector_base<_Tp, _Alloc>::~_Vector_base() [with _Tp = std::future<long int>; _Alloc = std::allocator<std::future<long int> >] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    try
      {
        try
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Vector_base<std::future<long int>, std::allocator<std::future<long int> > >::_M_deallocate (this, ((struct _Vector_base *) this)->_M_impl._M_start, (size_t) (((long int) ((struct _Vector_base *) this)->_M_impl._M_end_of_storage - (long int) ((struct _Vector_base *) this)->_M_impl._M_start) /[ex] 16)) >>>>>;
          }
        finally
          {
            std::_Vector_base<std::future<long int>, std::allocator<std::future<long int> > >::_Vector_impl::~_Vector_impl (&((struct _Vector_base *) this)->_M_impl);
          }
      }
    finally
      {
        *(struct 
        {
          struct _Vector_impl _M_impl;
        } &) this = {CLOBBER};
      }
  }
  <D.106047>:;
   >>>;


;; Function std::_Vector_base<_Tp, _Alloc>::_Tp_alloc_type& std::_Vector_base<_Tp, _Alloc>::_M_get_Tp_allocator() [with _Tp = std::future<long int>; _Alloc = std::allocator<std::future<long int> >; std::_Vector_base<_Tp, _Alloc>::_Tp_alloc_type = std::allocator<std::future<long int> >] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct _Tp_alloc_type &) (struct _Tp_alloc_type *) (struct allocator *) &((struct _Vector_base *) this)->_M_impl
   >>>;


;; Function void std::_Destroy(_ForwardIterator, _ForwardIterator, std::allocator<_T2>&) [with _ForwardIterator = std::future<long int>*; _Tp = std::future<long int>] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::_Destroy<std::future<long int>*> (__first, __last) >>>>>;


;; Function std::_Vector_base<std::thread*, std::allocator<std::thread*> >::_Vector_impl::~_Vector_impl() (null)
;; enabled by -tree-original


{
  try
    {
      try
        {
          
        }
      finally
        {
          std::allocator<std::thread*>::~allocator ((struct allocator *) this);
        }
    }
  finally
    {
      *(struct 
      {
        struct thread * * _M_start;
        struct thread * * _M_finish;
        struct thread * * _M_end_of_storage;
      } &) this = {CLOBBER};
    }
}
<D.106061>:;


;; Function std::_Vector_base<_Tp, _Alloc>::_Vector_base() [with _Tp = std::thread*; _Alloc = std::allocator<std::thread*>] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Vector_base *) this)->_M_impl = <<< Unknown tree: aggr_init_expr
  4
  __comp_ctor 
  D.106059
  (struct _Vector_impl *) <<< Unknown tree: void_cst >>> >>>) >>>>>;
  try
    {
      
    }
  catch
    {
      std::_Vector_base<std::thread*, std::allocator<std::thread*> >::_Vector_impl::~_Vector_impl (&((struct _Vector_base *) this)->_M_impl);
    }
}


;; Function std::_Vector_base<_Tp, _Alloc>::~_Vector_base() [with _Tp = std::thread*; _Alloc = std::allocator<std::thread*>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    try
      {
        try
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Vector_base<std::thread*, std::allocator<std::thread*> >::_M_deallocate (this, ((struct _Vector_base *) this)->_M_impl._M_start, (size_t) (((long int) ((struct _Vector_base *) this)->_M_impl._M_end_of_storage - (long int) ((struct _Vector_base *) this)->_M_impl._M_start) /[ex] 8)) >>>>>;
          }
        finally
          {
            std::_Vector_base<std::thread*, std::allocator<std::thread*> >::_Vector_impl::~_Vector_impl (&((struct _Vector_base *) this)->_M_impl);
          }
      }
    finally
      {
        *(struct 
        {
          struct _Vector_impl _M_impl;
        } &) this = {CLOBBER};
      }
  }
  <D.106071>:;
   >>>;


;; Function std::_Vector_base<_Tp, _Alloc>::_Tp_alloc_type& std::_Vector_base<_Tp, _Alloc>::_M_get_Tp_allocator() [with _Tp = std::thread*; _Alloc = std::allocator<std::thread*>; std::_Vector_base<_Tp, _Alloc>::_Tp_alloc_type = std::allocator<std::thread*>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct _Tp_alloc_type &) (struct _Tp_alloc_type *) (struct allocator *) &((struct _Vector_base *) this)->_M_impl
   >>>;


;; Function void std::_Destroy(_ForwardIterator, _ForwardIterator, std::allocator<_T2>&) [with _ForwardIterator = std::thread**; _Tp = std::thread*] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::_Destroy<std::thread**> (__first, __last) >>>>>;


;; Function std::allocator< <template-parameter-1-1> >::allocator() [with _Tp = int] (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<int>::new_allocator ((struct new_allocator *) this) >>>>>;
    try
      {
        
      }
    catch
      {
        __gnu_cxx::new_allocator<int>::~new_allocator ((struct new_allocator *) this);
      }
  }
   >>>;


;; Function std::allocator< <template-parameter-1-1> >::~allocator() [with _Tp = int] (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  {
    try
      {
        
      }
    finally
      {
        __gnu_cxx::new_allocator<int>::~new_allocator ((struct new_allocator *) this);
      }
  }
  <D.106086>:;
   >>>;


;; Function std::packaged_task<_Res(_ArgTypes ...)>::packaged_task(std::allocator_arg_t, const _Alloc&, _Fn&&) [with _Fn = long int (&)(int, int); _Alloc = std::allocator<int>; <template-parameter-2-3> = void; _Res = long int; _ArgTypes = {int, int}] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct packaged_task *) this)->_M_state = TARGET_EXPR <D.106096, <<< Unknown tree: aggr_init_expr
  5
  __create_task_state
  D.106096
  (long int (&<T105d3>) (int, int)) (long int (*<T105d2>) (int, int)) std::forward<long int (&)(int, int)> ((long int (&<T15f36>) (int, int)) (long int (*<T105d2>) (int, int)) __fn)
  (const struct allocator &) (const struct allocator *) __a >>>>) >>>>>;
  try
    {
      
    }
  catch
    {
      std::shared_ptr<std::__future_base::_Task_state_base<long int(int, int)> >::~shared_ptr (&((struct packaged_task *) this)->_M_state);
    }
}


;; Function std::__shared_ptr<_Tp, _Lp>::operator bool() const [with _Tp = std::__future_base::_Task_state_base<long int(int, int)>; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


return <retval> = (struct _Task_state_base *) ((const struct __shared_ptr *) this)->_M_ptr != 0B;


;; Function bool std::__shared_ptr<_Tp, _Lp>::unique() const [with _Tp = std::__future_base::_Task_state_base<long int(int, int)>; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::__shared_count<>::_M_unique (&((const struct __shared_ptr *) this)->_M_refcount)>>
   >>>;


;; Function _Tp* std::__shared_ptr<_Tp, _Lp>::operator->() const [with _Tp = std::__future_base::_Task_state_base<long int(int, int)>; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct _Task_state_base *) ((const struct __shared_ptr *) this)->_M_ptr
   >>>;


;; Function constexpr _Tp&& std::forward(typename std::remove_reference<_From>::type&) [with _Tp = std::__future_base::_Result<long int>*; typename std::remove_reference<_From>::type = std::__future_base::_Result<long int>*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct _Result * &) (struct _Result * *) (struct _Result * &) __t
   >>>;


;; Function constexpr std::_Head_base<_Idx, _Head, false>::_Head_base(_UHead&&) [with _UHead = std::__future_base::_Result<long int>*; long unsigned int _Idx = 0ul; _Head = std::__future_base::_Result_base*] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Head_base *) this)->_M_head_impl = (struct _Result_base *) *std::forward<std::__future_base::_Result<long int>*> ((struct _Result * &) (struct _Result * *) __h)) >>>>>;
}


;; Function constexpr std::_Tuple_impl<_Idx, _Head, _Tail ...>::_Tuple_impl(_UHead&&, _UTail&& ...) [with _UHead = std::__future_base::_Result<long int>*; _UTail = {std::__future_base::_Result_base::_Deleter}; <template-parameter-2-3> = void; long unsigned int _Idx = 0ul; _Head = std::__future_base::_Result_base*; _Tail = {std::__future_base::_Result_base::_Deleter}] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Tuple_impl<1ul, std::__future_base::_Result_base::_Deleter>::_Tuple_impl<std::__future_base::_Result_base::_Deleter> ((struct _Tuple_impl *) this, (struct _Deleter &) (struct _Deleter *) std::forward<std::__future_base::_Result_base::_Deleter> ((struct type &) (struct _Deleter *) __tail#0)) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Head_base<0ul, std::__future_base::_Result_base*, false>::_Head_base<std::__future_base::_Result<long int>*> (&((struct _Tuple_impl *) this)->D.63461, (struct _Result * &) (struct _Result * *) std::forward<std::__future_base::_Result<long int>*> ((struct _Result * &) (struct _Result * *) __head)) >>>>>;
}


;; Function constexpr std::tuple<_T1, _T2>::tuple(_U1&&, _U2&&) [with _U1 = std::__future_base::_Result<long int>*; _U2 = std::__future_base::_Result_base::_Deleter; <template-parameter-2-3> = void; _T1 = std::__future_base::_Result_base*; _T2 = std::__future_base::_Result_base::_Deleter] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Tuple_impl<0ul, std::__future_base::_Result_base*, std::__future_base::_Result_base::_Deleter>::_Tuple_impl<std::__future_base::_Result<long int>*, std::__future_base::_Result_base::_Deleter, void> (&((struct tuple *) this)->D.64132, (struct _Result * &) (struct _Result * *) std::forward<std::__future_base::_Result<long int>*> ((struct _Result * &) (struct _Result * *) __a1), (struct _Deleter &) (struct _Deleter *) std::forward<std::__future_base::_Result_base::_Deleter> ((struct type &) (struct _Deleter *) __a2)) >>>>>;
}


;; Function std::unique_ptr<_Tp, _Dp>::unique_ptr(std::unique_ptr<_Up, _Ep>&&) [with _Up = std::__future_base::_Result<long int>; _Ep = std::__future_base::_Result_base::_Deleter; <template-parameter-2-3> = void; _Tp = std::__future_base::_Result_base; _Dp = std::__future_base::_Result_base::_Deleter] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::tuple<std::__future_base::_Result_base*, std::__future_base::_Result_base::_Deleter>::tuple<std::__future_base::_Result<long int>*, std::__future_base::_Result_base::_Deleter, void> (&((struct unique_ptr *) this)->_M_t, (struct _Result * &) &TARGET_EXPR <D.106141, std::unique_ptr<std::__future_base::_Result<long int>, std::__future_base::_Result_base::_Deleter>::release ((struct unique_ptr *) __u)>, (struct _Deleter &) (struct _Deleter *) std::forward<std::__future_base::_Result_base::_Deleter> ((struct type &) (struct deleter_type *) std::unique_ptr<std::__future_base::_Result<long int>, std::__future_base::_Result_base::_Deleter>::get_deleter ((struct unique_ptr *) __u))) >>>>>;
  }
   >>>;


;; Function static void std::allocator_traits<std::allocator<_CharT> >::construct(std::allocator_traits<std::allocator<_CharT> >::allocator_type&, _Up*, _Args&& ...) [with _Up = std::packaged_task<long int(int, int)>; _Args = {std::packaged_task<long int(int, int)>}; _Tp = std::packaged_task<long int(int, int)>; std::allocator_traits<std::allocator<_CharT> >::allocator_type = std::allocator<std::packaged_task<long int(int, int)> >] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<std::packaged_task<long int(int, int)> >::construct<std::packaged_task<long int(int, int)>, std::packaged_task<long int(int, int)> > ((struct new_allocator *) (struct allocator_type *) __a, __p, (struct packaged_task &) (struct packaged_task *) std::forward<std::packaged_task<long int(int, int)> > ((struct type &) (struct packaged_task *) __args#0)) >>>>>;


;; Function void std::vector<_Tp, _Alloc>::_M_emplace_back_aux(_Args&& ...) [with _Args = {std::packaged_task<long int(int, int)>}; _Tp = std::packaged_task<long int(int, int)>; _Alloc = std::allocator<std::packaged_task<long int(int, int)> >] (null)
;; enabled by -tree-original


{
  const size_type __len;
  struct packaged_task * __new_start;
  struct packaged_task * __new_finish = __new_start;

    const size_type __len;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__len = std::vector<std::packaged_task<long int(int, int)> >::_M_check_len (this, 1, (const char *) "vector::_M_emplace_back_aux")) >>>>>;
    struct packaged_task * __new_start;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__new_start = std::_Vector_base<std::packaged_task<long int(int, int)>, std::allocator<std::packaged_task<long int(int, int)> > >::_M_allocate (&((struct vector *) this)->D.78390, (size_type) __len)) >>>>>;
    struct packaged_task * __new_finish = __new_start;
  <<< Unknown tree: try_block
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator_traits<std::allocator<std::packaged_task<long int(int, int)> > >::construct<std::packaged_task<long int(int, int)>, std::packaged_task<long int(int, int)> > ((struct allocator_type &) (struct allocator *) &((struct vector *) this)->D.78390._M_impl, __new_start + (sizetype) (std::vector<std::packaged_task<long int(int, int)> >::size (this) * 16), (struct packaged_task &) (struct packaged_task *) std::forward<std::packaged_task<long int(int, int)> > ((struct type &) (struct packaged_task *) __args#0)) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__new_finish = 0B) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__new_finish = std::__uninitialized_move_if_noexcept_a<std::packaged_task<long int(int, int)>*, std::packaged_task<long int(int, int)>*, std::allocator<std::packaged_task<long int(int, int)> > > (((struct vector *) this)->D.78390._M_impl._M_start, ((struct vector *) this)->D.78390._M_impl._M_finish, __new_start, (struct allocator &) (struct _Tp_alloc_type *) std::_Vector_base<std::packaged_task<long int(int, int)>, std::allocator<std::packaged_task<long int(int, int)> > >::_M_get_Tp_allocator (&((struct vector *) this)->D.78390))) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void)  ++__new_finish >>>>>;
  <<< Unknown tree: handler
  
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) __cxa_begin_catch (__builtin_eh_pointer (0)) >>>>>;
      if (__new_finish == 0B)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator_traits<std::allocator<std::packaged_task<long int(int, int)> > >::destroy<std::packaged_task<long int(int, int)> > ((struct allocator_type &) (struct allocator *) &((struct vector *) this)->D.78390._M_impl, __new_start + (sizetype) (std::vector<std::packaged_task<long int(int, int)> >::size (this) * 16)) >>>>>;
        }
      else
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Destroy<std::packaged_task<long int(int, int)>*, std::packaged_task<long int(int, int)> > (__new_start, __new_finish, (struct allocator &) (struct _Tp_alloc_type *) std::_Vector_base<std::packaged_task<long int(int, int)>, std::allocator<std::packaged_task<long int(int, int)> > >::_M_get_Tp_allocator (&((struct vector *) this)->D.78390)) >>>>>;
        }
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Vector_base<std::packaged_task<long int(int, int)>, std::allocator<std::packaged_task<long int(int, int)> > >::_M_deallocate (&((struct vector *) this)->D.78390, __new_start, (size_type) __len) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  <<< Unknown tree: throw_expr
  __cxa_rethrow () >>> >>>>>;
    }
  finally
    {
      __cxa_end_catch ();
    } >>> >>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Destroy<std::packaged_task<long int(int, int)>*, std::packaged_task<long int(int, int)> > (((struct vector *) this)->D.78390._M_impl._M_start, ((struct vector *) this)->D.78390._M_impl._M_finish, (struct allocator &) (struct _Tp_alloc_type *) std::_Vector_base<std::packaged_task<long int(int, int)>, std::allocator<std::packaged_task<long int(int, int)> > >::_M_get_Tp_allocator (&((struct vector *) this)->D.78390)) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Vector_base<std::packaged_task<long int(int, int)>, std::allocator<std::packaged_task<long int(int, int)> > >::_M_deallocate (&((struct vector *) this)->D.78390, ((struct vector *) this)->D.78390._M_impl._M_start, (size_t) (((long int) ((struct vector *) this)->D.78390._M_impl._M_end_of_storage - (long int) ((struct vector *) this)->D.78390._M_impl._M_start) /[ex] 16)) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct vector *) this)->D.78390._M_impl._M_start = __new_start) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct vector *) this)->D.78390._M_impl._M_finish = __new_finish) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct vector *) this)->D.78390._M_impl._M_end_of_storage = __new_start + (sizetype) ((long unsigned int) __len * 16)) >>>>>;
}


;; Function std::shared_ptr<_Tp>::shared_ptr(const std::shared_ptr<_Tp1>&) [with _Tp1 = std::__future_base::_Task_state_base<long int(int, int)>; <template-parameter-2-2> = void; _Tp = std::__future_base::_State_baseV2] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__shared_ptr<std::__future_base::_State_baseV2, (__gnu_cxx::_Lock_policy)2u>::__shared_ptr<std::__future_base::_Task_state_base<long int(int, int)>, void> (&((struct shared_ptr *) this)->D.69901, (const struct __shared_ptr &) &((const struct shared_ptr *) __r)->D.82011) >>>>>;
    try
      {
        
      }
    catch
      {
        std::__shared_ptr<std::__future_base::_State_baseV2, (__gnu_cxx::_Lock_policy)2u>::~__shared_ptr (&((struct shared_ptr *) this)->D.69901);
      }
  }
   >>>;


;; Function std::future<_Res>::future(const __state_type&) [with _Res = long int; std::future<_Res>::__state_type = std::shared_ptr<std::__future_base::_State_baseV2>] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__basic_future<long int>::__basic_future (&((struct future *) this)->D.82467, (const struct __state_type &) (const struct __state_type *) __state) >>>>>;
  try
    {
      
    }
  catch
    {
      std::__basic_future<long int>::~__basic_future (&((struct future *) this)->D.82467);
    }
}


;; Function std::__basic_future<_Res>::__basic_future(std::future<_Res>&&) [with _Res = long int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__future_base::__future_base ((struct __future_base *) this) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::shared_ptr<std::__future_base::_State_baseV2>::shared_ptr (&((struct __basic_future *) this)->_M_state, (struct shared_ptr &) (struct type *) std::move<std::shared_ptr<std::__future_base::_State_baseV2>&> ((struct shared_ptr &) &((struct future *) __uf)->D.82467._M_state)) >>>>>;
    try
      {
        
      }
    catch
      {
        std::shared_ptr<std::__future_base::_State_baseV2>::~shared_ptr (&((struct __basic_future *) this)->_M_state);
      }
  }
   >>>;


;; Function static void std::allocator_traits<std::allocator<_CharT> >::construct(std::allocator_traits<std::allocator<_CharT> >::allocator_type&, _Up*, _Args&& ...) [with _Up = std::future<long int>; _Args = {std::future<long int>}; _Tp = std::future<long int>; std::allocator_traits<std::allocator<_CharT> >::allocator_type = std::allocator<std::future<long int> >] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<std::future<long int> >::construct<std::future<long int>, std::future<long int> > ((struct new_allocator *) (struct allocator_type *) __a, __p, (struct future &) (struct future *) std::forward<std::future<long int> > ((struct type &) (struct future *) __args#0)) >>>>>;


;; Function void std::vector<_Tp, _Alloc>::_M_emplace_back_aux(_Args&& ...) [with _Args = {std::future<long int>}; _Tp = std::future<long int>; _Alloc = std::allocator<std::future<long int> >] (null)
;; enabled by -tree-original


{
  const size_type __len;
  struct future * __new_start;
  struct future * __new_finish = __new_start;

    const size_type __len;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__len = std::vector<std::future<long int> >::_M_check_len (this, 1, (const char *) "vector::_M_emplace_back_aux")) >>>>>;
    struct future * __new_start;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__new_start = std::_Vector_base<std::future<long int>, std::allocator<std::future<long int> > >::_M_allocate (&((struct vector *) this)->D.79511, (size_type) __len)) >>>>>;
    struct future * __new_finish = __new_start;
  <<< Unknown tree: try_block
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator_traits<std::allocator<std::future<long int> > >::construct<std::future<long int>, std::future<long int> > ((struct allocator_type &) (struct allocator *) &((struct vector *) this)->D.79511._M_impl, __new_start + (sizetype) (std::vector<std::future<long int> >::size (this) * 16), (struct future &) (struct future *) std::forward<std::future<long int> > ((struct type &) (struct future *) __args#0)) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__new_finish = 0B) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__new_finish = std::__uninitialized_move_if_noexcept_a<std::future<long int>*, std::future<long int>*, std::allocator<std::future<long int> > > (((struct vector *) this)->D.79511._M_impl._M_start, ((struct vector *) this)->D.79511._M_impl._M_finish, __new_start, (struct allocator &) (struct _Tp_alloc_type *) std::_Vector_base<std::future<long int>, std::allocator<std::future<long int> > >::_M_get_Tp_allocator (&((struct vector *) this)->D.79511))) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void)  ++__new_finish >>>>>;
  <<< Unknown tree: handler
  
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) __cxa_begin_catch (__builtin_eh_pointer (0)) >>>>>;
      if (__new_finish == 0B)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator_traits<std::allocator<std::future<long int> > >::destroy<std::future<long int> > ((struct allocator_type &) (struct allocator *) &((struct vector *) this)->D.79511._M_impl, __new_start + (sizetype) (std::vector<std::future<long int> >::size (this) * 16)) >>>>>;
        }
      else
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Destroy<std::future<long int>*, std::future<long int> > (__new_start, __new_finish, (struct allocator &) (struct _Tp_alloc_type *) std::_Vector_base<std::future<long int>, std::allocator<std::future<long int> > >::_M_get_Tp_allocator (&((struct vector *) this)->D.79511)) >>>>>;
        }
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Vector_base<std::future<long int>, std::allocator<std::future<long int> > >::_M_deallocate (&((struct vector *) this)->D.79511, __new_start, (size_type) __len) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  <<< Unknown tree: throw_expr
  __cxa_rethrow () >>> >>>>>;
    }
  finally
    {
      __cxa_end_catch ();
    } >>> >>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Destroy<std::future<long int>*, std::future<long int> > (((struct vector *) this)->D.79511._M_impl._M_start, ((struct vector *) this)->D.79511._M_impl._M_finish, (struct allocator &) (struct _Tp_alloc_type *) std::_Vector_base<std::future<long int>, std::allocator<std::future<long int> > >::_M_get_Tp_allocator (&((struct vector *) this)->D.79511)) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Vector_base<std::future<long int>, std::allocator<std::future<long int> > >::_M_deallocate (&((struct vector *) this)->D.79511, ((struct vector *) this)->D.79511._M_impl._M_start, (size_t) (((long int) ((struct vector *) this)->D.79511._M_impl._M_end_of_storage - (long int) ((struct vector *) this)->D.79511._M_impl._M_start) /[ex] 16)) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct vector *) this)->D.79511._M_impl._M_start = __new_start) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct vector *) this)->D.79511._M_impl._M_finish = __new_finish) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct vector *) this)->D.79511._M_impl._M_end_of_storage = __new_start + (sizetype) ((long unsigned int) __len * 16)) >>>>>;
}


;; Function static constexpr _Head& std::_Head_base<_Idx, _Head, false>::_M_head(std::_Head_base<_Idx, _Head, false>&) [with long unsigned int _Idx = 2ul; _Head = int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (int &) &__b->_M_head_impl
   >>>;


;; Function static constexpr _Head& std::_Tuple_impl<_Idx, _Head>::_M_head(std::_Tuple_impl<_Idx, _Head>&) [with long unsigned int _Idx = 2ul; _Head = int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (int &) (int *) std::_Head_base<2ul, int, false>::_M_head ((struct _Head_base &) &((struct _Tuple_impl *) __t)->D.100101)>>
   >>>;


;; Function constexpr std::_Head_base<_Idx, _Head, false>::_Head_base(_UHead&&) [with _UHead = int; long unsigned int _Idx = 2ul; _Head = int] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Head_base *) this)->_M_head_impl = *std::forward<int> ((type &) (int *) __h)) >>>>>;
}


;; Function constexpr std::_Tuple_impl<_Idx, _Head>::_Tuple_impl(std::_Tuple_impl<_Idx, _Head>&&) [with long unsigned int _Idx = 2ul; _Head = int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Head_base<2ul, int, false>::_Head_base<int> (&((struct _Tuple_impl *) this)->D.100101, (int &) (int *) std::forward<int> ((type &) (int *) std::_Tuple_impl<2ul, int>::_M_head ((struct _Tuple_impl &) (struct _Tuple_impl *) __in))) >>>>>;
  }
   >>>;


;; Function static constexpr std::_Tuple_impl<_Idx, _Head, _Tail ...>::_Inherited& std::_Tuple_impl<_Idx, _Head, _Tail ...>::_M_tail(std::_Tuple_impl<_Idx, _Head, _Tail ...>&) [with long unsigned int _Idx = 1ul; _Head = int; _Tail = {int}; std::_Tuple_impl<_Idx, _Head, _Tail ...>::_Inherited = std::_Tuple_impl<2ul, int>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct _Inherited &) &((struct _Tuple_impl *) __t)->D.100819
   >>>;


;; Function constexpr typename std::remove_reference< <template-parameter-1-1> >::type&& std::move(_Tp&&) [with _Tp = std::_Tuple_impl<2ul, int>&; typename std::remove_reference< <template-parameter-1-1> >::type = std::_Tuple_impl<2ul, int>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct type &) (struct type *) NON_LVALUE_EXPR <(struct type &) __t>
   >>>;


;; Function static constexpr _Head& std::_Head_base<_Idx, _Head, false>::_M_head(std::_Head_base<_Idx, _Head, false>&) [with long unsigned int _Idx = 1ul; _Head = int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (int &) &__b->_M_head_impl
   >>>;


;; Function static constexpr _Head& std::_Tuple_impl<_Idx, _Head, _Tail ...>::_M_head(std::_Tuple_impl<_Idx, _Head, _Tail ...>&) [with long unsigned int _Idx = 1ul; _Head = int; _Tail = {int}] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (int &) (int *) std::_Head_base<1ul, int, false>::_M_head ((struct _Head_base &) &((struct _Tuple_impl *) __t)->D.100820)>>
   >>>;


;; Function constexpr std::_Head_base<_Idx, _Head, false>::_Head_base(_UHead&&) [with _UHead = int; long unsigned int _Idx = 1ul; _Head = int] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Head_base *) this)->_M_head_impl = *std::forward<int> ((type &) (int *) __h)) >>>>>;
}


;; Function constexpr std::_Tuple_impl<_Idx, _Head, _Tail ...>::_Tuple_impl(std::_Tuple_impl<_Idx, _Head, _Tail ...>&&) [with long unsigned int _Idx = 1ul; _Head = int; _Tail = {int}] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Tuple_impl<2ul, int>::_Tuple_impl (&((struct _Tuple_impl *) this)->D.100819, (struct _Tuple_impl &) (struct type *) std::move<std::_Tuple_impl<2ul, int>&> ((struct _Tuple_impl &) (struct _Inherited *) std::_Tuple_impl<1ul, int, int>::_M_tail ((struct _Tuple_impl &) (struct _Tuple_impl *) __in))) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Head_base<1ul, int, false>::_Head_base<int> (&((struct _Tuple_impl *) this)->D.100820, (int &) (int *) std::forward<int> ((type &) (int *) std::_Tuple_impl<1ul, int, int>::_M_head ((struct _Tuple_impl &) (struct _Tuple_impl *) __in))) >>>>>;
  }
   >>>;


;; Function static constexpr std::_Tuple_impl<_Idx, _Head, _Tail ...>::_Inherited& std::_Tuple_impl<_Idx, _Head, _Tail ...>::_M_tail(std::_Tuple_impl<_Idx, _Head, _Tail ...>&) [with long unsigned int _Idx = 0ul; _Head = std::packaged_task<long int(int, int)>; _Tail = {int, int}; std::_Tuple_impl<_Idx, _Head, _Tail ...>::_Inherited = std::_Tuple_impl<1ul, int, int>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct _Inherited &) &((struct _Tuple_impl *) __t)->D.101575
   >>>;


;; Function constexpr typename std::remove_reference< <template-parameter-1-1> >::type&& std::move(_Tp&&) [with _Tp = std::_Tuple_impl<1ul, int, int>&; typename std::remove_reference< <template-parameter-1-1> >::type = std::_Tuple_impl<1ul, int, int>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct type &) (struct type *) NON_LVALUE_EXPR <(struct type &) __t>
   >>>;


;; Function static constexpr _Head& std::_Head_base<_Idx, _Head, false>::_M_head(std::_Head_base<_Idx, _Head, false>&) [with long unsigned int _Idx = 0ul; _Head = std::packaged_task<long int(int, int)>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct packaged_task &) &__b->_M_head_impl
   >>>;


;; Function static constexpr _Head& std::_Tuple_impl<_Idx, _Head, _Tail ...>::_M_head(std::_Tuple_impl<_Idx, _Head, _Tail ...>&) [with long unsigned int _Idx = 0ul; _Head = std::packaged_task<long int(int, int)>; _Tail = {int, int}] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct packaged_task &) (struct packaged_task *) std::_Head_base<0ul, std::packaged_task<long int(int, int)>, false>::_M_head ((struct _Head_base &) &((struct _Tuple_impl *) __t)->D.101576)>>
   >>>;


;; Function constexpr std::_Head_base<_Idx, _Head, false>::_Head_base(_UHead&&) [with _UHead = std::packaged_task<long int(int, int)>; long unsigned int _Idx = 0ul; _Head = std::packaged_task<long int(int, int)>] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::packaged_task<long int(int, int)>::packaged_task (&((struct _Head_base *) this)->_M_head_impl, (struct packaged_task &) (struct packaged_task *) std::forward<std::packaged_task<long int(int, int)> > ((struct type &) (struct packaged_task *) __h)) >>>>>;
  try
    {
      
    }
  catch
    {
      std::packaged_task<long int(int, int)>::~packaged_task (&((struct _Head_base *) this)->_M_head_impl);
    }
}


;; Function constexpr std::_Tuple_impl<_Idx, _Head, _Tail ...>::_Tuple_impl(std::_Tuple_impl<_Idx, _Head, _Tail ...>&&) [with long unsigned int _Idx = 0ul; _Head = std::packaged_task<long int(int, int)>; _Tail = {int, int}] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Tuple_impl<1ul, int, int>::_Tuple_impl (&((struct _Tuple_impl *) this)->D.101575, (struct _Tuple_impl &) (struct type *) std::move<std::_Tuple_impl<1ul, int, int>&> ((struct _Tuple_impl &) (struct _Inherited *) std::_Tuple_impl<0ul, std::packaged_task<long int(int, int)>, int, int>::_M_tail ((struct _Tuple_impl &) (struct _Tuple_impl *) __in))) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Head_base<0ul, std::packaged_task<long int(int, int)>, false>::_Head_base<std::packaged_task<long int(int, int)> > (&((struct _Tuple_impl *) this)->D.101576, (struct packaged_task &) (struct packaged_task *) std::forward<std::packaged_task<long int(int, int)> > ((struct type &) (struct packaged_task *) std::_Tuple_impl<0ul, std::packaged_task<long int(int, int)>, int, int>::_M_head ((struct _Tuple_impl &) (struct _Tuple_impl *) __in))) >>>>>;
    try
      {
        
      }
    catch
      {
        std::_Head_base<0ul, std::packaged_task<long int(int, int)>, false>::~_Head_base (&((struct _Tuple_impl *) this)->D.101576);
      }
  }
   >>>;


;; Function constexpr std::tuple< <template-parameter-1-1> >::tuple(std::tuple< <template-parameter-1-1> >&&) [with _Elements = {std::packaged_task<long int(int, int)>, int, int}] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Tuple_impl<0ul, std::packaged_task<long int(int, int)>, int, int>::_Tuple_impl (&((struct tuple *) this)->D.102039, (struct _Tuple_impl &) (struct _Tuple_impl *) NON_LVALUE_EXPR <(struct _Tuple_impl &) &((struct tuple *) D.101614)->D.102039>) >>>>>;
  try
    {
      
    }
  catch
    {
      std::_Tuple_impl<0ul, std::packaged_task<long int(int, int)>, int, int>::~_Tuple_impl (&((struct tuple *) this)->D.102039);
    }
}


;; Function std::_Bind_simple<_Callable(_Args ...)>::_Bind_simple(std::_Bind_simple<_Callable(_Args ...)>&&) [with _Callable = std::packaged_task<long int(int, int)>; _Args = {int, int}] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::tuple<std::packaged_task<long int(int, int)>, int, int>::tuple (&((struct _Bind_simple *) this)->_M_bound, (struct tuple &) (struct tuple *) NON_LVALUE_EXPR <(struct tuple &) &D.99434->_M_bound>) >>>>>;
  try
    {
      
    }
  catch
    {
      std::tuple<std::packaged_task<long int(int, int)>, int, int>::~tuple (&((struct _Bind_simple *) this)->_M_bound);
    }
}


;; Function typename std::_Bind_simple_helper<_Func, _BoundArgs>::__type std::__bind_simple(_Callable&&, _Args&& ...) [with _Callable = std::packaged_task<long int(int, int)>; _Args = {int&, int}; typename std::_Bind_simple_helper<_Func, _BoundArgs>::__type = std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)>] (null)
;; enabled by -tree-original


{
  typedef struct __helper_type __helper_type;
  typedef struct __maybe_type __maybe_type;
  typedef struct __result_type __result_type;

  <<cleanup_point return *<retval> = TARGET_EXPR <D.106255, <<< Unknown tree: aggr_init_expr
  7
  __comp_ctor 
  D.106255
  (struct _Bind_simple *) <<< Unknown tree: void_cst >>>
  (struct packaged_task &) (struct packaged_task *) std::_Maybe_wrap_member_pointer<std::packaged_task<long int(int, int)> >::__do_wrap ((struct packaged_task &) (struct packaged_task *) std::forward<std::packaged_task<long int(int, int)> > ((struct type &) (struct packaged_task *) __callable))
  (int &) (int *) std::forward<int&> ((type &) (int *) __args#0)
  (int &) (int *) std::forward<int> ((type &) (int *) __args#1) >>>>>>;
}


;; Function constexpr _Tp&& std::forward(typename std::remove_reference<_From>::type&) [with _Tp = std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)>; typename std::remove_reference<_From>::type = std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct _Bind_simple &) (struct _Bind_simple *) NON_LVALUE_EXPR <(struct _Bind_simple &) __t>
   >>>;


;; Function std::shared_ptr<std::thread::_Impl<_Callable> > std::thread::_M_make_routine(_Callable&&) [with _Callable = std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)>] (null)
;; enabled by -tree-original


<<cleanup_point return *<retval> = TARGET_EXPR <D.107334, <<< Unknown tree: aggr_init_expr
  4
  make_shared
  D.107334
  (struct _Bind_simple &) (struct _Bind_simple *) std::forward<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > ((struct type &) (struct _Bind_simple *) __f) >>>>>>;


;; Function constexpr typename std::remove_reference< <template-parameter-1-1> >::type&& std::move(_Tp&&) [with _Tp = std::shared_ptr<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >&; typename std::remove_reference< <template-parameter-1-1> >::type = std::shared_ptr<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct type &) (struct type *) NON_LVALUE_EXPR <(struct type &) __t>
   >>>;


;; Function std::shared_ptr<_Tp>::shared_ptr(std::shared_ptr<_Tp1>&&) [with _Tp1 = std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >; <template-parameter-2-2> = void; _Tp = std::thread::_Impl_base] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__shared_ptr<std::thread::_Impl_base, (__gnu_cxx::_Lock_policy)2u>::__shared_ptr<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >, void> (&((struct shared_ptr *) this)->D.52702, (struct __shared_ptr &) (struct __shared_ptr *) NON_LVALUE_EXPR <(struct __shared_ptr &) &((struct type *) std::move<std::shared_ptr<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >&> ((struct shared_ptr &) (struct shared_ptr *) __r))->D.103679>) >>>>>;
    try
      {
        
      }
    catch
      {
        std::__shared_ptr<std::thread::_Impl_base, (__gnu_cxx::_Lock_policy)2u>::~__shared_ptr (&((struct shared_ptr *) this)->D.52702);
      }
  }
   >>>;


;; Function constexpr typename std::remove_reference< <template-parameter-1-1> >::type&& std::move(_Tp&&) [with _Tp = std::shared_ptr<std::thread::_Impl_base>&; typename std::remove_reference< <template-parameter-1-1> >::type = std::shared_ptr<std::thread::_Impl_base>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct type &) (struct type *) NON_LVALUE_EXPR <(struct type &) __t>
   >>>;


;; Function std::shared_ptr<_Tp>::shared_ptr(std::shared_ptr<_Tp>&&) [with _Tp = std::thread::_Impl_base] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__shared_ptr<std::thread::_Impl_base, (__gnu_cxx::_Lock_policy)2u>::__shared_ptr (&((struct shared_ptr *) this)->D.52702, (struct __shared_ptr &) (struct __shared_ptr *) NON_LVALUE_EXPR <(struct __shared_ptr &) &((struct type *) std::move<std::shared_ptr<std::thread::_Impl_base>&> ((struct shared_ptr &) (struct shared_ptr *) __r))->D.52702>) >>>>>;
    try
      {
        
      }
    catch
      {
        std::__shared_ptr<std::thread::_Impl_base, (__gnu_cxx::_Lock_policy)2u>::~__shared_ptr (&((struct shared_ptr *) this)->D.52702);
      }
  }
   >>>;


;; Function constexpr _Tp&& std::forward(typename std::remove_reference<_From>::type&) [with _Tp = std::thread*; typename std::remove_reference<_From>::type = std::thread*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct thread * &) (struct thread * *) (struct thread * &) __t
   >>>;


;; Function void std::vector<_Tp, _Alloc>::emplace_back(_Args&& ...) [with _Args = {std::thread*}; _Tp = std::thread*; _Alloc = std::allocator<std::thread*>] (null)
;; enabled by -tree-original


if (((struct vector *) this)->D.80632._M_impl._M_finish != ((struct vector *) this)->D.80632._M_impl._M_end_of_storage)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator_traits<std::allocator<std::thread*> >::construct<std::thread*, std::thread*> ((struct allocator_type &) (struct allocator *) &((struct vector *) this)->D.80632._M_impl, ((struct vector *) this)->D.80632._M_impl._M_finish, (struct thread * &) (struct thread * *) std::forward<std::thread*> ((struct thread * &) (struct thread * *) __args#0)) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void)  ++((struct vector *) this)->D.80632._M_impl._M_finish >>>>>;
  }
else
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::vector<std::thread*>::_M_emplace_back_aux<std::thread*> (this, (struct thread * &) (struct thread * *) std::forward<std::thread*> ((struct thread * &) (struct thread * *) __args#0)) >>>>>;
  }


;; Function void std::vector<_Tp, _Alloc>::_M_erase_at_end(std::vector<_Tp, _Alloc>::pointer) [with _Tp = std::packaged_task<long int(int, int)>; _Alloc = std::allocator<std::packaged_task<long int(int, int)> >; std::vector<_Tp, _Alloc>::pointer = std::packaged_task<long int(int, int)>*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Destroy<std::packaged_task<long int(int, int)>*, std::packaged_task<long int(int, int)> > (__pos, ((struct vector *) this)->D.78390._M_impl._M_finish, (struct allocator &) (struct _Tp_alloc_type *) std::_Vector_base<std::packaged_task<long int(int, int)>, std::allocator<std::packaged_task<long int(int, int)> > >::_M_get_Tp_allocator (&((struct vector *) this)->D.78390)) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct vector *) this)->D.78390._M_impl._M_finish = __pos) >>>>>;
   >>>;


;; Function void std::vector<_Tp, _Alloc>::_M_erase_at_end(std::vector<_Tp, _Alloc>::pointer) [with _Tp = std::thread*; _Alloc = std::allocator<std::thread*>; std::vector<_Tp, _Alloc>::pointer = std::thread**] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Destroy<std::thread**, std::thread*> (__pos, ((struct vector *) this)->D.80632._M_impl._M_finish, (struct allocator &) (struct _Tp_alloc_type *) std::_Vector_base<std::thread*, std::allocator<std::thread*> >::_M_get_Tp_allocator (&((struct vector *) this)->D.80632)) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct vector *) this)->D.80632._M_impl._M_finish = __pos) >>>>>;
   >>>;


;; Function std::__basic_future<_Res>::_Reset::_Reset(std::__basic_future<_Res>&) [with _Res = long int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Reset *) this)->_M_fut = (struct __basic_future &) (struct __basic_future *) __fut) >>>>>;
  }
   >>>;


;; Function std::__basic_future<_Res>::_Reset::~_Reset() [with _Res = long int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    try
      {
        <<cleanup_point <<< Unknown tree: expr_stmt
  std::__shared_ptr<std::__future_base::_State_baseV2, (__gnu_cxx::_Lock_policy)2u>::reset (&((struct _Reset *) this)->_M_fut->_M_state.D.69901) >>>>>;
      }
    finally
      {
        *(struct 
        {
          struct __basic_future & _M_fut;
        } &) this = {CLOBBER};
      }
  }
  <D.107445>:;
   >>>;


;; Function std::__future_base::_Result<_Res>& std::__basic_future<_Res>::_M_get_result() const [with _Res = long int; std::__basic_future<_Res>::__result_type = std::__future_base::_Result<long int>&] (null)
;; enabled by -tree-original


{
  struct _Result_base & __res;

  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__future_base::_State_baseV2::_S_check<std::__future_base::_State_baseV2> ((const struct shared_ptr &) &((const struct __basic_future *) this)->_M_state) >>>>>;
    struct _Result_base & __res;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__res = (struct _Result_base &) (struct _Result_base *) std::__future_base::_State_baseV2::wait (std::__shared_ptr<std::__future_base::_State_baseV2, (__gnu_cxx::_Lock_policy)2u>::operator-> (&((const struct __basic_future *) this)->_M_state.D.69901))) >>>>>;
  if (<<cleanup_point !std::__exception_ptr::operator== ((const struct exception_ptr &) (const struct exception_ptr *) &__res->_M_error, (const struct exception_ptr &) &TARGET_EXPR <D.107453, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.107453
  (const struct exception_ptr *) <<< Unknown tree: void_cst >>>
  0 >>>>)>>)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::rethrow_exception (&TARGET_EXPR <D.107454, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.107454
  (struct exception_ptr *) <<< Unknown tree: void_cst >>>
  (const struct exception_ptr &) (const struct exception_ptr *) &__res->_M_error >>>>) >>>>>;
    }
  return <retval> = (struct _Result &) (struct _Result *) NON_LVALUE_EXPR <(struct _Result &) __res>;
}


;; Function _Res& std::__future_base::_Result<_Res>::_M_value() [with _Res = long int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (long int &) __gnu_cxx::__aligned_buffer<long int>::_M_ptr (&((struct _Result *) this)->_M_storage)>>
   >>>;


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_construct(_InIterator, _InIterator) [with _InIterator = char*; _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>] (null)
;; enabled by -tree-original


{
  typedef struct _Integral _Integral;

  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_M_construct_aux<char*> (this, __beg, __end, TARGET_EXPR <D.107464, {}>;, <<< Unknown tree: empty_class_expr >>>;) >>>>>;
}


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_destroy(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator_traits<std::allocator<char> >::deallocate ((struct allocator_type &) (struct allocator_type *) std::__cxx11::basic_string<char>::_M_get_allocator (this), std::__cxx11::basic_string<char>::_M_data (this), __size + 1) >>>>>
   >>>;


;; Function static _Tp* std::pointer_traits<_Tp*>::pointer_to(typename std::__ptrtr_not_void<_Tp>::__type&) [with _Tp = char; std::pointer_traits<_Tp*>::pointer = char*; typename std::__ptrtr_not_void<_Tp>::__type = char] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (char *) std::addressof<char> ((char &) (__type *) __r)>>
   >>>;


;; Function std::allocator< <template-parameter-1-1> >::allocator(const std::allocator< <template-parameter-1-1> >&) [with _Tp = char] (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<char>::new_allocator ((struct new_allocator *) this, (const struct new_allocator &) (const struct new_allocator *) (const struct allocator *) __a) >>>>>;
    try
      {
        
      }
    catch
      {
        __gnu_cxx::new_allocator<char>::~new_allocator ((struct new_allocator *) this);
      }
  }
   >>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_pointer std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_local_data() const [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_pointer = const char*] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (const char *) std::pointer_traits<const char*>::pointer_to ((const __type &) (const char *) &((const struct basic_string *) this)->D.17414._M_local_buf)>>;


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_construct(_InIterator, _InIterator) [with _InIterator = wchar_t*; _CharT = wchar_t; _Traits = std::char_traits<wchar_t>; _Alloc = std::allocator<wchar_t>] (null)
;; enabled by -tree-original


{
  typedef struct _Integral _Integral;

  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<wchar_t>::_M_construct_aux<wchar_t*> (this, __beg, __end, TARGET_EXPR <D.107525, {}>;, <<< Unknown tree: empty_class_expr >>>;) >>>>>;
}


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_destroy(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type) [with _CharT = wchar_t; _Traits = std::char_traits<wchar_t>; _Alloc = std::allocator<wchar_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator_traits<std::allocator<wchar_t> >::deallocate ((struct allocator_type &) (struct allocator_type *) std::__cxx11::basic_string<wchar_t>::_M_get_allocator (this), std::__cxx11::basic_string<wchar_t>::_M_data (this), __size + 1) >>>>>
   >>>;


;; Function static _Tp* std::pointer_traits<_Tp*>::pointer_to(typename std::__ptrtr_not_void<_Tp>::__type&) [with _Tp = wchar_t; std::pointer_traits<_Tp*>::pointer = wchar_t*; typename std::__ptrtr_not_void<_Tp>::__type = wchar_t] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (wchar_t *) std::addressof<wchar_t> ((wchar_t &) (__type *) __r)>>
   >>>;


;; Function std::allocator< <template-parameter-1-1> >::allocator(const std::allocator< <template-parameter-1-1> >&) [with _Tp = wchar_t] (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<wchar_t>::new_allocator ((struct new_allocator *) this, (const struct new_allocator &) (const struct new_allocator *) (const struct allocator *) __a) >>>>>;
    try
      {
        
      }
    catch
      {
        __gnu_cxx::new_allocator<wchar_t>::~new_allocator ((struct new_allocator *) this);
      }
  }
   >>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_pointer std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_local_data() const [with _CharT = wchar_t; _Traits = std::char_traits<wchar_t>; _Alloc = std::allocator<wchar_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_pointer = const wchar_t*] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (const wchar_t *) std::pointer_traits<const wchar_t*>::pointer_to ((const __type &) (const wchar_t *) &((const struct basic_string *) this)->D.18784._M_local_buf)>>;


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_construct_aux(_InIterator, _InIterator, std::__false_type) [with _InIterator = const char*; _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>] (null)
;; enabled by -tree-original


{
  typedef struct _Tag _Tag;

  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_M_construct<const char*> (this, __beg, __end, TARGET_EXPR <D.107690, *(struct forward_iterator_tag &) (struct forward_iterator_tag *) NON_LVALUE_EXPR <(struct forward_iterator_tag &) &TARGET_EXPR <D.107670, {}>>>;, <<< Unknown tree: empty_class_expr >>>;) >>>>>;
}


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_construct_aux(_InIterator, _InIterator, std::__false_type) [with _InIterator = const wchar_t*; _CharT = wchar_t; _Traits = std::char_traits<wchar_t>; _Alloc = std::allocator<wchar_t>] (null)
;; enabled by -tree-original


{
  typedef struct _Tag _Tag;

  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<wchar_t>::_M_construct<const wchar_t*> (this, __beg, __end, TARGET_EXPR <D.107712, *(struct forward_iterator_tag &) (struct forward_iterator_tag *) NON_LVALUE_EXPR <(struct forward_iterator_tag &) &TARGET_EXPR <D.107701, {}>>>;, <<< Unknown tree: empty_class_expr >>>;) >>>>>;
}


;; Function static _Tp* std::pointer_traits<_Tp*>::pointer_to(typename std::__ptrtr_not_void<_Tp>::__type&) [with _Tp = char16_t; std::pointer_traits<_Tp*>::pointer = char16_t*; typename std::__ptrtr_not_void<_Tp>::__type = char16_t] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (char16_t *) std::addressof<char16_t> ((char16_t &) (__type *) __r)>>
   >>>;


;; Function std::allocator< <template-parameter-1-1> >::allocator(const std::allocator< <template-parameter-1-1> >&) [with _Tp = char16_t] (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<char16_t>::new_allocator ((struct new_allocator *) this, (const struct new_allocator &) (const struct new_allocator *) (const struct allocator *) __a) >>>>>;
    try
      {
        
      }
    catch
      {
        __gnu_cxx::new_allocator<char16_t>::~new_allocator ((struct new_allocator *) this);
      }
  }
   >>>;


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_construct_aux(_InIterator, _InIterator, std::__false_type) [with _InIterator = const char16_t*; _CharT = char16_t; _Traits = std::char_traits<char16_t>; _Alloc = std::allocator<char16_t>] (null)
;; enabled by -tree-original


{
  typedef struct _Tag _Tag;

  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char16_t>::_M_construct<const char16_t*> (this, __beg, __end, TARGET_EXPR <D.107749, *(struct forward_iterator_tag &) (struct forward_iterator_tag *) NON_LVALUE_EXPR <(struct forward_iterator_tag &) &TARGET_EXPR <D.107738, {}>>>;, <<< Unknown tree: empty_class_expr >>>;) >>>>>;
}


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_destroy(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type) [with _CharT = char16_t; _Traits = std::char_traits<char16_t>; _Alloc = std::allocator<char16_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator_traits<std::allocator<char16_t> >::deallocate ((struct allocator_type &) (struct allocator_type *) std::__cxx11::basic_string<char16_t>::_M_get_allocator (this), std::__cxx11::basic_string<char16_t>::_M_data (this), __size + 1) >>>>>
   >>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_pointer std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_local_data() const [with _CharT = char16_t; _Traits = std::char_traits<char16_t>; _Alloc = std::allocator<char16_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_pointer = const char16_t*] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (const char16_t *) std::pointer_traits<const char16_t*>::pointer_to ((const __type &) (const char16_t *) &((const struct basic_string *) this)->D.20554._M_local_buf)>>;


;; Function static _Tp* std::pointer_traits<_Tp*>::pointer_to(typename std::__ptrtr_not_void<_Tp>::__type&) [with _Tp = char32_t; std::pointer_traits<_Tp*>::pointer = char32_t*; typename std::__ptrtr_not_void<_Tp>::__type = char32_t] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (char32_t *) std::addressof<char32_t> ((char32_t &) (__type *) __r)>>
   >>>;


;; Function std::allocator< <template-parameter-1-1> >::allocator(const std::allocator< <template-parameter-1-1> >&) [with _Tp = char32_t] (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<char32_t>::new_allocator ((struct new_allocator *) this, (const struct new_allocator &) (const struct new_allocator *) (const struct allocator *) __a) >>>>>;
    try
      {
        
      }
    catch
      {
        __gnu_cxx::new_allocator<char32_t>::~new_allocator ((struct new_allocator *) this);
      }
  }
   >>>;


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_construct_aux(_InIterator, _InIterator, std::__false_type) [with _InIterator = const char32_t*; _CharT = char32_t; _Traits = std::char_traits<char32_t>; _Alloc = std::allocator<char32_t>] (null)
;; enabled by -tree-original


{
  typedef struct _Tag _Tag;

  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char32_t>::_M_construct<const char32_t*> (this, __beg, __end, TARGET_EXPR <D.107818, *(struct forward_iterator_tag &) (struct forward_iterator_tag *) NON_LVALUE_EXPR <(struct forward_iterator_tag &) &TARGET_EXPR <D.107807, {}>>>;, <<< Unknown tree: empty_class_expr >>>;) >>>>>;
}


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_destroy(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type) [with _CharT = char32_t; _Traits = std::char_traits<char32_t>; _Alloc = std::allocator<char32_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator_traits<std::allocator<char32_t> >::deallocate ((struct allocator_type &) (struct allocator_type *) std::__cxx11::basic_string<char32_t>::_M_get_allocator (this), std::__cxx11::basic_string<char32_t>::_M_data (this), __size + 1) >>>>>
   >>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_pointer std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_local_data() const [with _CharT = char32_t; _Traits = std::char_traits<char32_t>; _Alloc = std::allocator<char32_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_pointer = const char32_t*] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (const char32_t *) std::pointer_traits<const char32_t*>::pointer_to ((const __type &) (const char32_t *) &((const struct basic_string *) this)->D.21840._M_local_buf)>>;


;; Function const allocator_type& std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_get_allocator() const [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::allocator_type = std::allocator<char>] (null)
;; enabled by -tree-original


return <retval> = (const struct allocator_type &) (const struct allocator *) &((const struct basic_string *) this)->_M_dataplus;


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_check_length(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, const char*) const [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


if (<<cleanup_point std::__cxx11::basic_string<char>::max_size (this) + (__n1 - std::__cxx11::basic_string<char>::size (this)) < __n2>>)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_length_error (*(const char * &) &__s) >>>>>;
  }


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>& std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, const _CharT*, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (struct basic_string &) (struct basic_string *) std::__cxx11::basic_string<char>::_M_replace (this, std::__cxx11::basic_string<char>::_M_check (this, __pos, (const char *) "basic_string::replace"), std::__cxx11::basic_string<char>::_M_limit (this, __pos, __n1), __s, __n2)>>;


;; Function void std::_Sp_counted_base<_Lp>::_M_destroy() [with __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  if ((struct _Sp_counted_base *) this != 0B)
    {
      OBJ_TYPE_REF(*(((struct _Sp_counted_base *) this)->_vptr._Sp_counted_base + 8);(struct _Sp_counted_base)this->1) (this);
    }
  else
    {
      <<< Unknown tree: void_cst >>>
    } >>>>>
   >>>;


;; Function __gnu_cxx::new_allocator<_Tp>::new_allocator() [with _Tp = std::mutex] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    
  }
   >>>;


;; Function __gnu_cxx::new_allocator<_Tp>::~new_allocator() [with _Tp = std::mutex] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    
  }
  <D.107859>:;
   >>>;


;; Function std::shared_ptr<_Tp>::shared_ptr(std::_Sp_make_shared_tag, const _Alloc&, _Args&& ...) [with _Alloc = std::allocator<std::mutex>; _Args = {}; _Tp = std::mutex] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__shared_ptr<std::mutex, (__gnu_cxx::_Lock_policy)2u>::__shared_ptr<std::allocator<std::mutex> > (&((struct shared_ptr *) this)->D.61009, TARGET_EXPR <D.107878, __tag>;, <<< Unknown tree: empty_class_expr >>>;, (const struct allocator &) (const struct allocator *) __a) >>>>>;
  try
    {
      
    }
  catch
    {
      std::__shared_ptr<std::mutex, (__gnu_cxx::_Lock_policy)2u>::~__shared_ptr (&((struct shared_ptr *) this)->D.61009);
    }
}


;; Function std::__atomic_base<_IntTp>::__int_type std::__atomic_base<_IntTp>::load(std::memory_order) const [with _ITp = unsigned int; std::__atomic_base<_IntTp>::__int_type = unsigned int; std::memory_order = std::memory_order] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    memory_order __b;

        memory_order __b;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__b = std::operator& (__m, 65535)) >>>>>;
    <<cleanup_point return <retval> = __atomic_load_4 ((const void *) &((const struct __atomic_base *) this)->_M_i, (int) __m)>>;
  }
   >>>;


;; Function unsigned int std::__atomic_futex_unsigned<_Waiter_bit>::_M_load_and_test_until(unsigned int, unsigned int, bool, std::memory_order, bool, std::chrono::seconds, std::chrono::nanoseconds) [with unsigned int _Waiter_bit = 2147483648u; std::memory_order = std::memory_order; std::chrono::seconds = std::chrono::duration<long int>; std::chrono::nanoseconds = std::chrono::duration<long int, std::ratio<1l, 1000000000l> >] (null)
;; enabled by -tree-original


{
  {
    while (1)
      {
        {
          bool __ret;

          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::__atomic_base<unsigned int>::fetch_or (&((struct __atomic_futex_unsigned *) this)->_M_data.D.56070, 2147483648, 0) >>>>>;
                    bool __ret;
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__ret = std::__atomic_futex_unsigned_base::_M_futex_wait_until ((struct __atomic_futex_unsigned_base *) this, (unsigned int *) (void *) &((struct __atomic_futex_unsigned *) this)->_M_data, __assumed | 2147483648, (int) __has_timeout, TARGET_EXPR <D.107886, __s>, TARGET_EXPR <D.107887, __ns>)) >>>>>;
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__assumed = std::__atomic_futex_unsigned<>::_M_load (this, __mo)) >>>>>;
          if (!__ret || (__operand == __assumed) == (int) __equal)
            {
              return <retval> = __assumed;
            }
        }
      }
  }
}


;; Function std::_Mem_fn<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)>::_Mem_fn(std::_Mem_fn_base<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*), true>::_Pmf) (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Mem_fn_base<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*), true>::_Mem_fn_base (&((struct _Mem_fn *) this)->D.84132, *(struct _Pmf &) &D.84124) >>>>>;
}


;; Function static std::_Maybe_wrap_member_pointer<_Tp _Class::*>::type std::_Maybe_wrap_member_pointer<_Tp _Class::*>::__do_wrap(_Tp _Class::*) [with _Tp = void(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*); _Class = std::__future_base::_State_baseV2; std::_Maybe_wrap_member_pointer<_Tp _Class::*>::type = std::_Mem_fn<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)>] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = TARGET_EXPR <D.107894, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.107894
  (struct _Mem_fn *) <<< Unknown tree: void_cst >>>
  __pm >>>>;, D.107894>>;


;; Function constexpr std::_Tuple_impl<_Idx, _Head>::_Tuple_impl(_UHead&&) [with _UHead = bool*; long unsigned int _Idx = 3ul; _Head = bool*] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Head_base<3ul, bool*, false>::_Head_base<bool*> (&((struct _Tuple_impl *) this)->D.85250, (bool * &) (bool * *) std::forward<bool*> ((bool * &) (bool * *) __head)) >>>>>;
}


;; Function constexpr std::_Tuple_impl<_Idx, _Head, _Tail ...>::_Tuple_impl(_UHead&&, _UTail&& ...) [with _UHead = std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*; _UTail = {bool*}; <template-parameter-2-3> = void; long unsigned int _Idx = 2ul; _Head = std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*; _Tail = {bool*}] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Tuple_impl<3ul, bool*>::_Tuple_impl<bool*> (&((struct _Tuple_impl *) this)->D.85972, (bool * &) (bool * *) std::forward<bool*> ((bool * &) (bool * *) __tail#0)) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Head_base<2ul, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, false>::_Head_base<std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*> (&((struct _Tuple_impl *) this)->D.85973, (struct function * &) (struct function * *) std::forward<std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*> ((struct function * &) (struct function * *) __head)) >>>>>;
}


;; Function constexpr std::_Tuple_impl<_Idx, _Head, _Tail ...>::_Tuple_impl(_UHead&&, _UTail&& ...) [with _UHead = std::__future_base::_State_baseV2*; _UTail = {std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*}; <template-parameter-2-3> = void; long unsigned int _Idx = 1ul; _Head = std::__future_base::_State_baseV2*; _Tail = {std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*}] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Tuple_impl<2ul, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*>::_Tuple_impl<std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*, void> (&((struct _Tuple_impl *) this)->D.86699, (struct function * &) (struct function * *) std::forward<std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*> ((struct function * &) (struct function * *) __tail#0), (bool * &) (bool * *) std::forward<bool*> ((bool * &) (bool * *) __tail#1)) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Head_base<1ul, std::__future_base::_State_baseV2*, false>::_Head_base<std::__future_base::_State_baseV2*> (&((struct _Tuple_impl *) this)->D.86700, (struct _State_baseV2 * &) (struct _State_baseV2 * *) std::forward<std::__future_base::_State_baseV2*> ((struct _State_baseV2 * &) (struct _State_baseV2 * *) __head)) >>>>>;
}


;; Function constexpr std::_Tuple_impl<_Idx, _Head, _Tail ...>::_Tuple_impl(_UHead&&, _UTail&& ...) [with _UHead = std::_Mem_fn<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)>; _UTail = {std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*}; <template-parameter-2-3> = void; long unsigned int _Idx = 0ul; _Head = std::_Mem_fn<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)>; _Tail = {std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*}] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Tuple_impl<1ul, std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*>::_Tuple_impl<std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*, void> (&((struct _Tuple_impl *) this)->D.87475, (struct _State_baseV2 * &) (struct _State_baseV2 * *) std::forward<std::__future_base::_State_baseV2*> ((struct _State_baseV2 * &) (struct _State_baseV2 * *) __tail#0), (struct function * &) (struct function * *) std::forward<std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*> ((struct function * &) (struct function * *) __tail#1), (bool * &) (bool * *) std::forward<bool*> ((bool * &) (bool * *) __tail#2)) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Head_base<0ul, std::_Mem_fn<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)>, false>::_Head_base<std::_Mem_fn<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)> > (&((struct _Tuple_impl *) this)->D.87476, (struct _Mem_fn &) (struct _Mem_fn *) std::forward<std::_Mem_fn<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)> > ((struct type &) (struct _Mem_fn *) __head)) >>>>>;
}


;; Function constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::_Mem_fn<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)>, std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*}; <template-parameter-2-2> = void; _Elements = {std::_Mem_fn<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)>, std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*}] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Tuple_impl<0ul, std::_Mem_fn<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)>, std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*>::_Tuple_impl<std::_Mem_fn<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)>, std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*, void> (&((struct tuple *) this)->D.87947, (struct _Mem_fn &) (struct _Mem_fn *) std::forward<std::_Mem_fn<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)> > ((struct type &) (struct _Mem_fn *) __elements#0), (struct _State_baseV2 * &) (struct _State_baseV2 * *) std::forward<std::__future_base::_State_baseV2*> ((struct _State_baseV2 * &) (struct _State_baseV2 * *) __elements#1), (struct function * &) (struct function * *) std::forward<std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*> ((struct function * &) (struct function * *) __elements#2), (bool * &) (bool * *) std::forward<bool*> ((bool * &) (bool * *) __elements#3)) >>>>>;
}


;; Function std::_Bind_simple<_Callable(_Args ...)>::_Bind_simple(_Tp&&, _Up&& ...) [with _Tp = std::_Mem_fn<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)>; _Up = {std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*}; _Callable = std::_Mem_fn<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)>; _Args = {std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*}] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::tuple<std::_Mem_fn<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)>, std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*>::tuple<std::_Mem_fn<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)>, std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*, void> (&((struct _Bind_simple *) this)->_M_bound, (struct _Mem_fn &) (struct _Mem_fn *) std::forward<std::_Mem_fn<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)> > ((struct type &) (struct _Mem_fn *) __f), (struct _State_baseV2 * &) (struct _State_baseV2 * *) std::forward<std::__future_base::_State_baseV2*> ((struct _State_baseV2 * &) (struct _State_baseV2 * *) __args#0), (struct function * &) (struct function * *) std::forward<std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*> ((struct function * &) (struct function * *) __args#1), (bool * &) (bool * *) std::forward<bool*> ((bool * &) (bool * *) __args#2)) >>>>>;
}


;; Function std::_Bind_simple<_Callable(_Args ...)>::result_type std::_Bind_simple<_Callable(_Args ...)>::operator()() [with _Callable = std::_Mem_fn<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)>; _Args = {std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*}; std::_Bind_simple<_Callable(_Args ...)>::result_type = void] (null)
;; enabled by -tree-original


{
  typedef struct _Indices _Indices;

  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Bind_simple<std::_Mem_fn<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)>(std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)>::_M_invoke<0ul, 1ul, 2ul> (this, TARGET_EXPR <D.108039, {}>;, <<< Unknown tree: empty_class_expr >>>;) >>>>>;
  return;
}


;; Function void std::tuple<_T1, _T2>::swap(std::tuple<_T1, _T2>&) [with _T1 = std::__future_base::_Result_base*; _T2 = std::__future_base::_Result_base::_Deleter] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Tuple_impl<0ul, std::__future_base::_Result_base*, std::__future_base::_Result_base::_Deleter>::_M_swap (&((struct tuple *) this)->D.64132, (struct _Tuple_impl &) &((struct tuple *) __in)->D.64132) >>>>>
   >>>;


;; Function void std::_Sp_counted_base<_Lp>::_M_add_ref_copy() [with __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::__atomic_add_dispatch (&((struct _Sp_counted_base *) this)->_M_use_count, 1) >>>>>;


;; Function __gnu_cxx::new_allocator<_Tp>::new_allocator() [with _Tp = std::__future_base::_State_baseV2] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    
  }
   >>>;


;; Function __gnu_cxx::new_allocator<_Tp>::~new_allocator() [with _Tp = std::__future_base::_State_baseV2] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    
  }
  <D.108060>:;
   >>>;


;; Function std::shared_ptr<_Tp>::shared_ptr(std::_Sp_make_shared_tag, const _Alloc&, _Args&& ...) [with _Alloc = std::allocator<std::__future_base::_State_baseV2>; _Args = {}; _Tp = std::__future_base::_State_baseV2] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__shared_ptr<std::__future_base::_State_baseV2, (__gnu_cxx::_Lock_policy)2u>::__shared_ptr<std::allocator<std::__future_base::_State_baseV2> > (&((struct shared_ptr *) this)->D.69901, TARGET_EXPR <D.108079, __tag>;, <<< Unknown tree: empty_class_expr >>>;, (const struct allocator &) (const struct allocator *) __a) >>>>>;
  try
    {
      
    }
  catch
    {
      std::__shared_ptr<std::__future_base::_State_baseV2, (__gnu_cxx::_Lock_policy)2u>::~__shared_ptr (&((struct shared_ptr *) this)->D.69901);
    }
}


;; Function static constexpr const _Head& std::_Head_base<_Idx, _Head, false>::_M_head(const std::_Head_base<_Idx, _Head, false>&) [with long unsigned int _Idx = 0ul; _Head = std::__future_base::_Result<void>*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct _Result * const &) &__b->_M_head_impl
   >>>;


;; Function static constexpr const _Head& std::_Tuple_impl<_Idx, _Head, _Tail ...>::_M_head(const std::_Tuple_impl<_Idx, _Head, _Tail ...>&) [with long unsigned int _Idx = 0ul; _Head = std::__future_base::_Result<void>*; _Tail = {std::__future_base::_Result_base::_Deleter}] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct _Result * const &) (struct _Result * const *) std::_Head_base<0ul, std::__future_base::_Result<void>*, false>::_M_head ((const struct _Head_base &) &((const struct _Tuple_impl *) __t)->D.71551)>>
   >>>;


;; Function constexpr const _Head& std::__get_helper(const std::_Tuple_impl<_Idx, _Head, _Tail ...>&) [with long unsigned int __i = 0ul; _Head = std::__future_base::_Result<void>*; _Tail = {std::__future_base::_Result_base::_Deleter}] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct _Result * const &) (struct _Result * const *) std::_Tuple_impl<0ul, std::__future_base::_Result<void>*, std::__future_base::_Result_base::_Deleter>::_M_head ((const struct _Tuple_impl &) (const struct _Tuple_impl *) __t)>>
   >>>;


;; Function constexpr std::__tuple_element_t<__i, std::tuple<_Elements ...> >& std::get(const std::tuple<_Elements ...>&) [with long unsigned int __i = 0ul; _Elements = {std::__future_base::_Result<void>*, std::__future_base::_Result_base::_Deleter}; std::__tuple_element_t<__i, std::tuple<_Elements ...> > = std::__future_base::_Result<void>*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct _Result * const &) (struct _Result * const *) std::__get_helper<0ul, std::__future_base::_Result<void>*, std::__future_base::_Result_base::_Deleter> ((const struct _Tuple_impl &) &((const struct tuple *) __t)->D.72219)>>
   >>>;


;; Function std::unique_ptr<_Tp, _Dp>::pointer std::unique_ptr<_Tp, _Dp>::get() const [with _Tp = std::__future_base::_Result<void>; _Dp = std::__future_base::_Result_base::_Deleter; std::unique_ptr<_Tp, _Dp>::pointer = std::__future_base::_Result<void>*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct _Result *) *std::get<0ul, std::__future_base::_Result<void>*, std::__future_base::_Result_base::_Deleter> ((const struct tuple &) &((const struct unique_ptr *) this)->_M_t)>>
   >>>;


;; Function long int std::__shared_count<_Lp>::_M_get_use_count() const [with __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct _Sp_counted_base *) ((const struct __shared_count *) this)->_M_pi != 0B ? std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2u>::_M_get_use_count ((struct _Sp_counted_base *) ((const struct __shared_count *) this)->_M_pi) : 0>>
   >>>;


;; Function void std::tuple<_T1, _T2>::swap(std::tuple<_T1, _T2>&) [with _T1 = std::__future_base::_Result<void>*; _T2 = std::__future_base::_Result_base::_Deleter] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Tuple_impl<0ul, std::__future_base::_Result<void>*, std::__future_base::_Result_base::_Deleter>::_M_swap (&((struct tuple *) this)->D.72219, (struct _Tuple_impl &) &((struct tuple *) __in)->D.72219) >>>>>
   >>>;


;; Function static void std::_Function_base::_Base_manager<_Functor>::_M_init_functor(std::_Any_data&, _Functor&&, std::true_type) [with _Functor = std::__future_base::_State_baseV2::_Setter<void, std::__future_base::_State_baseV2::__exception_ptr_tag>; std::true_type = std::integral_constant<bool, true>] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (TARGET_EXPR <D.108119, (struct _Setter *) (struct _Setter &) (struct type *) std::move<std::__future_base::_State_baseV2::_Setter<void, std::__future_base::_State_baseV2::__exception_ptr_tag>&> ((struct _Setter &) (struct _Setter *) __f)>;, TARGET_EXPR <D.108117, std::_Any_data::_M_access ((union _Any_data *) __functor)>;, TARGET_EXPR <D.108118, operator new (16, NON_LVALUE_EXPR <D.108117>)>;;, (struct _Setter *) D.108118 != 0B ? try
    {
      *(struct _Setter *) D.108118 = *NON_LVALUE_EXPR <(struct _Setter &) NON_LVALUE_EXPR <D.108119>>;
    }
  catch
    {
      operator delete (D.108118, NON_LVALUE_EXPR <D.108117>);
    }, (struct _Setter *) D.108118; : (struct _Setter *) D.108118;) >>>>>;


;; Function static _Functor* std::_Function_base::_Base_manager<_Functor>::_M_get_pointer(const std::_Any_data&) [with _Functor = std::__future_base::_State_baseV2::_Setter<void, std::__future_base::_State_baseV2::__exception_ptr_tag>] (null)
;; enabled by -tree-original


{
  const struct _Setter * __ptr;

    const struct _Setter * __ptr;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__ptr = std::__addressof<const std::__future_base::_State_baseV2::_Setter<void, std::__future_base::_State_baseV2::__exception_ptr_tag> > ((const struct _Setter &) (const struct _Setter *) std::_Any_data::_M_access<std::__future_base::_State_baseV2::_Setter<void, std::__future_base::_State_baseV2::__exception_ptr_tag> > ((const union _Any_data *) __source))) >>>>>;
  return <retval> = (struct _Setter *) __ptr;
}


;; Function typename std::promise<_Res>::_Ptr_type std::__future_base::_State_baseV2::_Setter<_Res, std::__future_base::_State_baseV2::__exception_ptr_tag>::operator()() const [with _Res = void; typename std::promise<_Res>::_Ptr_type = std::unique_ptr<std::__future_base::_Result<void>, std::__future_base::_Result_base::_Deleter>] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::__future_base::_State_baseV2::_S_check<std::__future_base::_State_baseV2> ((const struct shared_ptr &) (const struct shared_ptr *) &((struct promise *) ((const struct _Setter *) this)->_M_promise)->_M_future) >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::__exception_ptr::exception_ptr::operator= (&std::unique_ptr<std::__future_base::_Result<void>, std::__future_base::_Result_base::_Deleter>::operator-> (&((struct promise *) ((const struct _Setter *) this)->_M_promise)->_M_storage)->D.68681._M_error, (const struct exception_ptr &) (const struct exception_ptr *) ((const struct _Setter *) this)->_M_ex) >>>>>;
<<cleanup_point return *<retval> = TARGET_EXPR <D.108129, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.108129
  (struct unique_ptr *) <<< Unknown tree: void_cst >>>
  (struct unique_ptr &) (struct type *) std::move<std::unique_ptr<std::__future_base::_Result<void>, std::__future_base::_Result_base::_Deleter>&> ((struct unique_ptr &) &((struct promise *) ((const struct _Setter *) this)->_M_promise)->_M_storage) >>>>>>;


;; Function _Tp& std::_Any_data::_M_access() [with _Tp = const std::type_info*] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (const struct type_info * &) (const struct type_info * *) std::_Any_data::_M_access (this)>>;


;; Function _Tp& std::_Any_data::_M_access() [with _Tp = std::__future_base::_State_baseV2::_Setter<void, std::__future_base::_State_baseV2::__exception_ptr_tag>*] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (struct _Setter * &) (struct _Setter * *) std::_Any_data::_M_access (this)>>;


;; Function static void std::_Function_base::_Base_manager<_Functor>::_M_clone(std::_Any_data&, const std::_Any_data&, std::true_type) [with _Functor = std::__future_base::_State_baseV2::_Setter<void, std::__future_base::_State_baseV2::__exception_ptr_tag>; std::true_type = std::integral_constant<bool, true>] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (TARGET_EXPR <D.108135, (const struct _Setter *) (const struct _Setter &) (const struct _Setter *) std::_Any_data::_M_access<std::__future_base::_State_baseV2::_Setter<void, std::__future_base::_State_baseV2::__exception_ptr_tag> > ((const union _Any_data *) __source)>;, TARGET_EXPR <D.108133, std::_Any_data::_M_access ((union _Any_data *) __dest)>;, TARGET_EXPR <D.108134, operator new (16, NON_LVALUE_EXPR <D.108133>)>;;, (struct _Setter *) D.108134 != 0B ? try
    {
      *(struct _Setter *) D.108134 = *D.108135;
    }
  catch
    {
      operator delete (D.108134, NON_LVALUE_EXPR <D.108133>);
    }, (struct _Setter *) D.108134; : (struct _Setter *) D.108134;) >>>>>;


;; Function static void std::_Function_base::_Base_manager<_Functor>::_M_destroy(std::_Any_data&, std::true_type) [with _Functor = std::__future_base::_State_baseV2::_Setter<void, std::__future_base::_State_baseV2::__exception_ptr_tag>; std::true_type = std::integral_constant<bool, true>] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::_Any_data::_M_access<std::__future_base::_State_baseV2::_Setter<void, std::__future_base::_State_baseV2::__exception_ptr_tag> > ((union _Any_data *) __victim) >>>>>;


;; Function constexpr typename std::remove_reference< <template-parameter-1-1> >::type&& std::move(_Tp&&) [with _Tp = std::_Any_data&; typename std::remove_reference< <template-parameter-1-1> >::type = std::_Any_data] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (union type &) (union type *) NON_LVALUE_EXPR <(union type &) __t>
   >>>;


;; Function void std::swap(_Tp&, _Tp&) [with _Tp = std::_Any_data] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    union _Any_data __tmp;

        union _Any_data __tmp;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__tmp = *(union _Any_data &) (union type *) std::move<std::_Any_data&> ((union _Any_data &) (union _Any_data *) __a)) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*(union _Any_data *) __a = *(union _Any_data &) (union type *) std::move<std::_Any_data&> ((union _Any_data &) (union _Any_data *) __b)) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*(union _Any_data *) __b = *(union _Any_data &) (union type *) std::move<std::_Any_data&> ((union _Any_data &) &__tmp)) >>>>>;
  }
   >>>;


;; Function constexpr typename std::remove_reference< <template-parameter-1-1> >::type&& std::move(_Tp&&) [with _Tp = bool (*&)(std::_Any_data&, const std::_Any_data&, std::_Manager_operation); typename std::remove_reference< <template-parameter-1-1> >::type = bool (*)(std::_Any_data&, const std::_Any_data&, std::_Manager_operation)] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (bool (*type) (union _Any_data &, const union _Any_data &, _Manager_operation) &) (bool (*type) (union _Any_data &, const union _Any_data &, _Manager_operation) *) (bool (*type) (union _Any_data &, const union _Any_data &, _Manager_operation) &) __t
   >>>;


;; Function void std::swap(_Tp&, _Tp&) [with _Tp = bool (*)(std::_Any_data&, const std::_Any_data&, std::_Manager_operation)] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    bool (*<T8bad>) (union _Any_data &, const union _Any_data &, _Manager_operation) __tmp;

        bool (*<T8bad>) (union _Any_data &, const union _Any_data &, _Manager_operation) __tmp;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__tmp = *std::move<bool (*&)(std::_Any_data&, const std::_Any_data&, std::_Manager_operation)> ((bool (*<T8bad>) (union _Any_data &, const union _Any_data &, _Manager_operation) &) (bool (*<T8bad>) (union _Any_data &, const union _Any_data &, _Manager_operation) *) __a)) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__a = *std::move<bool (*&)(std::_Any_data&, const std::_Any_data&, std::_Manager_operation)> ((bool (*<T8bad>) (union _Any_data &, const union _Any_data &, _Manager_operation) &) (bool (*<T8bad>) (union _Any_data &, const union _Any_data &, _Manager_operation) *) __b)) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__b = *std::move<bool (*&)(std::_Any_data&, const std::_Any_data&, std::_Manager_operation)> ((bool (*<T8bad>) (union _Any_data &, const union _Any_data &, _Manager_operation) &) &__tmp)) >>>>>;
  }
   >>>;


;; Function constexpr typename std::remove_reference< <template-parameter-1-1> >::type&& std::move(_Tp&&) [with _Tp = std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> (*&)(const std::_Any_data&); typename std::remove_reference< <template-parameter-1-1> >::type = std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> (*)(const std::_Any_data&)] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct unique_ptr (*type) (const union _Any_data &) &) (struct unique_ptr (*type) (const union _Any_data &) *) (struct unique_ptr (*type) (const union _Any_data &) &) __t
   >>>;


;; Function void std::swap(_Tp&, _Tp&) [with _Tp = std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> (*)(const std::_Any_data&)] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    struct unique_ptr (*<Tccf1>) (const union _Any_data &) __tmp;

        struct unique_ptr (*<Tccf1>) (const union _Any_data &) __tmp;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__tmp = *std::move<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> (*&)(const std::_Any_data&)> ((struct unique_ptr (*<Tccf1>) (const union _Any_data &) &) (struct unique_ptr (*<Tccf1>) (const union _Any_data &) *) __a)) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__a = *std::move<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> (*&)(const std::_Any_data&)> ((struct unique_ptr (*<Tccf1>) (const union _Any_data &) &) (struct unique_ptr (*<Tccf1>) (const union _Any_data &) *) __b)) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__b = *std::move<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> (*&)(const std::_Any_data&)> ((struct unique_ptr (*<Tccf1>) (const union _Any_data &) &) &__tmp)) >>>>>;
  }
   >>>;


;; Function std::__weak_count<_Lp>::__weak_count(const std::__shared_count<_Lp>&) [with __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __weak_count *) this)->_M_pi = (struct _Sp_counted_base *) __r->_M_pi) >>>>>;
    if (((struct __weak_count *) this)->_M_pi != 0B)
      {
        <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2u>::_M_weak_add_ref (NON_LVALUE_EXPR <((struct __weak_count *) this)->_M_pi>) >>>>>;
      }
  }
   >>>;


;; Function static void std::_Function_base::_Base_manager<_Functor>::_M_init_functor(std::_Any_data&, _Functor&&, std::true_type) [with _Functor = std::__future_base::_State_baseV2::_Setter<void, void>; std::true_type = std::integral_constant<bool, true>] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (TARGET_EXPR <D.108171, (struct _Setter *) (struct _Setter &) (struct type *) std::move<std::__future_base::_State_baseV2::_Setter<void, void>&> ((struct _Setter &) (struct _Setter *) __f)>;, TARGET_EXPR <D.108169, std::_Any_data::_M_access ((union _Any_data *) __functor)>;, TARGET_EXPR <D.108170, operator new (8, NON_LVALUE_EXPR <D.108169>)>;;, (struct _Setter *) D.108170 != 0B ? try
    {
      *(struct _Setter *) D.108170 = *NON_LVALUE_EXPR <(struct _Setter &) NON_LVALUE_EXPR <D.108171>>;
    }
  catch
    {
      operator delete (D.108170, NON_LVALUE_EXPR <D.108169>);
    }, (struct _Setter *) D.108170; : (struct _Setter *) D.108170;) >>>>>;


;; Function static _Functor* std::_Function_base::_Base_manager<_Functor>::_M_get_pointer(const std::_Any_data&) [with _Functor = std::__future_base::_State_baseV2::_Setter<void, void>] (null)
;; enabled by -tree-original


{
  const struct _Setter * __ptr;

    const struct _Setter * __ptr;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__ptr = std::__addressof<const std::__future_base::_State_baseV2::_Setter<void, void> > ((const struct _Setter &) (const struct _Setter *) std::_Any_data::_M_access<std::__future_base::_State_baseV2::_Setter<void, void> > ((const union _Any_data *) __source))) >>>>>;
  return <retval> = (struct _Setter *) __ptr;
}


;; Function _Tp& std::_Any_data::_M_access() [with _Tp = std::__future_base::_State_baseV2::_Setter<void, void>*] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (struct _Setter * &) (struct _Setter * *) std::_Any_data::_M_access (this)>>;


;; Function static void std::_Function_base::_Base_manager<_Functor>::_M_clone(std::_Any_data&, const std::_Any_data&, std::true_type) [with _Functor = std::__future_base::_State_baseV2::_Setter<void, void>; std::true_type = std::integral_constant<bool, true>] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (TARGET_EXPR <D.108184, (const struct _Setter *) (const struct _Setter &) (const struct _Setter *) std::_Any_data::_M_access<std::__future_base::_State_baseV2::_Setter<void, void> > ((const union _Any_data *) __source)>;, TARGET_EXPR <D.108182, std::_Any_data::_M_access ((union _Any_data *) __dest)>;, TARGET_EXPR <D.108183, operator new (8, NON_LVALUE_EXPR <D.108182>)>;;, (struct _Setter *) D.108183 != 0B ? try
    {
      *(struct _Setter *) D.108183 = *D.108184;
    }
  catch
    {
      operator delete (D.108183, NON_LVALUE_EXPR <D.108182>);
    }, (struct _Setter *) D.108183; : (struct _Setter *) D.108183;) >>>>>;


;; Function static void std::_Function_base::_Base_manager<_Functor>::_M_destroy(std::_Any_data&, std::true_type) [with _Functor = std::__future_base::_State_baseV2::_Setter<void, void>; std::true_type = std::integral_constant<bool, true>] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::_Any_data::_M_access<std::__future_base::_State_baseV2::_Setter<void, void> > ((union _Any_data *) __victim) >>>>>;


;; Function _Tp* std::__addressof(_Tp&) [with _Tp = std::thread] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct thread *) __r
   >>>;


;; Function std::_Mem_fn<void (std::thread::*)()>::_Mem_fn(std::_Mem_fn_base<void (std::thread::*)(), true>::_Pmf) (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Mem_fn_base<void (std::thread::*)(), true>::_Mem_fn_base (&((struct _Mem_fn *) this)->D.92875, *(struct _Pmf &) &D.92867) >>>>>;
}


;; Function static std::_Maybe_wrap_member_pointer<_Tp _Class::*>::type std::_Maybe_wrap_member_pointer<_Tp _Class::*>::__do_wrap(_Tp _Class::*) [with _Tp = void(); _Class = std::thread; std::_Maybe_wrap_member_pointer<_Tp _Class::*>::type = std::_Mem_fn<void (std::thread::*)()>] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = TARGET_EXPR <D.108191, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.108191
  (struct _Mem_fn *) <<< Unknown tree: void_cst >>>
  __pm >>>>;, D.108191>>;


;; Function constexpr std::_Tuple_impl<_Idx, _Head>::_Tuple_impl(_UHead&&) [with _UHead = std::reference_wrapper<std::thread>; long unsigned int _Idx = 1ul; _Head = std::reference_wrapper<std::thread>] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Head_base<1ul, std::reference_wrapper<std::thread>, false>::_Head_base<std::reference_wrapper<std::thread> > (&((struct _Tuple_impl *) this)->D.93793, (struct reference_wrapper &) (struct reference_wrapper *) std::forward<std::reference_wrapper<std::thread> > ((struct type &) (struct reference_wrapper *) __head)) >>>>>;
}


;; Function constexpr std::_Tuple_impl<_Idx, _Head, _Tail ...>::_Tuple_impl(_UHead&&, _UTail&& ...) [with _UHead = std::_Mem_fn<void (std::thread::*)()>; _UTail = {std::reference_wrapper<std::thread>}; <template-parameter-2-3> = void; long unsigned int _Idx = 0ul; _Head = std::_Mem_fn<void (std::thread::*)()>; _Tail = {std::reference_wrapper<std::thread>}] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Tuple_impl<1ul, std::reference_wrapper<std::thread> >::_Tuple_impl<std::reference_wrapper<std::thread> > (&((struct _Tuple_impl *) this)->D.94562, (struct reference_wrapper &) (struct reference_wrapper *) std::forward<std::reference_wrapper<std::thread> > ((struct type &) (struct reference_wrapper *) __tail#0)) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Head_base<0ul, std::_Mem_fn<void (std::thread::*)()>, false>::_Head_base<std::_Mem_fn<void (std::thread::*)()> > (&((struct _Tuple_impl *) this)->D.94563, (struct _Mem_fn &) (struct _Mem_fn *) std::forward<std::_Mem_fn<void (std::thread::*)()> > ((struct type &) (struct _Mem_fn *) __head)) >>>>>;
}


;; Function constexpr std::tuple<_T1, _T2>::tuple(_U1&&, _U2&&) [with _U1 = std::_Mem_fn<void (std::thread::*)()>; _U2 = std::reference_wrapper<std::thread>; <template-parameter-2-3> = void; _T1 = std::_Mem_fn<void (std::thread::*)()>; _T2 = std::reference_wrapper<std::thread>] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Tuple_impl<0ul, std::_Mem_fn<void (std::thread::*)()>, std::reference_wrapper<std::thread> >::_Tuple_impl<std::_Mem_fn<void (std::thread::*)()>, std::reference_wrapper<std::thread>, void> (&((struct tuple *) this)->D.95234, (struct _Mem_fn &) (struct _Mem_fn *) std::forward<std::_Mem_fn<void (std::thread::*)()> > ((struct type &) (struct _Mem_fn *) __a1), (struct reference_wrapper &) (struct reference_wrapper *) std::forward<std::reference_wrapper<std::thread> > ((struct type &) (struct reference_wrapper *) __a2)) >>>>>;
}


;; Function std::_Bind_simple<_Callable(_Args ...)>::_Bind_simple(_Tp&&, _Up&& ...) [with _Tp = std::_Mem_fn<void (std::thread::*)()>; _Up = {std::reference_wrapper<std::thread>}; _Callable = std::_Mem_fn<void (std::thread::*)()>; _Args = {std::reference_wrapper<std::thread>}] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::tuple<std::_Mem_fn<void (std::thread::*)()>, std::reference_wrapper<std::thread> >::tuple<std::_Mem_fn<void (std::thread::*)()>, std::reference_wrapper<std::thread>, void> (&((struct _Bind_simple *) this)->_M_bound, (struct _Mem_fn &) (struct _Mem_fn *) std::forward<std::_Mem_fn<void (std::thread::*)()> > ((struct type &) (struct _Mem_fn *) __f), (struct reference_wrapper &) (struct reference_wrapper *) std::forward<std::reference_wrapper<std::thread> > ((struct type &) (struct reference_wrapper *) __args#0)) >>>>>;
}


;; Function std::_Bind_simple<_Callable(_Args ...)>::result_type std::_Bind_simple<_Callable(_Args ...)>::operator()() [with _Callable = std::_Mem_fn<void (std::thread::*)()>; _Args = {std::reference_wrapper<std::thread>}; std::_Bind_simple<_Callable(_Args ...)>::result_type = void] (null)
;; enabled by -tree-original


{
  typedef struct _Indices _Indices;

  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Bind_simple<std::_Mem_fn<void (std::thread::*)()>(std::reference_wrapper<std::thread>)>::_M_invoke<0ul> (this, TARGET_EXPR <D.108263, {}>;, <<< Unknown tree: empty_class_expr >>>;) >>>>>;
  return;
}


;; Function static std::_Iter_base<_Iterator, _HasBase>::iterator_type std::_Iter_base<_Iterator, _HasBase>::_S_base(_Iterator) [with _Iterator = long unsigned int*; bool _HasBase = false; std::_Iter_base<_Iterator, _HasBase>::iterator_type = long unsigned int*] (null)
;; enabled by -tree-original


return <retval> = (long unsigned int *) __it;


;; Function std::ios_base::iostate std::basic_ios<_CharT, _Traits>::rdstate() const [with _CharT = char; _Traits = std::char_traits<char>; std::ios_base::iostate = std::_Ios_Iostate] (null)
;; enabled by -tree-original


return <retval> = (iostate) ((const struct basic_ios *) this)->D.31198._M_streambuf_state;


;; Function const _Facet& std::__check_facet(const _Facet*) [with _Facet = std::ctype<char>] (null)
;; enabled by -tree-original


if (__f == 0B)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_bad_cast () >>>>>;
  }
return <retval> = (const struct ctype &) NON_LVALUE_EXPR <__f>;


;; Function std::_Vector_base<_Tp, _Alloc>::_Vector_impl::_Vector_impl() [with _Tp = std::packaged_task<long int(int, int)>; _Alloc = std::allocator<std::packaged_task<long int(int, int)> >] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator<std::packaged_task<long int(int, int)> >::allocator ((struct allocator *) this) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Vector_impl *) this)->_M_start = 0B) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Vector_impl *) this)->_M_finish = 0B) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Vector_impl *) this)->_M_end_of_storage = 0B) >>>>>;
    }
  catch
    {
      std::allocator<std::packaged_task<long int(int, int)> >::~allocator ((struct allocator *) this);
    }
}


;; Function std::allocator< <template-parameter-1-1> >::~allocator() [with _Tp = std::packaged_task<long int(int, int)>] (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  {
    try
      {
        
      }
    finally
      {
        __gnu_cxx::new_allocator<std::packaged_task<long int(int, int)> >::~new_allocator ((struct new_allocator *) this);
      }
  }
  <D.108283>:;
   >>>;


;; Function void std::_Vector_base<_Tp, _Alloc>::_M_deallocate(std::_Vector_base<_Tp, _Alloc>::pointer, std::size_t) [with _Tp = std::packaged_task<long int(int, int)>; _Alloc = std::allocator<std::packaged_task<long int(int, int)> >; std::_Vector_base<_Tp, _Alloc>::pointer = std::packaged_task<long int(int, int)>*; std::size_t = long unsigned int] (null)
;; enabled by -tree-original


{
  typedef struct _Tr _Tr;

  if (__p != 0B)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator_traits<std::allocator<std::packaged_task<long int(int, int)> > >::deallocate ((struct allocator_type &) (struct allocator *) &((struct _Vector_base *) this)->_M_impl, __p, __n) >>>>>;
    }
}


;; Function void std::_Destroy(_ForwardIterator, _ForwardIterator) [with _ForwardIterator = std::packaged_task<long int(int, int)>*] (null)
;; enabled by -tree-original


{
  typedef struct _Value_type _Value_type;

  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Destroy_aux<false>::__destroy<std::packaged_task<long int(int, int)>*> (__first, __last) >>>>>;
}


;; Function std::_Vector_base<_Tp, _Alloc>::_Vector_impl::_Vector_impl() [with _Tp = std::future<long int>; _Alloc = std::allocator<std::future<long int> >] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator<std::future<long int> >::allocator ((struct allocator *) this) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Vector_impl *) this)->_M_start = 0B) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Vector_impl *) this)->_M_finish = 0B) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Vector_impl *) this)->_M_end_of_storage = 0B) >>>>>;
    }
  catch
    {
      std::allocator<std::future<long int> >::~allocator ((struct allocator *) this);
    }
}


;; Function std::allocator< <template-parameter-1-1> >::~allocator() [with _Tp = std::future<long int>] (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  {
    try
      {
        
      }
    finally
      {
        __gnu_cxx::new_allocator<std::future<long int> >::~new_allocator ((struct new_allocator *) this);
      }
  }
  <D.108322>:;
   >>>;


;; Function void std::_Vector_base<_Tp, _Alloc>::_M_deallocate(std::_Vector_base<_Tp, _Alloc>::pointer, std::size_t) [with _Tp = std::future<long int>; _Alloc = std::allocator<std::future<long int> >; std::_Vector_base<_Tp, _Alloc>::pointer = std::future<long int>*; std::size_t = long unsigned int] (null)
;; enabled by -tree-original


{
  typedef struct _Tr _Tr;

  if (__p != 0B)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator_traits<std::allocator<std::future<long int> > >::deallocate ((struct allocator_type &) (struct allocator *) &((struct _Vector_base *) this)->_M_impl, __p, __n) >>>>>;
    }
}


;; Function void std::_Destroy(_ForwardIterator, _ForwardIterator) [with _ForwardIterator = std::future<long int>*] (null)
;; enabled by -tree-original


{
  typedef struct _Value_type _Value_type;

  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Destroy_aux<false>::__destroy<std::future<long int>*> (__first, __last) >>>>>;
}


;; Function std::_Vector_base<_Tp, _Alloc>::_Vector_impl::_Vector_impl() [with _Tp = std::thread*; _Alloc = std::allocator<std::thread*>] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator<std::thread*>::allocator ((struct allocator *) this) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Vector_impl *) this)->_M_start = 0B) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Vector_impl *) this)->_M_finish = 0B) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Vector_impl *) this)->_M_end_of_storage = 0B) >>>>>;
    }
  catch
    {
      std::allocator<std::thread*>::~allocator ((struct allocator *) this);
    }
}


;; Function std::allocator< <template-parameter-1-1> >::~allocator() [with _Tp = std::thread*] (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  {
    try
      {
        
      }
    finally
      {
        __gnu_cxx::new_allocator<std::thread*>::~new_allocator ((struct new_allocator *) this);
      }
  }
  <D.108347>:;
   >>>;


;; Function void std::_Vector_base<_Tp, _Alloc>::_M_deallocate(std::_Vector_base<_Tp, _Alloc>::pointer, std::size_t) [with _Tp = std::thread*; _Alloc = std::allocator<std::thread*>; std::_Vector_base<_Tp, _Alloc>::pointer = std::thread**; std::size_t = long unsigned int] (null)
;; enabled by -tree-original


{
  typedef struct _Tr _Tr;

  if (__p != 0B)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator_traits<std::allocator<std::thread*> >::deallocate ((struct allocator_type &) (struct allocator *) &((struct _Vector_base *) this)->_M_impl, __p, __n) >>>>>;
    }
}


;; Function void std::_Destroy(_ForwardIterator, _ForwardIterator) [with _ForwardIterator = std::thread**] (null)
;; enabled by -tree-original


{
  typedef struct thread * _Value_type;

  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Destroy_aux<true>::__destroy<std::thread**> (__first, __last) >>>>>;
}


;; Function __gnu_cxx::new_allocator<_Tp>::new_allocator() [with _Tp = int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    
  }
   >>>;


;; Function __gnu_cxx::new_allocator<_Tp>::~new_allocator() [with _Tp = int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    
  }
  <D.108372>:;
   >>>;


;; Function std::__shared_ptr<_Tp, _Lp>::~__shared_ptr() [with _Tp = std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


{
  try
    {
      try
        {
          
        }
      finally
        {
          std::__shared_count<>::~__shared_count (&((struct __shared_ptr *) this)->_M_refcount);
        }
    }
  finally
    {
      *(struct 
      {
        struct _Task_state * _M_ptr;
        struct __shared_count _M_refcount;
      } &) this = {CLOBBER};
    }
}
<D.109718>:;


;; Function std::shared_ptr<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)> >::~shared_ptr() (null)
;; enabled by -tree-original


{
  try
    {
      try
        {
          
        }
      finally
        {
          std::__shared_ptr<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, (__gnu_cxx::_Lock_policy)2u>::~__shared_ptr (&((struct shared_ptr *) this)->D.109703);
        }
    }
  finally
    {
      *(struct 
      {
        struct 
        {
          struct _Task_state * _M_ptr;
          struct __shared_count _M_refcount;
        } D.109704;
      } &) this = {CLOBBER};
    }
}
<D.109716>:;


;; Function std::shared_ptr<std::__future_base::_Task_state_base<_Signature> > std::__create_task_state(_Fn&&, const _Alloc&) [with _Signature = long int(int, int); _Fn = long int (&)(int, int); _Alloc = std::allocator<int>] (null)
;; enabled by -tree-original


{
  typedef long int (*_Fn2) (int, int) _Fn2;
  typedef struct _State _State;

  <<cleanup_point return *<retval> = TARGET_EXPR <D.109915, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.109915
  (struct shared_ptr *) <<< Unknown tree: void_cst >>>
  (struct shared_ptr &) &TARGET_EXPR <D.109705, <<< Unknown tree: aggr_init_expr
  6
  allocate_shared
  D.109705
  (const struct allocator &) (const struct allocator *) __a
  (long int (&<T105d3>) (int, int)) (long int (*<T105d2>) (int, int)) std::forward<long int (&)(int, int)> ((long int (&<T15f36>) (int, int)) (long int (*<T105d2>) (int, int)) __fn)
  (const struct allocator &) (const struct allocator *) __a >>>> >>>>>>;
}


;; Function constexpr typename std::remove_reference< <template-parameter-1-1> >::type&& std::move(_Tp&&) [with _Tp = std::shared_ptr<std::__future_base::_Task_state_base<long int(int, int)> >&; typename std::remove_reference< <template-parameter-1-1> >::type = std::shared_ptr<std::__future_base::_Task_state_base<long int(int, int)> >] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct type &) (struct type *) NON_LVALUE_EXPR <(struct type &) __t>
   >>>;


;; Function std::shared_ptr<_Tp>::shared_ptr(std::shared_ptr<_Tp>&&) [with _Tp = std::__future_base::_Task_state_base<long int(int, int)>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__shared_ptr<std::__future_base::_Task_state_base<long int(int, int)>, (__gnu_cxx::_Lock_policy)2u>::__shared_ptr (&((struct shared_ptr *) this)->D.82011, (struct __shared_ptr &) (struct __shared_ptr *) NON_LVALUE_EXPR <(struct __shared_ptr &) &((struct type *) std::move<std::shared_ptr<std::__future_base::_Task_state_base<long int(int, int)> >&> ((struct shared_ptr &) (struct shared_ptr *) __r))->D.82011>) >>>>>;
    try
      {
        
      }
    catch
      {
        std::__shared_ptr<std::__future_base::_Task_state_base<long int(int, int)>, (__gnu_cxx::_Lock_policy)2u>::~__shared_ptr (&((struct shared_ptr *) this)->D.82011);
      }
  }
   >>>;


;; Function static constexpr _Head& std::_Head_base<_Idx, _Head, false>::_M_head(std::_Head_base<_Idx, _Head, false>&) [with long unsigned int _Idx = 0ul; _Head = std::__future_base::_Result<long int>*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct _Result * &) &__b->_M_head_impl
   >>>;


;; Function static constexpr _Head& std::_Tuple_impl<_Idx, _Head, _Tail ...>::_M_head(std::_Tuple_impl<_Idx, _Head, _Tail ...>&) [with long unsigned int _Idx = 0ul; _Head = std::__future_base::_Result<long int>*; _Tail = {std::__future_base::_Result_base::_Deleter}] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct _Result * &) (struct _Result * *) std::_Head_base<0ul, std::__future_base::_Result<long int>*, false>::_M_head ((struct _Head_base &) &((struct _Tuple_impl *) __t)->D.97692)>>
   >>>;


;; Function constexpr _Head& std::__get_helper(std::_Tuple_impl<_Idx, _Head, _Tail ...>&) [with long unsigned int __i = 0ul; _Head = std::__future_base::_Result<long int>*; _Tail = {std::__future_base::_Result_base::_Deleter}] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct _Result * &) (struct _Result * *) std::_Tuple_impl<0ul, std::__future_base::_Result<long int>*, std::__future_base::_Result_base::_Deleter>::_M_head ((struct _Tuple_impl &) (struct _Tuple_impl *) __t)>>
   >>>;


;; Function constexpr std::__tuple_element_t<__i, std::tuple<_Elements ...> >& std::get(std::tuple<_Elements ...>&) [with long unsigned int __i = 0ul; _Elements = {std::__future_base::_Result<long int>*, std::__future_base::_Result_base::_Deleter}; std::__tuple_element_t<__i, std::tuple<_Elements ...> > = std::__future_base::_Result<long int>*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct _Result * &) (struct _Result * *) std::__get_helper<0ul, std::__future_base::_Result<long int>*, std::__future_base::_Result_base::_Deleter> ((struct _Tuple_impl &) &((struct tuple *) __t)->D.98360)>>
   >>>;


;; Function std::unique_ptr<_Tp, _Dp>::pointer std::unique_ptr<_Tp, _Dp>::release() [with _Tp = std::__future_base::_Result<long int>; _Dp = std::__future_base::_Result_base::_Deleter; std::unique_ptr<_Tp, _Dp>::pointer = std::__future_base::_Result<long int>*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    struct _Result * __p;

        struct _Result * __p;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__p = std::unique_ptr<std::__future_base::_Result<long int>, std::__future_base::_Result_base::_Deleter>::get (this)) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*std::get<0ul, std::__future_base::_Result<long int>*, std::__future_base::_Result_base::_Deleter> ((struct tuple &) &((struct unique_ptr *) this)->_M_t) = 0B) >>>>>;
    return <retval> = __p;
  }
   >>>;


;; Function constexpr std::__tuple_element_t<__i, std::tuple<_Elements ...> >& std::get(std::tuple<_Elements ...>&) [with long unsigned int __i = 1ul; _Elements = {std::__future_base::_Result<long int>*, std::__future_base::_Result_base::_Deleter}; std::__tuple_element_t<__i, std::tuple<_Elements ...> > = std::__future_base::_Result_base::_Deleter] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct __tuple_element_t &) (struct _Deleter *) std::__get_helper<1ul, std::__future_base::_Result_base::_Deleter> ((struct _Tuple_impl &) (struct _Tuple_impl *) (struct tuple *) __t)>>
   >>>;


;; Function std::unique_ptr<_Tp, _Dp>::deleter_type& std::unique_ptr<_Tp, _Dp>::get_deleter() [with _Tp = std::__future_base::_Result<long int>; _Dp = std::__future_base::_Result_base::_Deleter; std::unique_ptr<_Tp, _Dp>::deleter_type = std::__future_base::_Result_base::_Deleter] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct deleter_type &) (struct __tuple_element_t *) std::get<1ul, std::__future_base::_Result<long int>*, std::__future_base::_Result_base::_Deleter> ((struct tuple &) &((struct unique_ptr *) this)->_M_t)>>
   >>>;


;; Function void __gnu_cxx::new_allocator<_Tp>::construct(_Up*, _Args&& ...) [with _Up = std::packaged_task<long int(int, int)>; _Args = {std::packaged_task<long int(int, int)>}; _Tp = std::packaged_task<long int(int, int)>] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (TARGET_EXPR <D.109970, (struct packaged_task &) (struct packaged_task *) std::forward<std::packaged_task<long int(int, int)> > ((struct type &) (struct packaged_task *) __args#0)>;, TARGET_EXPR <D.109968, (void *) __p>;, TARGET_EXPR <D.109969, operator new (16, NON_LVALUE_EXPR <D.109968>)>;;, (struct packaged_task *) D.109969 != 0B ? try
    {
      std::packaged_task<long int(int, int)>::packaged_task ((struct packaged_task *) D.109969, NON_LVALUE_EXPR <D.109970>);
    }
  catch
    {
      operator delete (D.109969, NON_LVALUE_EXPR <D.109968>);
    }, (struct packaged_task *) D.109969; : (struct packaged_task *) D.109969;) >>>>>;


;; Function constexpr const _Tp& std::max(const _Tp&, const _Tp&) [with _Tp = long unsigned int] (null)
;; enabled by -tree-original


if ((long unsigned int) *__a < (long unsigned int) *__b)
  {
    return <retval> = (const long unsigned int &) (const long unsigned int *) __b;
  }
return <retval> = (const long unsigned int &) (const long unsigned int *) __a;


;; Function std::vector<_Tp, _Alloc>::size_type std::vector<_Tp, _Alloc>::_M_check_len(std::vector<_Tp, _Alloc>::size_type, const char*) const [with _Tp = std::packaged_task<long int(int, int)>; _Alloc = std::allocator<std::packaged_task<long int(int, int)> >; std::vector<_Tp, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


{
  const size_type __len;

  if (<<cleanup_point std::vector<std::packaged_task<long int(int, int)> >::max_size (this) - std::vector<std::packaged_task<long int(int, int)> >::size (this) < __n>>)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_length_error (*(const char * &) &__s) >>>>>;
    }
    const size_type __len;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__len = std::vector<std::packaged_task<long int(int, int)> >::size (this) + (long unsigned int) *std::max<long unsigned int> ((const long unsigned int &) &TARGET_EXPR <D.109976, std::vector<std::packaged_task<long int(int, int)> >::size (this)>, (const long unsigned int &) (const long unsigned int *) &__n)) >>>>>;
  <<cleanup_point return <retval> = std::vector<std::packaged_task<long int(int, int)> >::size (this) > (long unsigned int) __len || std::vector<std::packaged_task<long int(int, int)> >::max_size (this) < (long unsigned int) __len ? std::vector<std::packaged_task<long int(int, int)> >::max_size (this) : (size_type) __len>>;
}


;; Function std::_Vector_base<_Tp, _Alloc>::pointer std::_Vector_base<_Tp, _Alloc>::_M_allocate(std::size_t) [with _Tp = std::packaged_task<long int(int, int)>; _Alloc = std::allocator<std::packaged_task<long int(int, int)> >; std::_Vector_base<_Tp, _Alloc>::pointer = std::packaged_task<long int(int, int)>*; std::size_t = long unsigned int] (null)
;; enabled by -tree-original


{
  typedef struct _Tr _Tr;

  <<cleanup_point return <retval> = __n != 0 ? (struct packaged_task *) std::allocator_traits<std::allocator<std::packaged_task<long int(int, int)> > >::allocate ((struct allocator_type &) (struct allocator *) &((struct _Vector_base *) this)->_M_impl, __n) : 0B>>;
}


;; Function std::vector<_Tp, _Alloc>::size_type std::vector<_Tp, _Alloc>::size() const [with _Tp = std::packaged_task<long int(int, int)>; _Alloc = std::allocator<std::packaged_task<long int(int, int)> >; std::vector<_Tp, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (size_type) (((long int) ((const struct vector *) this)->D.78390._M_impl._M_finish - (long int) ((const struct vector *) this)->D.78390._M_impl._M_start) /[ex] 16)
   >>>;


;; Function _ForwardIterator std::__uninitialized_move_if_noexcept_a(_InputIterator, _InputIterator, _ForwardIterator, _Allocator&) [with _InputIterator = std::packaged_task<long int(int, int)>*; _ForwardIterator = std::packaged_task<long int(int, int)>*; _Allocator = std::allocator<std::packaged_task<long int(int, int)> >] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = std::__uninitialized_copy_a<std::move_iterator<std::packaged_task<long int(int, int)>*>, std::packaged_task<long int(int, int)>*, std::packaged_task<long int(int, int)> > (TARGET_EXPR <D.110084, std::__make_move_if_noexcept_iterator<std::packaged_task<long int(int, int)>*, std::move_iterator<std::packaged_task<long int(int, int)>*> > (__first)>, TARGET_EXPR <D.110094, std::__make_move_if_noexcept_iterator<std::packaged_task<long int(int, int)>*, std::move_iterator<std::packaged_task<long int(int, int)>*> > (__last)>, __result, (struct allocator &) (struct allocator *) __alloc)>>;


;; Function static void std::allocator_traits<std::allocator<_CharT> >::destroy(std::allocator_traits<std::allocator<_CharT> >::allocator_type&, _Up*) [with _Up = std::packaged_task<long int(int, int)>; _Tp = std::packaged_task<long int(int, int)>; std::allocator_traits<std::allocator<_CharT> >::allocator_type = std::allocator<std::packaged_task<long int(int, int)> >] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<std::packaged_task<long int(int, int)> >::destroy<std::packaged_task<long int(int, int)> > ((struct new_allocator *) (struct allocator_type *) __a, __p) >>>>>;


;; Function std::__shared_ptr<_Tp, _Lp>::__shared_ptr(const std::__shared_ptr<_Tp1, _Lp>&) [with _Tp1 = std::__future_base::_Task_state_base<long int(int, int)>; <template-parameter-2-2> = void; _Tp = std::__future_base::_State_baseV2; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __shared_ptr *) this)->_M_ptr = (struct _State_baseV2 *) (struct _Task_state_base *) __r->_M_ptr) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__shared_count<>::__shared_count (&((struct __shared_ptr *) this)->_M_refcount, (const struct __shared_count &) &__r->_M_refcount) >>>>>;
    try
      {
        
      }
    catch
      {
        std::__shared_count<>::~__shared_count (&((struct __shared_ptr *) this)->_M_refcount);
      }
  }
   >>>;


;; Function std::__basic_future<_Res>::__basic_future(const __state_type&) [with _Res = long int; std::__basic_future<_Res>::__state_type = std::shared_ptr<std::__future_base::_State_baseV2>] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__future_base::__future_base ((struct __future_base *) this) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::shared_ptr<std::__future_base::_State_baseV2>::shared_ptr (&((struct __basic_future *) this)->_M_state, (const struct shared_ptr &) (const struct __state_type *) __state) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__future_base::_State_baseV2::_S_check<std::__future_base::_State_baseV2> ((const struct shared_ptr &) (const struct shared_ptr *) &((struct __basic_future *) this)->_M_state) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__future_base::_State_baseV2::_M_set_retrieved_flag (std::__shared_ptr<std::__future_base::_State_baseV2, (__gnu_cxx::_Lock_policy)2u>::operator-> (&((struct __basic_future *) this)->_M_state.D.69901)) >>>>>;
    }
  catch
    {
      std::shared_ptr<std::__future_base::_State_baseV2>::~shared_ptr (&((struct __basic_future *) this)->_M_state);
    }
}


;; Function void __gnu_cxx::new_allocator<_Tp>::construct(_Up*, _Args&& ...) [with _Up = std::future<long int>; _Args = {std::future<long int>}; _Tp = std::future<long int>] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (TARGET_EXPR <D.110145, (struct future &) (struct future *) std::forward<std::future<long int> > ((struct type &) (struct future *) __args#0)>;, TARGET_EXPR <D.110143, (void *) __p>;, TARGET_EXPR <D.110144, operator new (16, NON_LVALUE_EXPR <D.110143>)>;;, (struct future *) D.110144 != 0B ? try
    {
      std::future<long int>::future ((struct future *) D.110144, NON_LVALUE_EXPR <D.110145>);
    }
  catch
    {
      operator delete (D.110144, NON_LVALUE_EXPR <D.110143>);
    }, (struct future *) D.110144; : (struct future *) D.110144;) >>>>>;


;; Function std::vector<_Tp, _Alloc>::size_type std::vector<_Tp, _Alloc>::_M_check_len(std::vector<_Tp, _Alloc>::size_type, const char*) const [with _Tp = std::future<long int>; _Alloc = std::allocator<std::future<long int> >; std::vector<_Tp, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


{
  const size_type __len;

  if (<<cleanup_point std::vector<std::future<long int> >::max_size (this) - std::vector<std::future<long int> >::size (this) < __n>>)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_length_error (*(const char * &) &__s) >>>>>;
    }
    const size_type __len;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__len = std::vector<std::future<long int> >::size (this) + (long unsigned int) *std::max<long unsigned int> ((const long unsigned int &) &TARGET_EXPR <D.110148, std::vector<std::future<long int> >::size (this)>, (const long unsigned int &) (const long unsigned int *) &__n)) >>>>>;
  <<cleanup_point return <retval> = std::vector<std::future<long int> >::size (this) > (long unsigned int) __len || std::vector<std::future<long int> >::max_size (this) < (long unsigned int) __len ? std::vector<std::future<long int> >::max_size (this) : (size_type) __len>>;
}


;; Function std::_Vector_base<_Tp, _Alloc>::pointer std::_Vector_base<_Tp, _Alloc>::_M_allocate(std::size_t) [with _Tp = std::future<long int>; _Alloc = std::allocator<std::future<long int> >; std::_Vector_base<_Tp, _Alloc>::pointer = std::future<long int>*; std::size_t = long unsigned int] (null)
;; enabled by -tree-original


{
  typedef struct _Tr _Tr;

  <<cleanup_point return <retval> = __n != 0 ? (struct future *) std::allocator_traits<std::allocator<std::future<long int> > >::allocate ((struct allocator_type &) (struct allocator *) &((struct _Vector_base *) this)->_M_impl, __n) : 0B>>;
}


;; Function std::vector<_Tp, _Alloc>::size_type std::vector<_Tp, _Alloc>::size() const [with _Tp = std::future<long int>; _Alloc = std::allocator<std::future<long int> >; std::vector<_Tp, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (size_type) (((long int) ((const struct vector *) this)->D.79511._M_impl._M_finish - (long int) ((const struct vector *) this)->D.79511._M_impl._M_start) /[ex] 16)
   >>>;


;; Function _ForwardIterator std::__uninitialized_move_if_noexcept_a(_InputIterator, _InputIterator, _ForwardIterator, _Allocator&) [with _InputIterator = std::future<long int>*; _ForwardIterator = std::future<long int>*; _Allocator = std::allocator<std::future<long int> >] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = std::__uninitialized_copy_a<std::move_iterator<std::future<long int>*>, std::future<long int>*, std::future<long int> > (TARGET_EXPR <D.110544, std::__make_move_if_noexcept_iterator<std::future<long int>*, std::move_iterator<std::future<long int>*> > (__first)>, TARGET_EXPR <D.110554, std::__make_move_if_noexcept_iterator<std::future<long int>*, std::move_iterator<std::future<long int>*> > (__last)>, __result, (struct allocator &) (struct allocator *) __alloc)>>;


;; Function static void std::allocator_traits<std::allocator<_CharT> >::destroy(std::allocator_traits<std::allocator<_CharT> >::allocator_type&, _Up*) [with _Up = std::future<long int>; _Tp = std::future<long int>; std::allocator_traits<std::allocator<_CharT> >::allocator_type = std::allocator<std::future<long int> >] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<std::future<long int> >::destroy<std::future<long int> > ((struct new_allocator *) (struct allocator_type *) __a, __p) >>>>>;


;; Function static _Tp&& std::_Maybe_wrap_member_pointer<_Tp>::__do_wrap(_Tp&&) [with _Tp = std::packaged_task<long int(int, int)>] (null)
;; enabled by -tree-original


return <retval> = (struct packaged_task &) (struct packaged_task *) NON_LVALUE_EXPR <__x>;


;; Function constexpr std::_Tuple_impl<_Idx, _Head>::_Tuple_impl(_UHead&&) [with _UHead = int; long unsigned int _Idx = 2ul; _Head = int] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Head_base<2ul, int, false>::_Head_base<int> (&((struct _Tuple_impl *) this)->D.100101, (int &) (int *) std::forward<int> ((type &) (int *) __head)) >>>>>;
}


;; Function constexpr std::_Head_base<_Idx, _Head, false>::_Head_base(_UHead&&) [with _UHead = int&; long unsigned int _Idx = 1ul; _Head = int] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Head_base *) this)->_M_head_impl = *std::forward<int&> ((type &) (int *) __h)) >>>>>;
}


;; Function constexpr std::_Tuple_impl<_Idx, _Head, _Tail ...>::_Tuple_impl(_UHead&&, _UTail&& ...) [with _UHead = int&; _UTail = {int}; <template-parameter-2-3> = void; long unsigned int _Idx = 1ul; _Head = int; _Tail = {int}] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Tuple_impl<2ul, int>::_Tuple_impl<int> (&((struct _Tuple_impl *) this)->D.100819, (int &) (int *) std::forward<int> ((type &) (int *) __tail#0)) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Head_base<1ul, int, false>::_Head_base<int&> (&((struct _Tuple_impl *) this)->D.100820, (int &) (int *) std::forward<int&> ((type &) (int *) __head)) >>>>>;
}


;; Function constexpr std::_Tuple_impl<_Idx, _Head, _Tail ...>::_Tuple_impl(_UHead&&, _UTail&& ...) [with _UHead = std::packaged_task<long int(int, int)>; _UTail = {int&, int}; <template-parameter-2-3> = void; long unsigned int _Idx = 0ul; _Head = std::packaged_task<long int(int, int)>; _Tail = {int, int}] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Tuple_impl<1ul, int, int>::_Tuple_impl<int&, int, void> (&((struct _Tuple_impl *) this)->D.101575, (int &) (int *) std::forward<int&> ((type &) (int *) __tail#0), (int &) (int *) std::forward<int> ((type &) (int *) __tail#1)) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Head_base<0ul, std::packaged_task<long int(int, int)>, false>::_Head_base<std::packaged_task<long int(int, int)> > (&((struct _Tuple_impl *) this)->D.101576, (struct packaged_task &) (struct packaged_task *) std::forward<std::packaged_task<long int(int, int)> > ((struct type &) (struct packaged_task *) __head)) >>>>>;
  try
    {
      
    }
  catch
    {
      std::_Head_base<0ul, std::packaged_task<long int(int, int)>, false>::~_Head_base (&((struct _Tuple_impl *) this)->D.101576);
    }
}


;; Function constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::packaged_task<long int(int, int)>, int&, int}; <template-parameter-2-2> = void; _Elements = {std::packaged_task<long int(int, int)>, int, int}] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Tuple_impl<0ul, std::packaged_task<long int(int, int)>, int, int>::_Tuple_impl<std::packaged_task<long int(int, int)>, int&, int, void> (&((struct tuple *) this)->D.102039, (struct packaged_task &) (struct packaged_task *) std::forward<std::packaged_task<long int(int, int)> > ((struct type &) (struct packaged_task *) __elements#0), (int &) (int *) std::forward<int&> ((type &) (int *) __elements#1), (int &) (int *) std::forward<int> ((type &) (int *) __elements#2)) >>>>>;
  try
    {
      
    }
  catch
    {
      std::_Tuple_impl<0ul, std::packaged_task<long int(int, int)>, int, int>::~_Tuple_impl (&((struct tuple *) this)->D.102039);
    }
}


;; Function std::_Bind_simple<_Callable(_Args ...)>::_Bind_simple(_Tp&&, _Up&& ...) [with _Tp = std::packaged_task<long int(int, int)>; _Up = {int&, int}; _Callable = std::packaged_task<long int(int, int)>; _Args = {int, int}] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::tuple<std::packaged_task<long int(int, int)>, int, int>::tuple<std::packaged_task<long int(int, int)>, int&, int, void> (&((struct _Bind_simple *) this)->_M_bound, (struct packaged_task &) (struct packaged_task *) std::forward<std::packaged_task<long int(int, int)> > ((struct type &) (struct packaged_task *) __f), (int &) (int *) std::forward<int&> ((type &) (int *) __args#0), (int &) (int *) std::forward<int> ((type &) (int *) __args#1)) >>>>>;
  try
    {
      
    }
  catch
    {
      std::tuple<std::packaged_task<long int(int, int)>, int, int>::~tuple (&((struct _Bind_simple *) this)->_M_bound);
    }
}


;; Function constexpr std::__shared_ptr<_Tp, _Lp>::__shared_ptr() [with _Tp = std::__future_base::_Task_state_base<long int(int, int)>; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __shared_ptr *) this)->_M_ptr = 0B) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __shared_ptr *) this)->_M_refcount = <<< Unknown tree: aggr_init_expr
  4
  __comp_ctor 
  D.110797
  (struct __shared_count *) <<< Unknown tree: void_cst >>> >>>) >>>>>;
    try
      {
        
      }
    catch
      {
        std::__shared_count<>::~__shared_count (&((struct __shared_ptr *) this)->_M_refcount);
      }
  }
   >>>;


;; Function constexpr std::shared_ptr<_Tp>::shared_ptr() [with _Tp = std::__future_base::_Task_state_base<long int(int, int)>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__shared_ptr<std::__future_base::_Task_state_base<long int(int, int)>, (__gnu_cxx::_Lock_policy)2u>::__shared_ptr (&((struct shared_ptr *) this)->D.82011) >>>>>;
    try
      {
        
      }
    catch
      {
        std::__shared_ptr<std::__future_base::_Task_state_base<long int(int, int)>, (__gnu_cxx::_Lock_policy)2u>::~__shared_ptr (&((struct shared_ptr *) this)->D.82011);
      }
  }
   >>>;


;; Function std::packaged_task<_Res(_ArgTypes ...)>::packaged_task(std::packaged_task<_Res(_ArgTypes ...)>&&) [with _Res = long int; _ArgTypes = {int, int}] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::shared_ptr<std::__future_base::_Task_state_base<long int(int, int)> >::shared_ptr (&((struct packaged_task *) this)->_M_state) >>>>>;
    try
      {
        <<cleanup_point <<< Unknown tree: expr_stmt
  std::packaged_task<long int(int, int)>::swap (this, (struct packaged_task &) (struct packaged_task *) __other) >>>>>;
      }
    catch
      {
        std::shared_ptr<std::__future_base::_Task_state_base<long int(int, int)> >::~shared_ptr (&((struct packaged_task *) this)->_M_state);
      }
  }
   >>>;


;; Function std::shared_ptr<_Tp1> std::make_shared(_Args&& ...) [with _Tp = std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >; _Args = {std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)>}] (null)
;; enabled by -tree-original


{
  typedef struct _Tp_nc _Tp_nc;

  <<cleanup_point return *<retval> = TARGET_EXPR <D.110981, <<< Unknown tree: aggr_init_expr
  5
  allocate_shared
  D.110981
  (const struct allocator &) (const struct allocator *) &TARGET_EXPR <D.110977, <<< Unknown tree: aggr_init_expr
  4
  __comp_ctor 
  D.110977
  (struct allocator *) <<< Unknown tree: void_cst >>> >>>>
  (struct _Bind_simple &) (struct _Bind_simple *) std::forward<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > ((struct type &) (struct _Bind_simple *) __args#0) >>>>>>;
}


;; Function std::shared_ptr<_Tp>::shared_ptr(std::shared_ptr<_Tp>&&) [with _Tp = std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__shared_ptr<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >, (__gnu_cxx::_Lock_policy)2u>::__shared_ptr (&((struct shared_ptr *) this)->D.103679, (struct __shared_ptr &) (struct __shared_ptr *) NON_LVALUE_EXPR <(struct __shared_ptr &) &((struct type *) std::move<std::shared_ptr<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >&> ((struct shared_ptr &) (struct shared_ptr *) __r))->D.103679>) >>>>>;
    try
      {
        
      }
    catch
      {
        std::__shared_ptr<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >, (__gnu_cxx::_Lock_policy)2u>::~__shared_ptr (&((struct shared_ptr *) this)->D.103679);
      }
  }
   >>>;


;; Function std::__shared_ptr<_Tp, _Lp>::__shared_ptr(std::__shared_ptr<_Tp1, _Lp>&&) [with _Tp1 = std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >; <template-parameter-2-2> = void; _Tp = std::thread::_Impl_base; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __shared_ptr *) this)->_M_ptr = (struct _Impl_base *) __r->_M_ptr) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __shared_ptr *) this)->_M_refcount = <<< Unknown tree: aggr_init_expr
  4
  __comp_ctor 
  D.110995
  (struct __shared_count *) <<< Unknown tree: void_cst >>> >>>) >>>>>;
    try
      {
        <<cleanup_point <<< Unknown tree: expr_stmt
  std::__shared_count<>::_M_swap (&((struct __shared_ptr *) this)->_M_refcount, (struct __shared_count &) &__r->_M_refcount) >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__r->_M_ptr = 0B) >>>>>;
      }
    catch
      {
        std::__shared_count<>::~__shared_count (&((struct __shared_ptr *) this)->_M_refcount);
      }
  }
   >>>;


;; Function std::__shared_ptr<_Tp, _Lp>::__shared_ptr(std::__shared_ptr<_Tp, _Lp>&&) [with _Tp = std::thread::_Impl_base; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __shared_ptr *) this)->_M_ptr = __r->_M_ptr) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __shared_ptr *) this)->_M_refcount = <<< Unknown tree: aggr_init_expr
  4
  __comp_ctor 
  D.111000
  (struct __shared_count *) <<< Unknown tree: void_cst >>> >>>) >>>>>;
    try
      {
        <<cleanup_point <<< Unknown tree: expr_stmt
  std::__shared_count<>::_M_swap (&((struct __shared_ptr *) this)->_M_refcount, (struct __shared_count &) &__r->_M_refcount) >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__r->_M_ptr = 0B) >>>>>;
      }
    catch
      {
        std::__shared_count<>::~__shared_count (&((struct __shared_ptr *) this)->_M_refcount);
      }
  }
   >>>;


;; Function static void std::allocator_traits<std::allocator<_CharT> >::construct(std::allocator_traits<std::allocator<_CharT> >::allocator_type&, _Up*, _Args&& ...) [with _Up = std::thread*; _Args = {std::thread*}; _Tp = std::thread*; std::allocator_traits<std::allocator<_CharT> >::allocator_type = std::allocator<std::thread*>] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<std::thread*>::construct<std::thread*, std::thread*> ((struct new_allocator *) (struct allocator_type *) __a, __p, (struct thread * &) (struct thread * *) std::forward<std::thread*> ((struct thread * &) (struct thread * *) __args#0)) >>>>>;


;; Function void std::vector<_Tp, _Alloc>::_M_emplace_back_aux(_Args&& ...) [with _Args = {std::thread*}; _Tp = std::thread*; _Alloc = std::allocator<std::thread*>] (null)
;; enabled by -tree-original


{
  const size_type __len;
  struct thread * * __new_start;
  struct thread * * __new_finish = __new_start;

    const size_type __len;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__len = std::vector<std::thread*>::_M_check_len (this, 1, (const char *) "vector::_M_emplace_back_aux")) >>>>>;
    struct thread * * __new_start;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__new_start = std::_Vector_base<std::thread*, std::allocator<std::thread*> >::_M_allocate (&((struct vector *) this)->D.80632, (size_type) __len)) >>>>>;
    struct thread * * __new_finish = __new_start;
  <<< Unknown tree: try_block
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator_traits<std::allocator<std::thread*> >::construct<std::thread*, std::thread*> ((struct allocator_type &) (struct allocator *) &((struct vector *) this)->D.80632._M_impl, __new_start + (sizetype) (std::vector<std::thread*>::size (this) * 8), (struct thread * &) (struct thread * *) std::forward<std::thread*> ((struct thread * &) (struct thread * *) __args#0)) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__new_finish = 0B) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__new_finish = std::__uninitialized_move_if_noexcept_a<std::thread**, std::thread**, std::allocator<std::thread*> > (((struct vector *) this)->D.80632._M_impl._M_start, ((struct vector *) this)->D.80632._M_impl._M_finish, __new_start, (struct allocator &) (struct _Tp_alloc_type *) std::_Vector_base<std::thread*, std::allocator<std::thread*> >::_M_get_Tp_allocator (&((struct vector *) this)->D.80632))) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void)  ++__new_finish >>>>>;
  <<< Unknown tree: handler
  
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) __cxa_begin_catch (__builtin_eh_pointer (0)) >>>>>;
      if (__new_finish == 0B)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator_traits<std::allocator<std::thread*> >::destroy<std::thread*> ((struct allocator_type &) (struct allocator *) &((struct vector *) this)->D.80632._M_impl, __new_start + (sizetype) (std::vector<std::thread*>::size (this) * 8)) >>>>>;
        }
      else
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Destroy<std::thread**, std::thread*> (__new_start, __new_finish, (struct allocator &) (struct _Tp_alloc_type *) std::_Vector_base<std::thread*, std::allocator<std::thread*> >::_M_get_Tp_allocator (&((struct vector *) this)->D.80632)) >>>>>;
        }
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Vector_base<std::thread*, std::allocator<std::thread*> >::_M_deallocate (&((struct vector *) this)->D.80632, __new_start, (size_type) __len) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  <<< Unknown tree: throw_expr
  __cxa_rethrow () >>> >>>>>;
    }
  finally
    {
      __cxa_end_catch ();
    } >>> >>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Destroy<std::thread**, std::thread*> (((struct vector *) this)->D.80632._M_impl._M_start, ((struct vector *) this)->D.80632._M_impl._M_finish, (struct allocator &) (struct _Tp_alloc_type *) std::_Vector_base<std::thread*, std::allocator<std::thread*> >::_M_get_Tp_allocator (&((struct vector *) this)->D.80632)) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Vector_base<std::thread*, std::allocator<std::thread*> >::_M_deallocate (&((struct vector *) this)->D.80632, ((struct vector *) this)->D.80632._M_impl._M_start, (size_t) (((long int) ((struct vector *) this)->D.80632._M_impl._M_end_of_storage - (long int) ((struct vector *) this)->D.80632._M_impl._M_start) /[ex] 8)) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct vector *) this)->D.80632._M_impl._M_start = __new_start) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct vector *) this)->D.80632._M_impl._M_finish = __new_finish) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct vector *) this)->D.80632._M_impl._M_end_of_storage = __new_start + (sizetype) ((long unsigned int) __len * 8)) >>>>>;
}


;; Function _Tp* __gnu_cxx::__aligned_buffer<_Tp>::_M_ptr() [with _Tp = long int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (long int *) __gnu_cxx::__aligned_buffer<long int>::_M_addr (this)>>
   >>>;


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_construct_aux(_InIterator, _InIterator, std::__false_type) [with _InIterator = char*; _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>] (null)
;; enabled by -tree-original


{
  typedef struct _Tag _Tag;

  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_M_construct<char*> (this, __beg, __end, TARGET_EXPR <D.111035, *(struct forward_iterator_tag &) (struct forward_iterator_tag *) NON_LVALUE_EXPR <(struct forward_iterator_tag &) &TARGET_EXPR <D.111024, {}>>>;, <<< Unknown tree: empty_class_expr >>>;) >>>>>;
}


;; Function static void std::allocator_traits<std::allocator<_CharT> >::deallocate(std::allocator_traits<std::allocator<_CharT> >::allocator_type&, std::allocator_traits<std::allocator<_CharT> >::pointer, std::allocator_traits<std::allocator<_CharT> >::size_type) [with _Tp = char; std::allocator_traits<std::allocator<_CharT> >::allocator_type = std::allocator<char>; std::allocator_traits<std::allocator<_CharT> >::pointer = char*; std::allocator_traits<std::allocator<_CharT> >::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<char>::deallocate ((struct new_allocator *) (struct allocator_type *) __a, __p, __n) >>>>>;


;; Function _Tp* std::addressof(_Tp&) [with _Tp = char] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::__addressof<char> ((char &) (char *) __r)>>
   >>>;


;; Function __gnu_cxx::new_allocator<_Tp>::new_allocator(const __gnu_cxx::new_allocator<_Tp>&) [with _Tp = char] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    
  }
   >>>;


;; Function static _Tp* std::pointer_traits<_Tp*>::pointer_to(typename std::__ptrtr_not_void<_Tp>::__type&) [with _Tp = const char; std::pointer_traits<_Tp*>::pointer = const char*; typename std::__ptrtr_not_void<_Tp>::__type = const char] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (const char *) std::addressof<const char> ((const char &) (const __type *) __r)>>
   >>>;


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_construct_aux(_InIterator, _InIterator, std::__false_type) [with _InIterator = wchar_t*; _CharT = wchar_t; _Traits = std::char_traits<wchar_t>; _Alloc = std::allocator<wchar_t>] (null)
;; enabled by -tree-original


{
  typedef struct _Tag _Tag;

  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<wchar_t>::_M_construct<wchar_t*> (this, __beg, __end, TARGET_EXPR <D.111059, *(struct forward_iterator_tag &) (struct forward_iterator_tag *) NON_LVALUE_EXPR <(struct forward_iterator_tag &) &TARGET_EXPR <D.111048, {}>>>;, <<< Unknown tree: empty_class_expr >>>;) >>>>>;
}


;; Function static void std::allocator_traits<std::allocator<_CharT> >::deallocate(std::allocator_traits<std::allocator<_CharT> >::allocator_type&, std::allocator_traits<std::allocator<_CharT> >::pointer, std::allocator_traits<std::allocator<_CharT> >::size_type) [with _Tp = wchar_t; std::allocator_traits<std::allocator<_CharT> >::allocator_type = std::allocator<wchar_t>; std::allocator_traits<std::allocator<_CharT> >::pointer = wchar_t*; std::allocator_traits<std::allocator<_CharT> >::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<wchar_t>::deallocate ((struct new_allocator *) (struct allocator_type *) __a, __p, __n) >>>>>;


;; Function _Tp* std::addressof(_Tp&) [with _Tp = wchar_t] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::__addressof<wchar_t> ((wchar_t &) (wchar_t *) __r)>>
   >>>;


;; Function __gnu_cxx::new_allocator<_Tp>::new_allocator(const __gnu_cxx::new_allocator<_Tp>&) [with _Tp = wchar_t] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    
  }
   >>>;


;; Function static _Tp* std::pointer_traits<_Tp*>::pointer_to(typename std::__ptrtr_not_void<_Tp>::__type&) [with _Tp = const wchar_t; std::pointer_traits<_Tp*>::pointer = const wchar_t*; typename std::__ptrtr_not_void<_Tp>::__type = const wchar_t] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (const wchar_t *) std::addressof<const wchar_t> ((const wchar_t &) (const __type *) __r)>>
   >>>;


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_construct(_InIterator, _InIterator, std::forward_iterator_tag) [with _FwdIterator = const char*; _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>] (null)
;; enabled by -tree-original


{
  size_type __dnew;

  if (<<cleanup_point __gnu_cxx::__is_null_pointer<const char> (__beg) && __beg != __end>>)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_logic_error ((const char *) "basic_string::_M_construct null not valid") >>>>>;
    }
    size_type __dnew;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__dnew = (size_type) std::distance<const char*> (__beg, __end)) >>>>>;
  if (__dnew > 15)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_M_data (this, std::__cxx11::basic_string<char>::_M_create (this, (size_type &) &__dnew, 0)) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_M_capacity (this, __dnew) >>>>>;
    }
  <<< Unknown tree: try_block
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_S_copy_chars (std::__cxx11::basic_string<char>::_M_data (this), __beg, __end) >>>>>
  <<< Unknown tree: handler
  
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) __cxa_begin_catch (__builtin_eh_pointer (0)) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_M_dispose (this) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  <<< Unknown tree: throw_expr
  __cxa_rethrow () >>> >>>>>;
    }
  finally
    {
      __cxa_end_catch ();
    } >>> >>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_M_set_length (this, __dnew) >>>>>;
}


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_construct(_InIterator, _InIterator, std::forward_iterator_tag) [with _FwdIterator = const wchar_t*; _CharT = wchar_t; _Traits = std::char_traits<wchar_t>; _Alloc = std::allocator<wchar_t>] (null)
;; enabled by -tree-original


{
  size_type __dnew;

  if (<<cleanup_point __gnu_cxx::__is_null_pointer<const wchar_t> (__beg) && __beg != __end>>)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_logic_error ((const char *) "basic_string::_M_construct null not valid") >>>>>;
    }
    size_type __dnew;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__dnew = (size_type) std::distance<const wchar_t*> (__beg, __end)) >>>>>;
  if (__dnew > 3)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<wchar_t>::_M_data (this, std::__cxx11::basic_string<wchar_t>::_M_create (this, (size_type &) &__dnew, 0)) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<wchar_t>::_M_capacity (this, __dnew) >>>>>;
    }
  <<< Unknown tree: try_block
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<wchar_t>::_S_copy_chars (std::__cxx11::basic_string<wchar_t>::_M_data (this), __beg, __end) >>>>>
  <<< Unknown tree: handler
  
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) __cxa_begin_catch (__builtin_eh_pointer (0)) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<wchar_t>::_M_dispose (this) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  <<< Unknown tree: throw_expr
  __cxa_rethrow () >>> >>>>>;
    }
  finally
    {
      __cxa_end_catch ();
    } >>> >>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<wchar_t>::_M_set_length (this, __dnew) >>>>>;
}


;; Function _Tp* std::addressof(_Tp&) [with _Tp = char16_t] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::__addressof<char16_t> ((char16_t &) (char16_t *) __r)>>
   >>>;


;; Function __gnu_cxx::new_allocator<_Tp>::new_allocator(const __gnu_cxx::new_allocator<_Tp>&) [with _Tp = char16_t] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    
  }
   >>>;


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_construct(_InIterator, _InIterator, std::forward_iterator_tag) [with _FwdIterator = const char16_t*; _CharT = char16_t; _Traits = std::char_traits<char16_t>; _Alloc = std::allocator<char16_t>] (null)
;; enabled by -tree-original


{
  size_type __dnew;

  if (<<cleanup_point __gnu_cxx::__is_null_pointer<const char16_t> (__beg) && __beg != __end>>)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_logic_error ((const char *) "basic_string::_M_construct null not valid") >>>>>;
    }
    size_type __dnew;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__dnew = (size_type) std::distance<const char16_t*> (__beg, __end)) >>>>>;
  if (__dnew > 7)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char16_t>::_M_data (this, std::__cxx11::basic_string<char16_t>::_M_create (this, (size_type &) &__dnew, 0)) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char16_t>::_M_capacity (this, __dnew) >>>>>;
    }
  <<< Unknown tree: try_block
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char16_t>::_S_copy_chars (std::__cxx11::basic_string<char16_t>::_M_data (this), __beg, __end) >>>>>
  <<< Unknown tree: handler
  
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) __cxa_begin_catch (__builtin_eh_pointer (0)) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char16_t>::_M_dispose (this) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  <<< Unknown tree: throw_expr
  __cxa_rethrow () >>> >>>>>;
    }
  finally
    {
      __cxa_end_catch ();
    } >>> >>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char16_t>::_M_set_length (this, __dnew) >>>>>;
}


;; Function static void std::allocator_traits<std::allocator<_CharT> >::deallocate(std::allocator_traits<std::allocator<_CharT> >::allocator_type&, std::allocator_traits<std::allocator<_CharT> >::pointer, std::allocator_traits<std::allocator<_CharT> >::size_type) [with _Tp = char16_t; std::allocator_traits<std::allocator<_CharT> >::allocator_type = std::allocator<char16_t>; std::allocator_traits<std::allocator<_CharT> >::pointer = char16_t*; std::allocator_traits<std::allocator<_CharT> >::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<char16_t>::deallocate ((struct new_allocator *) (struct allocator_type *) __a, __p, __n) >>>>>;


;; Function static _Tp* std::pointer_traits<_Tp*>::pointer_to(typename std::__ptrtr_not_void<_Tp>::__type&) [with _Tp = const char16_t; std::pointer_traits<_Tp*>::pointer = const char16_t*; typename std::__ptrtr_not_void<_Tp>::__type = const char16_t] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (const char16_t *) std::addressof<const char16_t> ((const char16_t &) (const __type *) __r)>>
   >>>;


;; Function _Tp* std::addressof(_Tp&) [with _Tp = char32_t] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::__addressof<char32_t> ((char32_t &) (char32_t *) __r)>>
   >>>;


;; Function __gnu_cxx::new_allocator<_Tp>::new_allocator(const __gnu_cxx::new_allocator<_Tp>&) [with _Tp = char32_t] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    
  }
   >>>;


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_construct(_InIterator, _InIterator, std::forward_iterator_tag) [with _FwdIterator = const char32_t*; _CharT = char32_t; _Traits = std::char_traits<char32_t>; _Alloc = std::allocator<char32_t>] (null)
;; enabled by -tree-original


{
  size_type __dnew;

  if (<<cleanup_point __gnu_cxx::__is_null_pointer<const char32_t> (__beg) && __beg != __end>>)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_logic_error ((const char *) "basic_string::_M_construct null not valid") >>>>>;
    }
    size_type __dnew;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__dnew = (size_type) std::distance<const char32_t*> (__beg, __end)) >>>>>;
  if (__dnew > 3)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char32_t>::_M_data (this, std::__cxx11::basic_string<char32_t>::_M_create (this, (size_type &) &__dnew, 0)) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char32_t>::_M_capacity (this, __dnew) >>>>>;
    }
  <<< Unknown tree: try_block
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char32_t>::_S_copy_chars (std::__cxx11::basic_string<char32_t>::_M_data (this), __beg, __end) >>>>>
  <<< Unknown tree: handler
  
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) __cxa_begin_catch (__builtin_eh_pointer (0)) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char32_t>::_M_dispose (this) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  <<< Unknown tree: throw_expr
  __cxa_rethrow () >>> >>>>>;
    }
  finally
    {
      __cxa_end_catch ();
    } >>> >>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char32_t>::_M_set_length (this, __dnew) >>>>>;
}


;; Function static void std::allocator_traits<std::allocator<_CharT> >::deallocate(std::allocator_traits<std::allocator<_CharT> >::allocator_type&, std::allocator_traits<std::allocator<_CharT> >::pointer, std::allocator_traits<std::allocator<_CharT> >::size_type) [with _Tp = char32_t; std::allocator_traits<std::allocator<_CharT> >::allocator_type = std::allocator<char32_t>; std::allocator_traits<std::allocator<_CharT> >::pointer = char32_t*; std::allocator_traits<std::allocator<_CharT> >::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<char32_t>::deallocate ((struct new_allocator *) (struct allocator_type *) __a, __p, __n) >>>>>;


;; Function static _Tp* std::pointer_traits<_Tp*>::pointer_to(typename std::__ptrtr_not_void<_Tp>::__type&) [with _Tp = const char32_t; std::pointer_traits<_Tp*>::pointer = const char32_t*; typename std::__ptrtr_not_void<_Tp>::__type = const char32_t] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (const char32_t *) std::addressof<const char32_t> ((const char32_t &) (const __type *) __r)>>
   >>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::max_size() const [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (std::allocator_traits<std::allocator<char> >::max_size ((const struct allocator_type &) (const struct allocator_type *) std::__cxx11::basic_string<char>::_M_get_allocator (this)) + 18446744073709551615) / 2>>
   >>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_check(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, const char*) const [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


if (<<cleanup_point std::__cxx11::basic_string<char>::size (this) < __pos>>)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_out_of_range_fmt ((const char *) "%s: __pos (which is %zu) > this->size() (which is %zu)", __s, __pos, std::__cxx11::basic_string<char>::size (this)) >>>>>;
  }
return <retval> = __pos;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_limit(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type) const [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    const bool __testoff;

        const bool __testoff;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__testoff = std::__cxx11::basic_string<char>::size (this) - __pos > __off) >>>>>;
    <<cleanup_point return <retval> = (bool) __testoff ? __off : std::__cxx11::basic_string<char>::size (this) - __pos>>;
  }
   >>>;


;; Function std::_Sp_counted_base<_Lp>::~_Sp_counted_base() [with __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Sp_counted_base *) this)->_vptr._Sp_counted_base = &_ZTVSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE2EE + 16) >>>>>;
    try
      {
        
      }
    finally
      {
        *(struct 
        {
          int (*__vtbl_ptr_type) () * _vptr._Sp_counted_base;
          _Atomic_word _M_use_count;
          _Atomic_word _M_weak_count;
        } &) this = {CLOBBER};
      }
  }
  <D.111769>:;
  if ((__in_chrg & 1) != 0)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  operator delete ((void *) this, 16) >>>>>;
    }
   >>>;


;; Function std::__shared_ptr<_Tp, _Lp>::__shared_ptr(std::_Sp_make_shared_tag, const _Alloc&, _Args&& ...) [with _Alloc = std::allocator<std::mutex>; _Args = {}; _Tp = std::mutex; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __shared_ptr *) this)->_M_ptr = 0B) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__shared_count<>::__shared_count<std::mutex, std::allocator<std::mutex> > (&((struct __shared_ptr *) this)->_M_refcount, TARGET_EXPR <D.111817, __tag>;, <<< Unknown tree: empty_class_expr >>>;, 0B, (const struct allocator &) (const struct allocator *) __a) >>>>>;
  try
    {
      {
        void * __p;

                void * __p;
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__p = std::__shared_count<>::_M_get_deleter (&((struct __shared_ptr *) this)->_M_refcount, (const struct type_info &) (const struct type_info *) &_ZTISt19_Sp_make_shared_tag)) >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __shared_ptr *) this)->_M_ptr = (struct mutex *) __p) >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  std::__enable_shared_from_this_helper<(__gnu_cxx::_Lock_policy)2u> ((const struct __shared_count &) (const struct __shared_count *) &((struct __shared_ptr *) this)->_M_refcount, ((struct __shared_ptr *) this)->_M_ptr, ((struct __shared_ptr *) this)->_M_ptr) >>>>>;
      }
    }
  catch
    {
      std::__shared_count<>::~__shared_count (&((struct __shared_ptr *) this)->_M_refcount);
    }
}


;; Function std::__atomic_base<_IntTp>::__int_type std::__atomic_base<_IntTp>::fetch_or(std::__atomic_base<_IntTp>::__int_type, std::memory_order) [with _ITp = unsigned int; std::__atomic_base<_IntTp>::__int_type = unsigned int; std::memory_order = std::memory_order] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = __atomic_fetch_or_4 ((volatile void *) &((struct __atomic_base *) this)->_M_i, __i, (int) __m)>>
   >>>;


;; Function constexpr std::_Maybe_unary_or_binary_function<void, std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*>::_Maybe_unary_or_binary_function() (null)
;; enabled by -tree-original


{
  
}


;; Function std::_Mem_fn_base<_MemFunPtr, __is_mem_fn>::_Mem_fn_base(std::_Mem_fn_base<_MemFunPtr, __is_mem_fn>::_Pmf) [with _MemFunPtr = void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*); bool __is_mem_fn = true; std::_Mem_fn_base<_MemFunPtr, __is_mem_fn>::_Pmf = void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Maybe_unary_or_binary_function<void, std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*>::_Maybe_unary_or_binary_function ((struct _Maybe_unary_or_binary_function *) this) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Mem_fn_base *) this)->_M_pmf = __pmf) >>>>>;
}


;; Function constexpr _Head& std::__get_helper(std::_Tuple_impl<_Idx, _Head, _Tail ...>&) [with long unsigned int __i = 0ul; _Head = std::_Mem_fn<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)>; _Tail = {std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*}] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct _Mem_fn &) (struct _Mem_fn *) std::_Tuple_impl<0ul, std::_Mem_fn<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)>, std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*>::_M_head ((struct _Tuple_impl &) (struct _Tuple_impl *) __t)>>
   >>>;


;; Function constexpr std::__tuple_element_t<__i, std::tuple<_Elements ...> >& std::get(std::tuple<_Elements ...>&) [with long unsigned int __i = 0ul; _Elements = {std::_Mem_fn<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)>, std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*}; std::__tuple_element_t<__i, std::tuple<_Elements ...> > = std::_Mem_fn<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct __tuple_element_t &) (struct _Mem_fn *) std::__get_helper<0ul, std::_Mem_fn<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)>, std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*> ((struct _Tuple_impl &) &((struct tuple *) __t)->D.87947)>>
   >>>;


;; Function constexpr _Head& std::__get_helper(std::_Tuple_impl<_Idx, _Head, _Tail ...>&) [with long unsigned int __i = 1ul; _Head = std::__future_base::_State_baseV2*; _Tail = {std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*}] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct _State_baseV2 * &) (struct _State_baseV2 * *) std::_Tuple_impl<1ul, std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*>::_M_head ((struct _Tuple_impl &) (struct _Tuple_impl *) __t)>>
   >>>;


;; Function constexpr std::__tuple_element_t<__i, std::tuple<_Elements ...> >& std::get(std::tuple<_Elements ...>&) [with long unsigned int __i = 1ul; _Elements = {std::_Mem_fn<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)>, std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*}; std::__tuple_element_t<__i, std::tuple<_Elements ...> > = std::__future_base::_State_baseV2*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct _State_baseV2 * &) (struct _State_baseV2 * *) std::__get_helper<1ul, std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*> ((struct _Tuple_impl &) &((struct tuple *) __t)->D.87947.D.87475)>>
   >>>;


;; Function constexpr _Head& std::__get_helper(std::_Tuple_impl<_Idx, _Head, _Tail ...>&) [with long unsigned int __i = 2ul; _Head = std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*; _Tail = {bool*}] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct function * &) (struct function * *) std::_Tuple_impl<2ul, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*>::_M_head ((struct _Tuple_impl &) (struct _Tuple_impl *) __t)>>
   >>>;


;; Function constexpr std::__tuple_element_t<__i, std::tuple<_Elements ...> >& std::get(std::tuple<_Elements ...>&) [with long unsigned int __i = 2ul; _Elements = {std::_Mem_fn<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)>, std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*}; std::__tuple_element_t<__i, std::tuple<_Elements ...> > = std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct function * &) (struct function * *) std::__get_helper<2ul, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*> ((struct _Tuple_impl &) &((struct tuple *) __t)->D.87947.D.87475.D.86699)>>
   >>>;


;; Function constexpr _Head& std::__get_helper(std::_Tuple_impl<_Idx, _Head, _Tail ...>&) [with long unsigned int __i = 3ul; _Head = bool*; _Tail = {}] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (bool * &) (bool * *) std::_Tuple_impl<3ul, bool*>::_M_head ((struct _Tuple_impl &) (struct _Tuple_impl *) __t)>>
   >>>;


;; Function constexpr std::__tuple_element_t<__i, std::tuple<_Elements ...> >& std::get(std::tuple<_Elements ...>&) [with long unsigned int __i = 3ul; _Elements = {std::_Mem_fn<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)>, std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*}; std::__tuple_element_t<__i, std::tuple<_Elements ...> > = bool*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (bool * &) (bool * *) std::__get_helper<3ul, bool*> ((struct _Tuple_impl &) &((struct tuple *) __t)->D.87947.D.87475.D.86699.D.85972)>>
   >>>;


;; Function typename std::result_of<_Functor(_ArgTypes ...)>::type std::_Bind_simple<_Callable(_Args ...)>::_M_invoke(std::_Index_tuple<_Indices ...>) [with long unsigned int ..._Indices = {0ul, 1ul, 2ul}; _Callable = std::_Mem_fn<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)>; _Args = {std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*}; typename std::result_of<_Functor(_ArgTypes ...)>::type = void] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::_Mem_fn_base<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*), true>::operator()<std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*, void> (&((struct _Mem_fn *) std::forward<std::_Mem_fn<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)> > ((struct type &) (struct __tuple_element_t *) std::get<0ul, std::_Mem_fn<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)>, std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*> ((struct tuple &) &((struct _Bind_simple *) this)->_M_bound)))->D.84132, *std::forward<std::__future_base::_State_baseV2*> ((struct _State_baseV2 * &) (struct _State_baseV2 * *) std::get<1ul, std::_Mem_fn<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)>, std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*> ((struct tuple &) &((struct _Bind_simple *) this)->_M_bound)), (struct function * &) (struct function * *) std::forward<std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*> ((struct function * &) (struct function * *) std::get<2ul, std::_Mem_fn<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)>, std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*> ((struct tuple &) &((struct _Bind_simple *) this)->_M_bound)), (bool * &) (bool * *) std::forward<bool*> ((bool * &) (bool * *) std::get<3ul, std::_Mem_fn<void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*)>, std::__future_base::_State_baseV2*, std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*> ((struct tuple &) &((struct _Bind_simple *) this)->_M_bound))) >>>>>;
return;


;; Function void std::_Tuple_impl<_Idx, _Head, _Tail ...>::_M_swap(std::_Tuple_impl<_Idx, _Head, _Tail ...>&) [with long unsigned int _Idx = 0ul; _Head = std::__future_base::_Result_base*; _Tail = {std::__future_base::_Result_base::_Deleter}] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    (void) 0;
    (void) 0;
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::swap<std::__future_base::_Result_base*> ((struct _Result_base * &) (struct _Result_base * *) std::_Tuple_impl<0ul, std::__future_base::_Result_base*, std::__future_base::_Result_base::_Deleter>::_M_head ((struct _Tuple_impl &) (struct _Tuple_impl *) this), (struct _Result_base * &) (struct _Result_base * *) std::_Tuple_impl<0ul, std::__future_base::_Result_base*, std::__future_base::_Result_base::_Deleter>::_M_head ((struct _Tuple_impl &) (struct _Tuple_impl *) __in)) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Tuple_impl<1ul, std::__future_base::_Result_base::_Deleter>::_M_swap ((struct _Tuple_impl *) this, (struct _Tuple_impl &) (struct _Inherited *) std::_Tuple_impl<0ul, std::__future_base::_Result_base*, std::__future_base::_Result_base::_Deleter>::_M_tail ((struct _Tuple_impl &) (struct _Tuple_impl *) __in)) >>>>>;
  }
   >>>;


;; Function std::__shared_ptr<_Tp, _Lp>::__shared_ptr(std::_Sp_make_shared_tag, const _Alloc&, _Args&& ...) [with _Alloc = std::allocator<std::__future_base::_State_baseV2>; _Args = {}; _Tp = std::__future_base::_State_baseV2; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __shared_ptr *) this)->_M_ptr = 0B) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__shared_count<>::__shared_count<std::__future_base::_State_baseV2, std::allocator<std::__future_base::_State_baseV2> > (&((struct __shared_ptr *) this)->_M_refcount, TARGET_EXPR <D.111968, __tag>;, <<< Unknown tree: empty_class_expr >>>;, 0B, (const struct allocator &) (const struct allocator *) __a) >>>>>;
  try
    {
      {
        void * __p;

                void * __p;
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__p = std::__shared_count<>::_M_get_deleter (&((struct __shared_ptr *) this)->_M_refcount, (const struct type_info &) (const struct type_info *) &_ZTISt19_Sp_make_shared_tag)) >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __shared_ptr *) this)->_M_ptr = (struct _State_baseV2 *) __p) >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  std::__enable_shared_from_this_helper<(__gnu_cxx::_Lock_policy)2u> ((const struct __shared_count &) (const struct __shared_count *) &((struct __shared_ptr *) this)->_M_refcount, ((struct __shared_ptr *) this)->_M_ptr, ((struct __shared_ptr *) this)->_M_ptr) >>>>>;
      }
    }
  catch
    {
      std::__shared_count<>::~__shared_count (&((struct __shared_ptr *) this)->_M_refcount);
    }
}


;; Function void std::_Tuple_impl<_Idx, _Head, _Tail ...>::_M_swap(std::_Tuple_impl<_Idx, _Head, _Tail ...>&) [with long unsigned int _Idx = 0ul; _Head = std::__future_base::_Result<void>*; _Tail = {std::__future_base::_Result_base::_Deleter}] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    (void) 0;
    (void) 0;
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::swap<std::__future_base::_Result<void>*> ((struct _Result * &) (struct _Result * *) std::_Tuple_impl<0ul, std::__future_base::_Result<void>*, std::__future_base::_Result_base::_Deleter>::_M_head ((struct _Tuple_impl &) (struct _Tuple_impl *) this), (struct _Result * &) (struct _Result * *) std::_Tuple_impl<0ul, std::__future_base::_Result<void>*, std::__future_base::_Result_base::_Deleter>::_M_head ((struct _Tuple_impl &) (struct _Tuple_impl *) __in)) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Tuple_impl<1ul, std::__future_base::_Result_base::_Deleter>::_M_swap ((struct _Tuple_impl *) this, (struct _Tuple_impl &) (struct _Inherited *) std::_Tuple_impl<0ul, std::__future_base::_Result<void>*, std::__future_base::_Result_base::_Deleter>::_M_tail ((struct _Tuple_impl &) (struct _Tuple_impl *) __in)) >>>>>;
  }
   >>>;


;; Function const _Tp& std::_Any_data::_M_access() const [with _Tp = std::__future_base::_State_baseV2::_Setter<void, std::__future_base::_State_baseV2::__exception_ptr_tag>] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (const struct _Setter &) (const struct _Setter *) std::_Any_data::_M_access (this)>>;


;; Function _Tp* std::__addressof(_Tp&) [with _Tp = const std::__future_base::_State_baseV2::_Setter<void, std::__future_base::_State_baseV2::__exception_ptr_tag>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (const struct _Setter *) __r
   >>>;


;; Function const _Tp& std::_Any_data::_M_access() const [with _Tp = std::__future_base::_State_baseV2::_Setter<void, std::__future_base::_State_baseV2::__exception_ptr_tag>*] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (struct _Setter * const &) (struct _Setter * const *) std::_Any_data::_M_access (this)>>;


;; Function std::unique_ptr<_Tp, _Dp>::pointer std::unique_ptr<_Tp, _Dp>::operator->() const [with _Tp = std::__future_base::_Result<void>; _Dp = std::__future_base::_Result_base::_Deleter; std::unique_ptr<_Tp, _Dp>::pointer = std::__future_base::_Result<void>*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::unique_ptr<std::__future_base::_Result<void>, std::__future_base::_Result_base::_Deleter>::get (this)>>
   >>>;


;; Function _Tp& std::_Any_data::_M_access() [with _Tp = std::__future_base::_State_baseV2::_Setter<void, std::__future_base::_State_baseV2::__exception_ptr_tag>] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (struct _Setter &) (struct _Setter *) std::_Any_data::_M_access (this)>>;


;; Function void std::_Sp_counted_base<_Lp>::_M_weak_add_ref() [with __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::__atomic_add_dispatch (&((struct _Sp_counted_base *) this)->_M_weak_count, 1) >>>>>
   >>>;


;; Function const _Tp& std::_Any_data::_M_access() const [with _Tp = std::__future_base::_State_baseV2::_Setter<void, void>] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (const struct _Setter &) (const struct _Setter *) std::_Any_data::_M_access (this)>>;


;; Function _Tp* std::__addressof(_Tp&) [with _Tp = const std::__future_base::_State_baseV2::_Setter<void, void>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (const struct _Setter *) __r
   >>>;


;; Function const _Tp& std::_Any_data::_M_access() const [with _Tp = std::__future_base::_State_baseV2::_Setter<void, void>*] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (struct _Setter * const &) (struct _Setter * const *) std::_Any_data::_M_access (this)>>;


;; Function _Tp& std::_Any_data::_M_access() [with _Tp = std::__future_base::_State_baseV2::_Setter<void, void>] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (struct _Setter &) (struct _Setter *) std::_Any_data::_M_access (this)>>;


;; Function constexpr std::unary_function<std::thread*, void>::unary_function() (null)
;; enabled by -tree-original


{
  
}


;; Function constexpr std::_Maybe_unary_or_binary_function<void, std::thread*>::_Maybe_unary_or_binary_function() (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::unary_function<std::thread*, void>::unary_function ((struct unary_function *) this) >>>>>;
}


;; Function std::_Mem_fn_base<_MemFunPtr, __is_mem_fn>::_Mem_fn_base(std::_Mem_fn_base<_MemFunPtr, __is_mem_fn>::_Pmf) [with _MemFunPtr = void (std::thread::*)(); bool __is_mem_fn = true; std::_Mem_fn_base<_MemFunPtr, __is_mem_fn>::_Pmf = void (std::thread::*)()] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Maybe_unary_or_binary_function<void, std::thread*>::_Maybe_unary_or_binary_function ((struct _Maybe_unary_or_binary_function *) this) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Mem_fn_base *) this)->_M_pmf = __pmf) >>>>>;
}


;; Function constexpr _Head& std::__get_helper(std::_Tuple_impl<_Idx, _Head, _Tail ...>&) [with long unsigned int __i = 0ul; _Head = std::_Mem_fn<void (std::thread::*)()>; _Tail = {std::reference_wrapper<std::thread>}] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct _Mem_fn &) (struct _Mem_fn *) std::_Tuple_impl<0ul, std::_Mem_fn<void (std::thread::*)()>, std::reference_wrapper<std::thread> >::_M_head ((struct _Tuple_impl &) (struct _Tuple_impl *) __t)>>
   >>>;


;; Function constexpr std::__tuple_element_t<__i, std::tuple<_Elements ...> >& std::get(std::tuple<_Elements ...>&) [with long unsigned int __i = 0ul; _Elements = {std::_Mem_fn<void (std::thread::*)()>, std::reference_wrapper<std::thread>}; std::__tuple_element_t<__i, std::tuple<_Elements ...> > = std::_Mem_fn<void (std::thread::*)()>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct __tuple_element_t &) (struct _Mem_fn *) std::__get_helper<0ul, std::_Mem_fn<void (std::thread::*)()>, std::reference_wrapper<std::thread> > ((struct _Tuple_impl &) &((struct tuple *) __t)->D.95234)>>
   >>>;


;; Function constexpr _Head& std::__get_helper(std::_Tuple_impl<_Idx, _Head, _Tail ...>&) [with long unsigned int __i = 1ul; _Head = std::reference_wrapper<std::thread>; _Tail = {}] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct reference_wrapper &) (struct reference_wrapper *) std::_Tuple_impl<1ul, std::reference_wrapper<std::thread> >::_M_head ((struct _Tuple_impl &) (struct _Tuple_impl *) __t)>>
   >>>;


;; Function constexpr std::__tuple_element_t<__i, std::tuple<_Elements ...> >& std::get(std::tuple<_Elements ...>&) [with long unsigned int __i = 1ul; _Elements = {std::_Mem_fn<void (std::thread::*)()>, std::reference_wrapper<std::thread>}; std::__tuple_element_t<__i, std::tuple<_Elements ...> > = std::reference_wrapper<std::thread>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct __tuple_element_t &) (struct reference_wrapper *) std::__get_helper<1ul, std::reference_wrapper<std::thread> > ((struct _Tuple_impl &) &((struct tuple *) __t)->D.95234.D.94562)>>
   >>>;


;; Function typename std::result_of<_Functor(_ArgTypes ...)>::type std::_Bind_simple<_Callable(_Args ...)>::_M_invoke(std::_Index_tuple<_Indices ...>) [with long unsigned int ..._Indices = {0ul}; _Callable = std::_Mem_fn<void (std::thread::*)()>; _Args = {std::reference_wrapper<std::thread>}; typename std::result_of<_Functor(_ArgTypes ...)>::type = void] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::_Mem_fn_base<void (std::thread::*)(), true>::operator()<std::thread, void> (&((struct _Mem_fn *) std::forward<std::_Mem_fn<void (std::thread::*)()> > ((struct type &) (struct __tuple_element_t *) std::get<0ul, std::_Mem_fn<void (std::thread::*)()>, std::reference_wrapper<std::thread> > ((struct tuple &) &((struct _Bind_simple *) this)->_M_bound)))->D.92875, TARGET_EXPR <D.112040, *(const struct reference_wrapper &) (const struct reference_wrapper *) std::forward<std::reference_wrapper<std::thread> > ((struct type &) (struct __tuple_element_t *) std::get<1ul, std::_Mem_fn<void (std::thread::*)()>, std::reference_wrapper<std::thread> > ((struct tuple &) &((struct _Bind_simple *) this)->_M_bound))>) >>>>>;
return;


;; Function std::allocator< <template-parameter-1-1> >::allocator() [with _Tp = std::packaged_task<long int(int, int)>] (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<std::packaged_task<long int(int, int)> >::new_allocator ((struct new_allocator *) this) >>>>>;
    try
      {
        
      }
    catch
      {
        __gnu_cxx::new_allocator<std::packaged_task<long int(int, int)> >::~new_allocator ((struct new_allocator *) this);
      }
  }
   >>>;


;; Function __gnu_cxx::new_allocator<_Tp>::~new_allocator() [with _Tp = std::packaged_task<long int(int, int)>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    
  }
  <D.112045>:;
   >>>;


;; Function static void std::allocator_traits<std::allocator<_CharT> >::deallocate(std::allocator_traits<std::allocator<_CharT> >::allocator_type&, std::allocator_traits<std::allocator<_CharT> >::pointer, std::allocator_traits<std::allocator<_CharT> >::size_type) [with _Tp = std::packaged_task<long int(int, int)>; std::allocator_traits<std::allocator<_CharT> >::allocator_type = std::allocator<std::packaged_task<long int(int, int)> >; std::allocator_traits<std::allocator<_CharT> >::pointer = std::packaged_task<long int(int, int)>*; std::allocator_traits<std::allocator<_CharT> >::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<std::packaged_task<long int(int, int)> >::deallocate ((struct new_allocator *) (struct allocator_type *) __a, __p, __n) >>>>>;


;; Function static void std::_Destroy_aux<<anonymous> >::__destroy(_ForwardIterator, _ForwardIterator) [with _ForwardIterator = std::packaged_task<long int(int, int)>*; bool <anonymous> = false] (null)
;; enabled by -tree-original


while (1)
  {
    if (__first == __last) goto <D.112057>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Destroy<std::packaged_task<long int(int, int)> > (std::__addressof<std::packaged_task<long int(int, int)> > ((struct packaged_task &) NON_LVALUE_EXPR <__first>)) >>>>>;
    <<cleanup_point (void)  ++__first>>;
  }
<D.112057>:;


;; Function std::allocator< <template-parameter-1-1> >::allocator() [with _Tp = std::future<long int>] (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<std::future<long int> >::new_allocator ((struct new_allocator *) this) >>>>>;
    try
      {
        
      }
    catch
      {
        __gnu_cxx::new_allocator<std::future<long int> >::~new_allocator ((struct new_allocator *) this);
      }
  }
   >>>;


;; Function __gnu_cxx::new_allocator<_Tp>::~new_allocator() [with _Tp = std::future<long int>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    
  }
  <D.112063>:;
   >>>;


;; Function static void std::allocator_traits<std::allocator<_CharT> >::deallocate(std::allocator_traits<std::allocator<_CharT> >::allocator_type&, std::allocator_traits<std::allocator<_CharT> >::pointer, std::allocator_traits<std::allocator<_CharT> >::size_type) [with _Tp = std::future<long int>; std::allocator_traits<std::allocator<_CharT> >::allocator_type = std::allocator<std::future<long int> >; std::allocator_traits<std::allocator<_CharT> >::pointer = std::future<long int>*; std::allocator_traits<std::allocator<_CharT> >::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<std::future<long int> >::deallocate ((struct new_allocator *) (struct allocator_type *) __a, __p, __n) >>>>>;


;; Function static void std::_Destroy_aux<<anonymous> >::__destroy(_ForwardIterator, _ForwardIterator) [with _ForwardIterator = std::future<long int>*; bool <anonymous> = false] (null)
;; enabled by -tree-original


while (1)
  {
    if (__first == __last) goto <D.112075>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Destroy<std::future<long int> > (std::__addressof<std::future<long int> > ((struct future &) NON_LVALUE_EXPR <__first>)) >>>>>;
    <<cleanup_point (void)  ++__first>>;
  }
<D.112075>:;


;; Function std::allocator< <template-parameter-1-1> >::allocator() [with _Tp = std::thread*] (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<std::thread*>::new_allocator ((struct new_allocator *) this) >>>>>;
    try
      {
        
      }
    catch
      {
        __gnu_cxx::new_allocator<std::thread*>::~new_allocator ((struct new_allocator *) this);
      }
  }
   >>>;


;; Function __gnu_cxx::new_allocator<_Tp>::~new_allocator() [with _Tp = std::thread*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    
  }
  <D.112081>:;
   >>>;


;; Function static void std::allocator_traits<std::allocator<_CharT> >::deallocate(std::allocator_traits<std::allocator<_CharT> >::allocator_type&, std::allocator_traits<std::allocator<_CharT> >::pointer, std::allocator_traits<std::allocator<_CharT> >::size_type) [with _Tp = std::thread*; std::allocator_traits<std::allocator<_CharT> >::allocator_type = std::allocator<std::thread*>; std::allocator_traits<std::allocator<_CharT> >::pointer = std::thread**; std::allocator_traits<std::allocator<_CharT> >::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<std::thread*>::deallocate ((struct new_allocator *) (struct allocator_type *) __a, __p, __n) >>>>>;


;; Function static void std::_Destroy_aux<true>::__destroy(_ForwardIterator, _ForwardIterator) [with _ForwardIterator = std::thread**] (null)
;; enabled by -tree-original





;; Function constexpr _Tp&& std::forward(typename std::remove_reference<_From>::type&) [with _Tp = const std::allocator<int>&; typename std::remove_reference<_From>::type = const std::allocator<int>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (const struct allocator &) (const struct allocator *) NON_LVALUE_EXPR <(const struct allocator &) __t>
   >>>;


;; Function std::shared_ptr<_Tp1> std::allocate_shared(const _Alloc&, _Args&& ...) [with _Tp = std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>; _Alloc = std::allocator<int>; _Args = {long int (&)(int, int), const std::allocator<int>&}] (null)
;; enabled by -tree-original


<<cleanup_point return *<retval> = TARGET_EXPR <D.112116, <<< Unknown tree: aggr_init_expr
  8
  __comp_ctor 
  D.112116
  (struct shared_ptr *) <<< Unknown tree: void_cst >>>
  TARGET_EXPR <D.112090, {}>;, <<< Unknown tree: empty_class_expr >>>;
  (const struct allocator &) (const struct allocator *) __a
  (long int (&<T105d3>) (int, int)) (long int (*<T105d2>) (int, int)) std::forward<long int (&)(int, int)> ((long int (&<T15f36>) (int, int)) (long int (*<T105d2>) (int, int)) __args#0)
  (const struct allocator &) (const struct allocator *) std::forward<const std::allocator<int>&> ((const struct type &) (const struct allocator *) __args#1) >>>>>>;


;; Function constexpr typename std::remove_reference< <template-parameter-1-1> >::type&& std::move(_Tp&&) [with _Tp = std::shared_ptr<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)> >&; typename std::remove_reference< <template-parameter-1-1> >::type = std::shared_ptr<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)> >] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct type &) (struct type *) NON_LVALUE_EXPR <(struct type &) __t>
   >>>;


;; Function std::shared_ptr<_Tp>::shared_ptr(std::shared_ptr<_Tp1>&&) [with _Tp1 = std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>; <template-parameter-2-2> = void; _Tp = std::__future_base::_Task_state_base<long int(int, int)>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__shared_ptr<std::__future_base::_Task_state_base<long int(int, int)>, (__gnu_cxx::_Lock_policy)2u>::__shared_ptr<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, void> (&((struct shared_ptr *) this)->D.82011, (struct __shared_ptr &) (struct __shared_ptr *) NON_LVALUE_EXPR <(struct __shared_ptr &) &((struct type *) std::move<std::shared_ptr<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)> >&> ((struct shared_ptr &) (struct shared_ptr *) __r))->D.109703>) >>>>>;
    try
      {
        
      }
    catch
      {
        std::__shared_ptr<std::__future_base::_Task_state_base<long int(int, int)>, (__gnu_cxx::_Lock_policy)2u>::~__shared_ptr (&((struct shared_ptr *) this)->D.82011);
      }
  }
   >>>;


;; Function std::__shared_ptr<_Tp, _Lp>::__shared_ptr(std::__shared_ptr<_Tp, _Lp>&&) [with _Tp = std::__future_base::_Task_state_base<long int(int, int)>; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __shared_ptr *) this)->_M_ptr = __r->_M_ptr) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __shared_ptr *) this)->_M_refcount = <<< Unknown tree: aggr_init_expr
  4
  __comp_ctor 
  D.112166
  (struct __shared_count *) <<< Unknown tree: void_cst >>> >>>) >>>>>;
    try
      {
        <<cleanup_point <<< Unknown tree: expr_stmt
  std::__shared_count<>::_M_swap (&((struct __shared_ptr *) this)->_M_refcount, (struct __shared_count &) &__r->_M_refcount) >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__r->_M_ptr = 0B) >>>>>;
      }
    catch
      {
        std::__shared_count<>::~__shared_count (&((struct __shared_ptr *) this)->_M_refcount);
      }
  }
   >>>;


;; Function static constexpr const _Head& std::_Head_base<_Idx, _Head, false>::_M_head(const std::_Head_base<_Idx, _Head, false>&) [with long unsigned int _Idx = 0ul; _Head = std::__future_base::_Result<long int>*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct _Result * const &) &__b->_M_head_impl
   >>>;


;; Function static constexpr const _Head& std::_Tuple_impl<_Idx, _Head, _Tail ...>::_M_head(const std::_Tuple_impl<_Idx, _Head, _Tail ...>&) [with long unsigned int _Idx = 0ul; _Head = std::__future_base::_Result<long int>*; _Tail = {std::__future_base::_Result_base::_Deleter}] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct _Result * const &) (struct _Result * const *) std::_Head_base<0ul, std::__future_base::_Result<long int>*, false>::_M_head ((const struct _Head_base &) &((const struct _Tuple_impl *) __t)->D.97692)>>
   >>>;


;; Function constexpr const _Head& std::__get_helper(const std::_Tuple_impl<_Idx, _Head, _Tail ...>&) [with long unsigned int __i = 0ul; _Head = std::__future_base::_Result<long int>*; _Tail = {std::__future_base::_Result_base::_Deleter}] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct _Result * const &) (struct _Result * const *) std::_Tuple_impl<0ul, std::__future_base::_Result<long int>*, std::__future_base::_Result_base::_Deleter>::_M_head ((const struct _Tuple_impl &) (const struct _Tuple_impl *) __t)>>
   >>>;


;; Function constexpr std::__tuple_element_t<__i, std::tuple<_Elements ...> >& std::get(const std::tuple<_Elements ...>&) [with long unsigned int __i = 0ul; _Elements = {std::__future_base::_Result<long int>*, std::__future_base::_Result_base::_Deleter}; std::__tuple_element_t<__i, std::tuple<_Elements ...> > = std::__future_base::_Result<long int>*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct _Result * const &) (struct _Result * const *) std::__get_helper<0ul, std::__future_base::_Result<long int>*, std::__future_base::_Result_base::_Deleter> ((const struct _Tuple_impl &) &((const struct tuple *) __t)->D.98360)>>
   >>>;


;; Function std::unique_ptr<_Tp, _Dp>::pointer std::unique_ptr<_Tp, _Dp>::get() const [with _Tp = std::__future_base::_Result<long int>; _Dp = std::__future_base::_Result_base::_Deleter; std::unique_ptr<_Tp, _Dp>::pointer = std::__future_base::_Result<long int>*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct _Result *) *std::get<0ul, std::__future_base::_Result<long int>*, std::__future_base::_Result_base::_Deleter> ((const struct tuple &) &((const struct unique_ptr *) this)->_M_t)>>
   >>>;


;; Function std::vector<_Tp, _Alloc>::size_type std::vector<_Tp, _Alloc>::max_size() const [with _Tp = std::packaged_task<long int(int, int)>; _Alloc = std::allocator<std::packaged_task<long int(int, int)> >; std::vector<_Tp, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::allocator_traits<std::allocator<std::packaged_task<long int(int, int)> > >::max_size ((const struct allocator_type &) (const struct _Tp_alloc_type *) std::_Vector_base<std::packaged_task<long int(int, int)>, std::allocator<std::packaged_task<long int(int, int)> > >::_M_get_Tp_allocator (&((const struct vector *) this)->D.78390))>>
   >>>;


;; Function static _Tp* std::allocator_traits<std::allocator<_CharT> >::allocate(std::allocator_traits<std::allocator<_CharT> >::allocator_type&, std::allocator_traits<std::allocator<_CharT> >::size_type) [with _Tp = std::packaged_task<long int(int, int)>; std::allocator_traits<std::allocator<_CharT> >::pointer = std::packaged_task<long int(int, int)>*; std::allocator_traits<std::allocator<_CharT> >::allocator_type = std::allocator<std::packaged_task<long int(int, int)> >; std::allocator_traits<std::allocator<_CharT> >::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (struct packaged_task *) __gnu_cxx::new_allocator<std::packaged_task<long int(int, int)> >::allocate ((struct new_allocator *) (struct allocator_type *) __a, __n, 0B)>>;


;; Function _ReturnType std::__make_move_if_noexcept_iterator(_Iterator) [with _Iterator = std::packaged_task<long int(int, int)>*; _ReturnType = std::move_iterator<std::packaged_task<long int(int, int)>*>] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = TARGET_EXPR <D.112178, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.112178
  (struct move_iterator *) <<< Unknown tree: void_cst >>>
  __i >>>>;, D.112178>>;


;; Function _ForwardIterator std::__uninitialized_copy_a(_InputIterator, _InputIterator, _ForwardIterator, std::allocator<_Tp>&) [with _InputIterator = std::move_iterator<std::packaged_task<long int(int, int)>*>; _ForwardIterator = std::packaged_task<long int(int, int)>*; _Tp = std::packaged_task<long int(int, int)>] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = std::uninitialized_copy<std::move_iterator<std::packaged_task<long int(int, int)>*>, std::packaged_task<long int(int, int)>*> (TARGET_EXPR <D.112184, __first>, TARGET_EXPR <D.112185, __last>, __result)>>;


;; Function void __gnu_cxx::new_allocator<_Tp>::destroy(_Up*) [with _Up = std::packaged_task<long int(int, int)>; _Tp = std::packaged_task<long int(int, int)>] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::packaged_task<long int(int, int)>::~packaged_task (NON_LVALUE_EXPR <__p>) >>>>>;


;; Function std::vector<_Tp, _Alloc>::size_type std::vector<_Tp, _Alloc>::max_size() const [with _Tp = std::future<long int>; _Alloc = std::allocator<std::future<long int> >; std::vector<_Tp, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::allocator_traits<std::allocator<std::future<long int> > >::max_size ((const struct allocator_type &) (const struct _Tp_alloc_type *) std::_Vector_base<std::future<long int>, std::allocator<std::future<long int> > >::_M_get_Tp_allocator (&((const struct vector *) this)->D.79511))>>
   >>>;


;; Function static _Tp* std::allocator_traits<std::allocator<_CharT> >::allocate(std::allocator_traits<std::allocator<_CharT> >::allocator_type&, std::allocator_traits<std::allocator<_CharT> >::size_type) [with _Tp = std::future<long int>; std::allocator_traits<std::allocator<_CharT> >::pointer = std::future<long int>*; std::allocator_traits<std::allocator<_CharT> >::allocator_type = std::allocator<std::future<long int> >; std::allocator_traits<std::allocator<_CharT> >::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (struct future *) __gnu_cxx::new_allocator<std::future<long int> >::allocate ((struct new_allocator *) (struct allocator_type *) __a, __n, 0B)>>;


;; Function _ReturnType std::__make_move_if_noexcept_iterator(_Iterator) [with _Iterator = std::future<long int>*; _ReturnType = std::move_iterator<std::future<long int>*>] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = TARGET_EXPR <D.112190, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.112190
  (struct move_iterator *) <<< Unknown tree: void_cst >>>
  __i >>>>;, D.112190>>;


;; Function _ForwardIterator std::__uninitialized_copy_a(_InputIterator, _InputIterator, _ForwardIterator, std::allocator<_Tp>&) [with _InputIterator = std::move_iterator<std::future<long int>*>; _ForwardIterator = std::future<long int>*; _Tp = std::future<long int>] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = std::uninitialized_copy<std::move_iterator<std::future<long int>*>, std::future<long int>*> (TARGET_EXPR <D.112196, __first>, TARGET_EXPR <D.112197, __last>, __result)>>;


;; Function void __gnu_cxx::new_allocator<_Tp>::destroy(_Up*) [with _Up = std::future<long int>; _Tp = std::future<long int>] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::future<long int>::~future (NON_LVALUE_EXPR <__p>) >>>>>;


;; Function void std::packaged_task<_Res(_ArgTypes ...)>::swap(std::packaged_task<_Res(_ArgTypes ...)>&) [with _Res = long int; _ArgTypes = {int, int}] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__shared_ptr<std::__future_base::_Task_state_base<long int(int, int)>, (__gnu_cxx::_Lock_policy)2u>::swap (&((struct packaged_task *) this)->_M_state.D.82011, (struct __shared_ptr &) &__other->_M_state.D.82011) >>>>>
   >>>;


;; Function std::allocator< <template-parameter-1-1> >::allocator() [with _Tp = std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >] (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >::new_allocator ((struct new_allocator *) this) >>>>>;
    try
      {
        
      }
    catch
      {
        __gnu_cxx::new_allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >::~new_allocator ((struct new_allocator *) this);
      }
  }
   >>>;


;; Function std::allocator< <template-parameter-1-1> >::~allocator() [with _Tp = std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >] (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  {
    try
      {
        
      }
    finally
      {
        __gnu_cxx::new_allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >::~new_allocator ((struct new_allocator *) this);
      }
  }
  <D.112204>:;
   >>>;


;; Function std::shared_ptr<_Tp1> std::allocate_shared(const _Alloc&, _Args&& ...) [with _Tp = std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >; _Alloc = std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >; _Args = {std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)>}] (null)
;; enabled by -tree-original


<<cleanup_point return *<retval> = TARGET_EXPR <D.112227, <<< Unknown tree: aggr_init_expr
  7
  __comp_ctor 
  D.112227
  (struct shared_ptr *) <<< Unknown tree: void_cst >>>
  TARGET_EXPR <D.112211, {}>;, <<< Unknown tree: empty_class_expr >>>;
  (const struct allocator &) (const struct allocator *) __a
  (struct _Bind_simple &) (struct _Bind_simple *) std::forward<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > ((struct type &) (struct _Bind_simple *) __args#0) >>>>>>;


;; Function std::__shared_ptr<_Tp, _Lp>::__shared_ptr(std::__shared_ptr<_Tp, _Lp>&&) [with _Tp = std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __shared_ptr *) this)->_M_ptr = __r->_M_ptr) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __shared_ptr *) this)->_M_refcount = <<< Unknown tree: aggr_init_expr
  4
  __comp_ctor 
  D.112229
  (struct __shared_count *) <<< Unknown tree: void_cst >>> >>>) >>>>>;
    try
      {
        <<cleanup_point <<< Unknown tree: expr_stmt
  std::__shared_count<>::_M_swap (&((struct __shared_ptr *) this)->_M_refcount, (struct __shared_count &) &__r->_M_refcount) >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__r->_M_ptr = 0B) >>>>>;
      }
    catch
      {
        std::__shared_count<>::~__shared_count (&((struct __shared_ptr *) this)->_M_refcount);
      }
  }
   >>>;


;; Function void __gnu_cxx::new_allocator<_Tp>::construct(_Up*, _Args&& ...) [with _Up = std::thread*; _Args = {std::thread*}; _Tp = std::thread*] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (TARGET_EXPR <D.112236, *std::forward<std::thread*> ((struct thread * &) (struct thread * *) __args#0)>;, TARGET_EXPR <D.112234, (void *) __p>;, TARGET_EXPR <D.112235, operator new (8, NON_LVALUE_EXPR <D.112234>)>;;, (struct thread * *) D.112235 != 0B ? try
    {
      *(struct thread * *) D.112235 = NON_LVALUE_EXPR <D.112236>;
    }
  catch
    {
      operator delete (D.112235, NON_LVALUE_EXPR <D.112234>);
    }, (struct thread * *) D.112235; : (struct thread * *) D.112235;) >>>>>;


;; Function std::vector<_Tp, _Alloc>::size_type std::vector<_Tp, _Alloc>::_M_check_len(std::vector<_Tp, _Alloc>::size_type, const char*) const [with _Tp = std::thread*; _Alloc = std::allocator<std::thread*>; std::vector<_Tp, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


{
  const size_type __len;

  if (<<cleanup_point std::vector<std::thread*>::max_size (this) - std::vector<std::thread*>::size (this) < __n>>)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_length_error (*(const char * &) &__s) >>>>>;
    }
    const size_type __len;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__len = std::vector<std::thread*>::size (this) + (long unsigned int) *std::max<long unsigned int> ((const long unsigned int &) &TARGET_EXPR <D.112239, std::vector<std::thread*>::size (this)>, (const long unsigned int &) (const long unsigned int *) &__n)) >>>>>;
  <<cleanup_point return <retval> = std::vector<std::thread*>::size (this) > (long unsigned int) __len || std::vector<std::thread*>::max_size (this) < (long unsigned int) __len ? std::vector<std::thread*>::max_size (this) : (size_type) __len>>;
}


;; Function std::_Vector_base<_Tp, _Alloc>::pointer std::_Vector_base<_Tp, _Alloc>::_M_allocate(std::size_t) [with _Tp = std::thread*; _Alloc = std::allocator<std::thread*>; std::_Vector_base<_Tp, _Alloc>::pointer = std::thread**; std::size_t = long unsigned int] (null)
;; enabled by -tree-original


{
  typedef struct _Tr _Tr;

  <<cleanup_point return <retval> = __n != 0 ? (struct thread * *) std::allocator_traits<std::allocator<std::thread*> >::allocate ((struct allocator_type &) (struct allocator *) &((struct _Vector_base *) this)->_M_impl, __n) : 0B>>;
}


;; Function std::vector<_Tp, _Alloc>::size_type std::vector<_Tp, _Alloc>::size() const [with _Tp = std::thread*; _Alloc = std::allocator<std::thread*>; std::vector<_Tp, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (size_type) (((long int) ((const struct vector *) this)->D.80632._M_impl._M_finish - (long int) ((const struct vector *) this)->D.80632._M_impl._M_start) /[ex] 8)
   >>>;


;; Function _ForwardIterator std::__uninitialized_move_if_noexcept_a(_InputIterator, _InputIterator, _ForwardIterator, _Allocator&) [with _InputIterator = std::thread**; _ForwardIterator = std::thread**; _Allocator = std::allocator<std::thread*>] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = std::__uninitialized_copy_a<std::move_iterator<std::thread**>, std::thread**, std::thread*> (TARGET_EXPR <D.112563, std::__make_move_if_noexcept_iterator<std::thread**, std::move_iterator<std::thread**> > (__first)>, TARGET_EXPR <D.112573, std::__make_move_if_noexcept_iterator<std::thread**, std::move_iterator<std::thread**> > (__last)>, __result, (struct allocator &) (struct allocator *) __alloc)>>;


;; Function static void std::allocator_traits<std::allocator<_CharT> >::destroy(std::allocator_traits<std::allocator<_CharT> >::allocator_type&, _Up*) [with _Up = std::thread*; _Tp = std::thread*; std::allocator_traits<std::allocator<_CharT> >::allocator_type = std::allocator<std::thread*>] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<std::thread*>::destroy<std::thread*> ((struct new_allocator *) (struct allocator_type *) __a, __p) >>>>>;


;; Function void* __gnu_cxx::__aligned_buffer<_Tp>::_M_addr() [with _Tp = long int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (void *) &((struct __aligned_buffer *) this)->_M_storage
   >>>;


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_construct(_InIterator, _InIterator, std::forward_iterator_tag) [with _FwdIterator = char*; _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>] (null)
;; enabled by -tree-original


{
  size_type __dnew;

  if (<<cleanup_point __gnu_cxx::__is_null_pointer<char> (__beg) && __beg != __end>>)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_logic_error ((const char *) "basic_string::_M_construct null not valid") >>>>>;
    }
    size_type __dnew;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__dnew = (size_type) std::distance<char*> (__beg, __end)) >>>>>;
  if (__dnew > 15)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_M_data (this, std::__cxx11::basic_string<char>::_M_create (this, (size_type &) &__dnew, 0)) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_M_capacity (this, __dnew) >>>>>;
    }
  <<< Unknown tree: try_block
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_S_copy_chars (std::__cxx11::basic_string<char>::_M_data (this), __beg, __end) >>>>>
  <<< Unknown tree: handler
  
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) __cxa_begin_catch (__builtin_eh_pointer (0)) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_M_dispose (this) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  <<< Unknown tree: throw_expr
  __cxa_rethrow () >>> >>>>>;
    }
  finally
    {
      __cxa_end_catch ();
    } >>> >>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_M_set_length (this, __dnew) >>>>>;
}


;; Function void __gnu_cxx::new_allocator<_Tp>::deallocate(__gnu_cxx::new_allocator<_Tp>::pointer, __gnu_cxx::new_allocator<_Tp>::size_type) [with _Tp = char; __gnu_cxx::new_allocator<_Tp>::pointer = char*; __gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  operator delete ((void *) __p) >>>>>;


;; Function _Tp* std::__addressof(_Tp&) [with _Tp = char] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (char *) (char &) (const char *) (const char &) __r
   >>>;


;; Function _Tp* std::addressof(_Tp&) [with _Tp = const char] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::__addressof<const char> ((const char &) (const char *) __r)>>
   >>>;


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_construct(_InIterator, _InIterator, std::forward_iterator_tag) [with _FwdIterator = wchar_t*; _CharT = wchar_t; _Traits = std::char_traits<wchar_t>; _Alloc = std::allocator<wchar_t>] (null)
;; enabled by -tree-original


{
  size_type __dnew;

  if (<<cleanup_point __gnu_cxx::__is_null_pointer<wchar_t> (__beg) && __beg != __end>>)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_logic_error ((const char *) "basic_string::_M_construct null not valid") >>>>>;
    }
    size_type __dnew;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__dnew = (size_type) std::distance<wchar_t*> (__beg, __end)) >>>>>;
  if (__dnew > 3)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<wchar_t>::_M_data (this, std::__cxx11::basic_string<wchar_t>::_M_create (this, (size_type &) &__dnew, 0)) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<wchar_t>::_M_capacity (this, __dnew) >>>>>;
    }
  <<< Unknown tree: try_block
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<wchar_t>::_S_copy_chars (std::__cxx11::basic_string<wchar_t>::_M_data (this), __beg, __end) >>>>>
  <<< Unknown tree: handler
  
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) __cxa_begin_catch (__builtin_eh_pointer (0)) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<wchar_t>::_M_dispose (this) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  <<< Unknown tree: throw_expr
  __cxa_rethrow () >>> >>>>>;
    }
  finally
    {
      __cxa_end_catch ();
    } >>> >>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<wchar_t>::_M_set_length (this, __dnew) >>>>>;
}


;; Function void __gnu_cxx::new_allocator<_Tp>::deallocate(__gnu_cxx::new_allocator<_Tp>::pointer, __gnu_cxx::new_allocator<_Tp>::size_type) [with _Tp = wchar_t; __gnu_cxx::new_allocator<_Tp>::pointer = wchar_t*; __gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  operator delete ((void *) __p) >>>>>;


;; Function _Tp* std::__addressof(_Tp&) [with _Tp = wchar_t] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (wchar_t *) __r
   >>>;


;; Function _Tp* std::addressof(_Tp&) [with _Tp = const wchar_t] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::__addressof<const wchar_t> ((const wchar_t &) (const wchar_t *) __r)>>
   >>>;


;; Function bool __gnu_cxx::__is_null_pointer(_Type*) [with _Type = const char] (null)
;; enabled by -tree-original


return <retval> = __ptr == 0B;


;; Function typename std::iterator_traits<_Iterator>::difference_type std::distance(_InputIterator, _InputIterator) [with _InputIterator = const char*; typename std::iterator_traits<_Iterator>::difference_type = long int] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = std::__distance<const char*> (__first, __last, TARGET_EXPR <D.112656, std::__iterator_category<const char*> ((const char * const &) (const char * const *) &__first)>;, <<< Unknown tree: empty_class_expr >>>;)>>;


;; Function static void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_S_copy_chars(_CharT*, const _CharT*, const _CharT*) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_S_copy (__p, __k1, (size_type) ((long int) __k2 - (long int) __k1)) >>>>>
   >>>;


;; Function bool __gnu_cxx::__is_null_pointer(_Type*) [with _Type = const wchar_t] (null)
;; enabled by -tree-original


return <retval> = __ptr == 0B;


;; Function typename std::iterator_traits<_Iterator>::difference_type std::distance(_InputIterator, _InputIterator) [with _InputIterator = const wchar_t*; typename std::iterator_traits<_Iterator>::difference_type = long int] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = std::__distance<const wchar_t*> (__first, __last, TARGET_EXPR <D.112670, std::__iterator_category<const wchar_t*> ((const wchar_t * const &) (const wchar_t * const *) &__first)>;, <<< Unknown tree: empty_class_expr >>>;)>>;


;; Function static void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_S_copy_chars(_CharT*, const _CharT*, const _CharT*) [with _CharT = wchar_t; _Traits = std::char_traits<wchar_t>; _Alloc = std::allocator<wchar_t>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<wchar_t>::_S_copy (__p, __k1, (size_type) (((long int) __k2 - (long int) __k1) /[ex] 4)) >>>>>
   >>>;


;; Function _Tp* std::__addressof(_Tp&) [with _Tp = char16_t] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (char16_t *) __r
   >>>;


;; Function bool __gnu_cxx::__is_null_pointer(_Type*) [with _Type = const char16_t] (null)
;; enabled by -tree-original


return <retval> = __ptr == 0B;


;; Function typename std::iterator_traits<_Iterator>::difference_type std::distance(_InputIterator, _InputIterator) [with _InputIterator = const char16_t*; typename std::iterator_traits<_Iterator>::difference_type = long int] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = std::__distance<const char16_t*> (__first, __last, TARGET_EXPR <D.112685, std::__iterator_category<const char16_t*> ((const char16_t * const &) (const char16_t * const *) &__first)>;, <<< Unknown tree: empty_class_expr >>>;)>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_create(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type&, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type) [with _CharT = char16_t; _Traits = std::char_traits<char16_t>; _Alloc = std::allocator<char16_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer = char16_t*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


if (<<cleanup_point *__capacity > std::__cxx11::basic_string<char16_t>::max_size (this)>>)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_length_error ((const char *) "basic_string::_M_create") >>>>>;
  }
if (*__capacity > __old_capacity && *__capacity < __old_capacity * 2)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__capacity = __old_capacity * 2) >>>>>;
    if (<<cleanup_point *__capacity > std::__cxx11::basic_string<char16_t>::max_size (this)>>)
      {
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__capacity = std::__cxx11::basic_string<char16_t>::max_size (this)) >>>>>;
      }
  }
<<cleanup_point return <retval> = (char16_t *) std::allocator_traits<std::allocator<char16_t> >::allocate ((struct allocator_type &) (struct allocator_type *) std::__cxx11::basic_string<char16_t>::_M_get_allocator (this), *__capacity + 1)>>;


;; Function static void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_S_copy_chars(_CharT*, const _CharT*, const _CharT*) [with _CharT = char16_t; _Traits = std::char_traits<char16_t>; _Alloc = std::allocator<char16_t>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char16_t>::_S_copy (__p, __k1, (size_type) (((long int) __k2 - (long int) __k1) /[ex] 2)) >>>>>
   >>>;


;; Function void __gnu_cxx::new_allocator<_Tp>::deallocate(__gnu_cxx::new_allocator<_Tp>::pointer, __gnu_cxx::new_allocator<_Tp>::size_type) [with _Tp = char16_t; __gnu_cxx::new_allocator<_Tp>::pointer = char16_t*; __gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  operator delete ((void *) __p) >>>>>;


;; Function _Tp* std::addressof(_Tp&) [with _Tp = const char16_t] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::__addressof<const char16_t> ((const char16_t &) (const char16_t *) __r)>>
   >>>;


;; Function _Tp* std::__addressof(_Tp&) [with _Tp = char32_t] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (char32_t *) __r
   >>>;


;; Function bool __gnu_cxx::__is_null_pointer(_Type*) [with _Type = const char32_t] (null)
;; enabled by -tree-original


return <retval> = __ptr == 0B;


;; Function typename std::iterator_traits<_Iterator>::difference_type std::distance(_InputIterator, _InputIterator) [with _InputIterator = const char32_t*; typename std::iterator_traits<_Iterator>::difference_type = long int] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = std::__distance<const char32_t*> (__first, __last, TARGET_EXPR <D.112705, std::__iterator_category<const char32_t*> ((const char32_t * const &) (const char32_t * const *) &__first)>;, <<< Unknown tree: empty_class_expr >>>;)>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_create(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type&, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type) [with _CharT = char32_t; _Traits = std::char_traits<char32_t>; _Alloc = std::allocator<char32_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer = char32_t*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


if (<<cleanup_point *__capacity > std::__cxx11::basic_string<char32_t>::max_size (this)>>)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_length_error ((const char *) "basic_string::_M_create") >>>>>;
  }
if (*__capacity > __old_capacity && *__capacity < __old_capacity * 2)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__capacity = __old_capacity * 2) >>>>>;
    if (<<cleanup_point *__capacity > std::__cxx11::basic_string<char32_t>::max_size (this)>>)
      {
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__capacity = std::__cxx11::basic_string<char32_t>::max_size (this)) >>>>>;
      }
  }
<<cleanup_point return <retval> = (char32_t *) std::allocator_traits<std::allocator<char32_t> >::allocate ((struct allocator_type &) (struct allocator_type *) std::__cxx11::basic_string<char32_t>::_M_get_allocator (this), *__capacity + 1)>>;


;; Function static void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_S_copy_chars(_CharT*, const _CharT*, const _CharT*) [with _CharT = char32_t; _Traits = std::char_traits<char32_t>; _Alloc = std::allocator<char32_t>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char32_t>::_S_copy (__p, __k1, (size_type) (((long int) __k2 - (long int) __k1) /[ex] 4)) >>>>>
   >>>;


;; Function void __gnu_cxx::new_allocator<_Tp>::deallocate(__gnu_cxx::new_allocator<_Tp>::pointer, __gnu_cxx::new_allocator<_Tp>::size_type) [with _Tp = char32_t; __gnu_cxx::new_allocator<_Tp>::pointer = char32_t*; __gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  operator delete ((void *) __p) >>>>>;


;; Function _Tp* std::addressof(_Tp&) [with _Tp = const char32_t] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::__addressof<const char32_t> ((const char32_t &) (const char32_t *) __r)>>
   >>>;


;; Function static std::allocator_traits<std::allocator<_CharT> >::size_type std::allocator_traits<std::allocator<_CharT> >::max_size(const allocator_type&) [with _Tp = char; std::allocator_traits<std::allocator<_CharT> >::size_type = long unsigned int; std::allocator_traits<std::allocator<_CharT> >::allocator_type = std::allocator<char>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = __gnu_cxx::new_allocator<char>::max_size ((const struct new_allocator *) (const struct allocator_type *) __a)>>
   >>>;


;; Function constexpr typename std::remove_reference< <template-parameter-1-1> >::type&& std::move(_Tp&&) [with _Tp = const std::allocator<std::mutex>&; typename std::remove_reference< <template-parameter-1-1> >::type = const std::allocator<std::mutex>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (const struct type &) (const struct type *) NON_LVALUE_EXPR <(const struct type &) __t>
   >>>;


;; Function std::__shared_count<_Lp>::__shared_count(std::_Sp_make_shared_tag, _Tp*, const _Alloc&, _Args&& ...) [with _Tp = std::mutex; _Alloc = std::allocator<std::mutex>; _Args = {}; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __shared_count *) this)->_M_pi = 0B) >>>>>;
  {
    typedef struct _Sp_cp_type _Sp_cp_type;
    struct __allocator_type __a2;
    struct __allocated_ptr __guard;
    struct _Sp_cp_type * __mem;

        struct __allocator_type __a2;
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator<std::_Sp_counted_ptr_inplace<std::mutex, std::allocator<std::mutex>, (__gnu_cxx::_Lock_policy)2u> >::allocator<std::mutex> (&__a2, (const struct allocator &) (const struct allocator *) __a) >>>>>;
    try
      {
                struct __allocated_ptr __guard;
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__guard = <<< Unknown tree: aggr_init_expr
  4
  __allocate_guarded
  D.113337
  (struct allocator &) &__a2 >>>) >>>>>;
        try
          {
                        struct _Sp_cp_type * __mem;
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__mem = std::__allocated_ptr<std::allocator<std::_Sp_counted_ptr_inplace<std::mutex, std::allocator<std::mutex>, (__gnu_cxx::_Lock_policy)2u> > >::get (&__guard)) >>>>>;
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (TARGET_EXPR <D.113467, &TARGET_EXPR <D.113466, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.113466
  (struct allocator *) <<< Unknown tree: void_cst >>>
  (const struct allocator &) (const struct type *) std::move<const std::allocator<std::mutex>&> ((const struct allocator &) (const struct allocator *) __a) >>>>>;, TARGET_EXPR <D.113357, (void *) TARGET_EXPR <D.113355, __mem>>;, TARGET_EXPR <D.113356, operator new (56, NON_LVALUE_EXPR <D.113357>)>;;, (struct _Sp_cp_type *) D.113356 != 0B ? try
    {
      std::_Sp_counted_ptr_inplace<std::mutex, std::allocator<std::mutex>, (__gnu_cxx::_Lock_policy)2u>::_Sp_counted_ptr_inplace<> ((struct _Sp_cp_type *) D.113356, NON_LVALUE_EXPR <D.113467>);
    }
  catch
    {
      operator delete (D.113356, NON_LVALUE_EXPR <D.113357>);
    }, (struct _Sp_cp_type *) D.113356; : (struct _Sp_cp_type *) D.113356;) >>>>>;
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __shared_count *) this)->_M_pi = (struct _Sp_counted_base *) __mem) >>>>>;
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::__allocated_ptr<std::allocator<std::_Sp_counted_ptr_inplace<std::mutex, std::allocator<std::mutex>, (__gnu_cxx::_Lock_policy)2u> > >::operator= (&__guard, 0) >>>>>;
          }
        finally
          {
            std::__allocated_ptr<std::allocator<std::_Sp_counted_ptr_inplace<std::mutex, std::allocator<std::mutex>, (__gnu_cxx::_Lock_policy)2u> > >::~__allocated_ptr (&__guard);
          }
      }
    finally
      {
        std::allocator<std::_Sp_counted_ptr_inplace<std::mutex, std::allocator<std::mutex>, (__gnu_cxx::_Lock_policy)2u> >::~allocator (&__a2);
      }
  }
}


;; Function void* std::__shared_count<_Lp>::_M_get_deleter(const std::type_info&) const [with __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct _Sp_counted_base *) ((const struct __shared_count *) this)->_M_pi != 0B ? OBJ_TYPE_REF(*(((struct _Sp_counted_base *) ((const struct __shared_count *) this)->_M_pi)->_vptr._Sp_counted_base + 32);(struct _Sp_counted_base)(struct _Sp_counted_base *) ((const struct __shared_count *) this)->_M_pi->4) ((struct _Sp_counted_base *) ((const struct __shared_count *) this)->_M_pi, (const struct type_info &) (const struct type_info *) __ti) : 0B>>
   >>>;


;; Function void std::__enable_shared_from_this_helper(const std::__shared_count<_Lp>&, ...) [with __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  
   >>>;


;; Function std::_Mem_fn_base<_MemFunPtr, __is_mem_fn>::result_type std::_Mem_fn_base<_MemFunPtr, __is_mem_fn>::operator()(std::_Mem_fn_base<_MemFunPtr, __is_mem_fn>::_Class*, _Args&& ...) const [with _Args = {std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*}; _Req = void; _MemFunPtr = void (std::__future_base::_State_baseV2::*)(std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*, bool*); bool __is_mem_fn = true; std::_Mem_fn_base<_MemFunPtr, __is_mem_fn>::result_type = void; std::_Mem_fn_base<_MemFunPtr, __is_mem_fn>::_Class = std::__future_base::_State_baseV2] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (((long int) ((const struct _Mem_fn_base *) this)->_M_pmf.__pfn & 1) == 0) ? (void _State_baseV2::<Tc8fa> (struct _State_baseV2 *, struct function *, bool *) *) ((const struct _Mem_fn_base *) this)->_M_pmf.__pfn : (void _State_baseV2::<Tc8fa> (struct _State_baseV2 *, struct function *, bool *) *) (void _State_baseV2::<Tc8fa> (struct _State_baseV2 *, struct function *, bool *) * const) *(*(int (*__vtbl_ptr_type) () * *) (NON_LVALUE_EXPR <__object> + (sizetype) ((const struct _Mem_fn_base *) this)->_M_pmf.__delta) + (sizetype) ((long int) ((const struct _Mem_fn_base *) this)->_M_pmf.__pfn + -1)) (NON_LVALUE_EXPR <__object> + (sizetype) ((const struct _Mem_fn_base *) this)->_M_pmf.__delta, *std::forward<std::function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>()>*> ((struct function * &) (struct function * *) __args#0), *std::forward<bool*> ((bool * &) (bool * *) __args#1)) >>>>>;
return;


;; Function constexpr typename std::remove_reference< <template-parameter-1-1> >::type&& std::move(_Tp&&) [with _Tp = std::__future_base::_Result_base*&; typename std::remove_reference< <template-parameter-1-1> >::type = std::__future_base::_Result_base*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct _Result_base * &) (struct _Result_base * *) (struct _Result_base * &) __t
   >>>;


;; Function void std::swap(_Tp&, _Tp&) [with _Tp = std::__future_base::_Result_base*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    struct _Result_base * __tmp;

        struct _Result_base * __tmp;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__tmp = *std::move<std::__future_base::_Result_base*&> ((struct _Result_base * &) (struct _Result_base * *) __a)) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__a = *std::move<std::__future_base::_Result_base*&> ((struct _Result_base * &) (struct _Result_base * *) __b)) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__b = *std::move<std::__future_base::_Result_base*&> ((struct _Result_base * &) &__tmp)) >>>>>;
  }
   >>>;


;; Function void std::_Tuple_impl<_Idx, _Head>::_M_swap(std::_Tuple_impl<_Idx, _Head>&) [with long unsigned int _Idx = 1ul; _Head = std::__future_base::_Result_base::_Deleter] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    (void) 0;
    (void) 0;
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::swap<std::__future_base::_Result_base::_Deleter> ((struct _Deleter &) (struct _Deleter *) std::_Tuple_impl<1ul, std::__future_base::_Result_base::_Deleter>::_M_head ((struct _Tuple_impl &) (struct _Tuple_impl *) this), (struct _Deleter &) (struct _Deleter *) std::_Tuple_impl<1ul, std::__future_base::_Result_base::_Deleter>::_M_head ((struct _Tuple_impl &) (struct _Tuple_impl *) __in)) >>>>>;
  }
   >>>;


;; Function constexpr typename std::remove_reference< <template-parameter-1-1> >::type&& std::move(_Tp&&) [with _Tp = const std::allocator<std::__future_base::_State_baseV2>&; typename std::remove_reference< <template-parameter-1-1> >::type = const std::allocator<std::__future_base::_State_baseV2>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (const struct type &) (const struct type *) NON_LVALUE_EXPR <(const struct type &) __t>
   >>>;


;; Function std::__shared_count<_Lp>::__shared_count(std::_Sp_make_shared_tag, _Tp*, const _Alloc&, _Args&& ...) [with _Tp = std::__future_base::_State_baseV2; _Alloc = std::allocator<std::__future_base::_State_baseV2>; _Args = {}; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __shared_count *) this)->_M_pi = 0B) >>>>>;
  {
    typedef struct _Sp_cp_type _Sp_cp_type;
    struct __allocator_type __a2;
    struct __allocated_ptr __guard;
    struct _Sp_cp_type * __mem;

        struct __allocator_type __a2;
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator<std::_Sp_counted_ptr_inplace<std::__future_base::_State_baseV2, std::allocator<std::__future_base::_State_baseV2>, (__gnu_cxx::_Lock_policy)2u> >::allocator<std::__future_base::_State_baseV2> (&__a2, (const struct allocator &) (const struct allocator *) __a) >>>>>;
    try
      {
                struct __allocated_ptr __guard;
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__guard = <<< Unknown tree: aggr_init_expr
  4
  __allocate_guarded
  D.114114
  (struct allocator &) &__a2 >>>) >>>>>;
        try
          {
                        struct _Sp_cp_type * __mem;
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__mem = std::__allocated_ptr<std::allocator<std::_Sp_counted_ptr_inplace<std::__future_base::_State_baseV2, std::allocator<std::__future_base::_State_baseV2>, (__gnu_cxx::_Lock_policy)2u> > >::get (&__guard)) >>>>>;
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (TARGET_EXPR <D.114244, &TARGET_EXPR <D.114243, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.114243
  (struct allocator *) <<< Unknown tree: void_cst >>>
  (const struct allocator &) (const struct type *) std::move<const std::allocator<std::__future_base::_State_baseV2>&> ((const struct allocator &) (const struct allocator *) __a) >>>>>;, TARGET_EXPR <D.114134, (void *) TARGET_EXPR <D.114132, __mem>>;, TARGET_EXPR <D.114133, operator new (48, NON_LVALUE_EXPR <D.114134>)>;;, (struct _Sp_cp_type *) D.114133 != 0B ? try
    {
      std::_Sp_counted_ptr_inplace<std::__future_base::_State_baseV2, std::allocator<std::__future_base::_State_baseV2>, (__gnu_cxx::_Lock_policy)2u>::_Sp_counted_ptr_inplace<> ((struct _Sp_cp_type *) D.114133, NON_LVALUE_EXPR <D.114244>);
    }
  catch
    {
      operator delete (D.114133, NON_LVALUE_EXPR <D.114134>);
    }, (struct _Sp_cp_type *) D.114133; : (struct _Sp_cp_type *) D.114133;) >>>>>;
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __shared_count *) this)->_M_pi = (struct _Sp_counted_base *) __mem) >>>>>;
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::__allocated_ptr<std::allocator<std::_Sp_counted_ptr_inplace<std::__future_base::_State_baseV2, std::allocator<std::__future_base::_State_baseV2>, (__gnu_cxx::_Lock_policy)2u> > >::operator= (&__guard, 0) >>>>>;
          }
        finally
          {
            std::__allocated_ptr<std::allocator<std::_Sp_counted_ptr_inplace<std::__future_base::_State_baseV2, std::allocator<std::__future_base::_State_baseV2>, (__gnu_cxx::_Lock_policy)2u> > >::~__allocated_ptr (&__guard);
          }
      }
    finally
      {
        std::allocator<std::_Sp_counted_ptr_inplace<std::__future_base::_State_baseV2, std::allocator<std::__future_base::_State_baseV2>, (__gnu_cxx::_Lock_policy)2u> >::~allocator (&__a2);
      }
  }
}


;; Function constexpr typename std::remove_reference< <template-parameter-1-1> >::type&& std::move(_Tp&&) [with _Tp = std::__future_base::_Result<void>*&; typename std::remove_reference< <template-parameter-1-1> >::type = std::__future_base::_Result<void>*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct _Result * &) (struct _Result * *) (struct _Result * &) __t
   >>>;


;; Function void std::swap(_Tp&, _Tp&) [with _Tp = std::__future_base::_Result<void>*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    struct _Result * __tmp;

        struct _Result * __tmp;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__tmp = *std::move<std::__future_base::_Result<void>*&> ((struct _Result * &) (struct _Result * *) __a)) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__a = *std::move<std::__future_base::_Result<void>*&> ((struct _Result * &) (struct _Result * *) __b)) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__b = *std::move<std::__future_base::_Result<void>*&> ((struct _Result * &) &__tmp)) >>>>>;
  }
   >>>;


;; Function std::_Mem_fn_base<_MemFunPtr, __is_mem_fn>::result_type std::_Mem_fn_base<_MemFunPtr, __is_mem_fn>::operator()(std::reference_wrapper<_Tp>, _Args&& ...) const [with _Tp = std::thread; _Args = {}; _Req = void; _MemFunPtr = void (std::thread::*)(); bool __is_mem_fn = true; std::_Mem_fn_base<_MemFunPtr, __is_mem_fn>::result_type = void] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::_Mem_fn_base<void (std::thread::*)(), true>::operator()<, void> (this, (struct _Class &) (struct thread *) std::reference_wrapper<std::thread>::get (&__ref)) >>>>>;
return;


;; Function __gnu_cxx::new_allocator<_Tp>::new_allocator() [with _Tp = std::packaged_task<long int(int, int)>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    
  }
   >>>;


;; Function void __gnu_cxx::new_allocator<_Tp>::deallocate(__gnu_cxx::new_allocator<_Tp>::pointer, __gnu_cxx::new_allocator<_Tp>::size_type) [with _Tp = std::packaged_task<long int(int, int)>; __gnu_cxx::new_allocator<_Tp>::pointer = std::packaged_task<long int(int, int)>*; __gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  operator delete ((void *) __p) >>>>>;


;; Function _Tp* std::__addressof(_Tp&) [with _Tp = std::packaged_task<long int(int, int)>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct packaged_task *) __r
   >>>;


;; Function void std::_Destroy(_Tp*) [with _Tp = std::packaged_task<long int(int, int)>] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::packaged_task<long int(int, int)>::~packaged_task (NON_LVALUE_EXPR <__pointer>) >>>>>;


;; Function __gnu_cxx::new_allocator<_Tp>::new_allocator() [with _Tp = std::future<long int>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    
  }
   >>>;


;; Function void __gnu_cxx::new_allocator<_Tp>::deallocate(__gnu_cxx::new_allocator<_Tp>::pointer, __gnu_cxx::new_allocator<_Tp>::size_type) [with _Tp = std::future<long int>; __gnu_cxx::new_allocator<_Tp>::pointer = std::future<long int>*; __gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  operator delete ((void *) __p) >>>>>;


;; Function _Tp* std::__addressof(_Tp&) [with _Tp = std::future<long int>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct future *) __r
   >>>;


;; Function void std::_Destroy(_Tp*) [with _Tp = std::future<long int>] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::future<long int>::~future (NON_LVALUE_EXPR <__pointer>) >>>>>;


;; Function __gnu_cxx::new_allocator<_Tp>::new_allocator() [with _Tp = std::thread*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    
  }
   >>>;


;; Function void __gnu_cxx::new_allocator<_Tp>::deallocate(__gnu_cxx::new_allocator<_Tp>::pointer, __gnu_cxx::new_allocator<_Tp>::size_type) [with _Tp = std::thread*; __gnu_cxx::new_allocator<_Tp>::pointer = std::thread**; __gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  operator delete ((void *) __p) >>>>>;


;; Function std::shared_ptr<_Tp>::shared_ptr(std::_Sp_make_shared_tag, const _Alloc&, _Args&& ...) [with _Alloc = std::allocator<int>; _Args = {long int (&)(int, int), const std::allocator<int>&}; _Tp = std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__shared_ptr<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, (__gnu_cxx::_Lock_policy)2u>::__shared_ptr<std::allocator<int>, long int (&)(int, int), const std::allocator<int>&> (&((struct shared_ptr *) this)->D.109703, TARGET_EXPR <D.114324, __tag>;, <<< Unknown tree: empty_class_expr >>>;, (const struct allocator &) (const struct allocator *) __a, (long int (&<T105d3>) (int, int)) (long int (*<T105d2>) (int, int)) std::forward<long int (&)(int, int)> ((long int (&<T15f36>) (int, int)) (long int (*<T105d2>) (int, int)) __args#0), (const struct allocator &) (const struct allocator *) std::forward<const std::allocator<int>&> ((const struct type &) (const struct allocator *) __args#1)) >>>>>;
  try
    {
      
    }
  catch
    {
      std::__shared_ptr<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, (__gnu_cxx::_Lock_policy)2u>::~__shared_ptr (&((struct shared_ptr *) this)->D.109703);
    }
}


;; Function std::shared_ptr<_Tp>::shared_ptr(std::shared_ptr<_Tp>&&) [with _Tp = std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__shared_ptr<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, (__gnu_cxx::_Lock_policy)2u>::__shared_ptr (&((struct shared_ptr *) this)->D.109703, (struct __shared_ptr &) (struct __shared_ptr *) NON_LVALUE_EXPR <(struct __shared_ptr &) &((struct type *) std::move<std::shared_ptr<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)> >&> ((struct shared_ptr &) (struct shared_ptr *) __r))->D.109703>) >>>>>;
    try
      {
        
      }
    catch
      {
        std::__shared_ptr<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, (__gnu_cxx::_Lock_policy)2u>::~__shared_ptr (&((struct shared_ptr *) this)->D.109703);
      }
  }
   >>>;


;; Function std::__shared_ptr<_Tp, _Lp>::__shared_ptr(std::__shared_ptr<_Tp1, _Lp>&&) [with _Tp1 = std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>; <template-parameter-2-2> = void; _Tp = std::__future_base::_Task_state_base<long int(int, int)>; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __shared_ptr *) this)->_M_ptr = (struct _Task_state_base *) __r->_M_ptr) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __shared_ptr *) this)->_M_refcount = <<< Unknown tree: aggr_init_expr
  4
  __comp_ctor 
  D.114341
  (struct __shared_count *) <<< Unknown tree: void_cst >>> >>>) >>>>>;
    try
      {
        <<cleanup_point <<< Unknown tree: expr_stmt
  std::__shared_count<>::_M_swap (&((struct __shared_ptr *) this)->_M_refcount, (struct __shared_count &) &__r->_M_refcount) >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__r->_M_ptr = 0B) >>>>>;
      }
    catch
      {
        std::__shared_count<>::~__shared_count (&((struct __shared_ptr *) this)->_M_refcount);
      }
  }
   >>>;


;; Function static std::allocator_traits<std::allocator<_CharT> >::size_type std::allocator_traits<std::allocator<_CharT> >::max_size(const allocator_type&) [with _Tp = std::packaged_task<long int(int, int)>; std::allocator_traits<std::allocator<_CharT> >::size_type = long unsigned int; std::allocator_traits<std::allocator<_CharT> >::allocator_type = std::allocator<std::packaged_task<long int(int, int)> >] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = __gnu_cxx::new_allocator<std::packaged_task<long int(int, int)> >::max_size ((const struct new_allocator *) (const struct allocator_type *) __a)>>
   >>>;


;; Function const _Tp_alloc_type& std::_Vector_base<_Tp, _Alloc>::_M_get_Tp_allocator() const [with _Tp = std::packaged_task<long int(int, int)>; _Alloc = std::allocator<std::packaged_task<long int(int, int)> >; std::_Vector_base<_Tp, _Alloc>::_Tp_alloc_type = std::allocator<std::packaged_task<long int(int, int)> >] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (const struct _Tp_alloc_type &) (const struct _Tp_alloc_type *) (const struct allocator *) &((const struct _Vector_base *) this)->_M_impl
   >>>;


;; Function _Tp* __gnu_cxx::new_allocator<_Tp>::allocate(__gnu_cxx::new_allocator<_Tp>::size_type, const void*) [with _Tp = std::packaged_task<long int(int, int)>; __gnu_cxx::new_allocator<_Tp>::pointer = std::packaged_task<long int(int, int)>*; __gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int] (null)
;; enabled by -tree-original


if (<<cleanup_point __gnu_cxx::new_allocator<std::packaged_task<long int(int, int)> >::max_size (this) < __n>>)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_bad_alloc () >>>>>;
  }
<<cleanup_point return <retval> = (struct packaged_task *) operator new (16 * __n)>>;


;; Function std::move_iterator<_Iterator>::move_iterator(std::move_iterator<_Iterator>::iterator_type) [with _Iterator = std::packaged_task<long int(int, int)>*; std::move_iterator<_Iterator>::iterator_type = std::packaged_task<long int(int, int)>*] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct move_iterator *) this)->_M_current = __i) >>>>>;
}


;; Function _ForwardIterator std::uninitialized_copy(_InputIterator, _InputIterator, _ForwardIterator) [with _InputIterator = std::move_iterator<std::packaged_task<long int(int, int)>*>; _ForwardIterator = std::packaged_task<long int(int, int)>*] (null)
;; enabled by -tree-original


{
  typedef struct _ValueType1 _ValueType1;
  typedef struct _ValueType2 _ValueType2;
  typedef struct packaged_task & _RefType1;
  typedef struct packaged_task & _RefType2;
  const bool __assignable = 1;

  <<cleanup_point   const bool __assignable = 1;>>;
  <<cleanup_point return <retval> = std::__uninitialized_copy<false>::__uninit_copy<std::move_iterator<std::packaged_task<long int(int, int)>*>, std::packaged_task<long int(int, int)>*> (TARGET_EXPR <D.114424, __first>, TARGET_EXPR <D.114425, __last>, __result)>>;
}


;; Function static std::allocator_traits<std::allocator<_CharT> >::size_type std::allocator_traits<std::allocator<_CharT> >::max_size(const allocator_type&) [with _Tp = std::future<long int>; std::allocator_traits<std::allocator<_CharT> >::size_type = long unsigned int; std::allocator_traits<std::allocator<_CharT> >::allocator_type = std::allocator<std::future<long int> >] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = __gnu_cxx::new_allocator<std::future<long int> >::max_size ((const struct new_allocator *) (const struct allocator_type *) __a)>>
   >>>;


;; Function const _Tp_alloc_type& std::_Vector_base<_Tp, _Alloc>::_M_get_Tp_allocator() const [with _Tp = std::future<long int>; _Alloc = std::allocator<std::future<long int> >; std::_Vector_base<_Tp, _Alloc>::_Tp_alloc_type = std::allocator<std::future<long int> >] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (const struct _Tp_alloc_type &) (const struct _Tp_alloc_type *) (const struct allocator *) &((const struct _Vector_base *) this)->_M_impl
   >>>;


;; Function _Tp* __gnu_cxx::new_allocator<_Tp>::allocate(__gnu_cxx::new_allocator<_Tp>::size_type, const void*) [with _Tp = std::future<long int>; __gnu_cxx::new_allocator<_Tp>::pointer = std::future<long int>*; __gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int] (null)
;; enabled by -tree-original


if (<<cleanup_point __gnu_cxx::new_allocator<std::future<long int> >::max_size (this) < __n>>)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_bad_alloc () >>>>>;
  }
<<cleanup_point return <retval> = (struct future *) operator new (16 * __n)>>;


;; Function std::move_iterator<_Iterator>::move_iterator(std::move_iterator<_Iterator>::iterator_type) [with _Iterator = std::future<long int>*; std::move_iterator<_Iterator>::iterator_type = std::future<long int>*] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct move_iterator *) this)->_M_current = __i) >>>>>;
}


;; Function _ForwardIterator std::uninitialized_copy(_InputIterator, _InputIterator, _ForwardIterator) [with _InputIterator = std::move_iterator<std::future<long int>*>; _ForwardIterator = std::future<long int>*] (null)
;; enabled by -tree-original


{
  typedef struct _ValueType1 _ValueType1;
  typedef struct _ValueType2 _ValueType2;
  typedef struct future & _RefType1;
  typedef struct future & _RefType2;
  const bool __assignable = 1;

  <<cleanup_point   const bool __assignable = 1;>>;
  <<cleanup_point return <retval> = std::__uninitialized_copy<false>::__uninit_copy<std::move_iterator<std::future<long int>*>, std::future<long int>*> (TARGET_EXPR <D.114484, __first>, TARGET_EXPR <D.114485, __last>, __result)>>;
}


;; Function void std::__shared_ptr<_Tp, _Lp>::swap(std::__shared_ptr<_Tp, _Lp>&) [with _Tp = std::__future_base::_Task_state_base<long int(int, int)>; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::swap<std::__future_base::_Task_state_base<long int(int, int)>*> ((struct _Task_state_base * &) &((struct __shared_ptr *) this)->_M_ptr, (struct _Task_state_base * &) &__other->_M_ptr) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__shared_count<>::_M_swap (&((struct __shared_ptr *) this)->_M_refcount, (struct __shared_count &) &__other->_M_refcount) >>>>>;
   >>>;


;; Function __gnu_cxx::new_allocator<_Tp>::new_allocator() [with _Tp = std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    
  }
   >>>;


;; Function __gnu_cxx::new_allocator<_Tp>::~new_allocator() [with _Tp = std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    
  }
  <D.114756>:;
   >>>;


;; Function std::shared_ptr<_Tp>::shared_ptr(std::_Sp_make_shared_tag, const _Alloc&, _Args&& ...) [with _Alloc = std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >; _Args = {std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)>}; _Tp = std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__shared_ptr<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >, (__gnu_cxx::_Lock_policy)2u>::__shared_ptr<std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >, std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > (&((struct shared_ptr *) this)->D.103679, TARGET_EXPR <D.114778, __tag>;, <<< Unknown tree: empty_class_expr >>>;, (const struct allocator &) (const struct allocator *) __a, (struct _Bind_simple &) (struct _Bind_simple *) std::forward<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > ((struct type &) (struct _Bind_simple *) __args#0)) >>>>>;
  try
    {
      
    }
  catch
    {
      std::__shared_ptr<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >, (__gnu_cxx::_Lock_policy)2u>::~__shared_ptr (&((struct shared_ptr *) this)->D.103679);
    }
}


;; Function std::vector<_Tp, _Alloc>::size_type std::vector<_Tp, _Alloc>::max_size() const [with _Tp = std::thread*; _Alloc = std::allocator<std::thread*>; std::vector<_Tp, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::allocator_traits<std::allocator<std::thread*> >::max_size ((const struct allocator_type &) (const struct _Tp_alloc_type *) std::_Vector_base<std::thread*, std::allocator<std::thread*> >::_M_get_Tp_allocator (&((const struct vector *) this)->D.80632))>>
   >>>;


;; Function static _Tp* std::allocator_traits<std::allocator<_CharT> >::allocate(std::allocator_traits<std::allocator<_CharT> >::allocator_type&, std::allocator_traits<std::allocator<_CharT> >::size_type) [with _Tp = std::thread*; std::allocator_traits<std::allocator<_CharT> >::pointer = std::thread**; std::allocator_traits<std::allocator<_CharT> >::allocator_type = std::allocator<std::thread*>; std::allocator_traits<std::allocator<_CharT> >::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (struct thread * *) __gnu_cxx::new_allocator<std::thread*>::allocate ((struct new_allocator *) (struct allocator_type *) __a, __n, 0B)>>;


;; Function _ReturnType std::__make_move_if_noexcept_iterator(_Iterator) [with _Iterator = std::thread**; _ReturnType = std::move_iterator<std::thread**>] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = TARGET_EXPR <D.114785, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.114785
  (struct move_iterator *) <<< Unknown tree: void_cst >>>
  __i >>>>;, D.114785>>;


;; Function _ForwardIterator std::__uninitialized_copy_a(_InputIterator, _InputIterator, _ForwardIterator, std::allocator<_Tp>&) [with _InputIterator = std::move_iterator<std::thread**>; _ForwardIterator = std::thread**; _Tp = std::thread*] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = std::uninitialized_copy<std::move_iterator<std::thread**>, std::thread**> (TARGET_EXPR <D.114791, __first>, TARGET_EXPR <D.114792, __last>, __result)>>;


;; Function void __gnu_cxx::new_allocator<_Tp>::destroy(_Up*) [with _Up = std::thread*; _Tp = std::thread*] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) *__p >>>>>;


;; Function bool __gnu_cxx::__is_null_pointer(_Type*) [with _Type = char] (null)
;; enabled by -tree-original


return <retval> = __ptr == 0B;


;; Function typename std::iterator_traits<_Iterator>::difference_type std::distance(_InputIterator, _InputIterator) [with _InputIterator = char*; typename std::iterator_traits<_Iterator>::difference_type = long int] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = std::__distance<char*> (__first, __last, TARGET_EXPR <D.114798, std::__iterator_category<char*> ((char * const &) (char * const *) &__first)>;, <<< Unknown tree: empty_class_expr >>>;)>>;


;; Function static void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_S_copy_chars(_CharT*, _CharT*, _CharT*) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_S_copy (__p, (const char *) __k1, (size_type) ((long int) __k2 - (long int) __k1)) >>>>>
   >>>;


;; Function _Tp* std::__addressof(_Tp&) [with _Tp = const char] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (const char *) __r
   >>>;


;; Function bool __gnu_cxx::__is_null_pointer(_Type*) [with _Type = wchar_t] (null)
;; enabled by -tree-original


return <retval> = __ptr == 0B;


;; Function typename std::iterator_traits<_Iterator>::difference_type std::distance(_InputIterator, _InputIterator) [with _InputIterator = wchar_t*; typename std::iterator_traits<_Iterator>::difference_type = long int] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = std::__distance<wchar_t*> (__first, __last, TARGET_EXPR <D.114813, std::__iterator_category<wchar_t*> ((wchar_t * const &) (wchar_t * const *) &__first)>;, <<< Unknown tree: empty_class_expr >>>;)>>;


;; Function static void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_S_copy_chars(_CharT*, _CharT*, _CharT*) [with _CharT = wchar_t; _Traits = std::char_traits<wchar_t>; _Alloc = std::allocator<wchar_t>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<wchar_t>::_S_copy (__p, (const wchar_t *) __k1, (size_type) (((long int) __k2 - (long int) __k1) /[ex] 4)) >>>>>
   >>>;


;; Function _Tp* std::__addressof(_Tp&) [with _Tp = const wchar_t] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (const wchar_t *) __r
   >>>;


;; Function typename std::iterator_traits<_Iterator>::iterator_category std::__iterator_category(const _Iter&) [with _Iter = const char*; typename std::iterator_traits<_Iterator>::iterator_category = std::random_access_iterator_tag] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = TARGET_EXPR <D.114825, {}>>>;


;; Function typename std::iterator_traits<_Iterator>::difference_type std::__distance(_RandomAccessIterator, _RandomAccessIterator, std::random_access_iterator_tag) [with _RandomAccessIterator = const char*; typename std::iterator_traits<_Iterator>::difference_type = long int] (null)
;; enabled by -tree-original


return <retval> = (long int) __last - (long int) __first;


;; Function static void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_S_copy(_CharT*, const _CharT*, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


if (__n == 1)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::char_traits<char>::assign ((char_type &) NON_LVALUE_EXPR <__d>, (const char_type &) NON_LVALUE_EXPR <__s>) >>>>>;
  }
else
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::char_traits<char>::copy (__d, __s, __n) >>>>>;
  }


;; Function typename std::iterator_traits<_Iterator>::iterator_category std::__iterator_category(const _Iter&) [with _Iter = const wchar_t*; typename std::iterator_traits<_Iterator>::iterator_category = std::random_access_iterator_tag] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = TARGET_EXPR <D.114829, {}>>>;


;; Function typename std::iterator_traits<_Iterator>::difference_type std::__distance(_RandomAccessIterator, _RandomAccessIterator, std::random_access_iterator_tag) [with _RandomAccessIterator = const wchar_t*; typename std::iterator_traits<_Iterator>::difference_type = long int] (null)
;; enabled by -tree-original


return <retval> = ((long int) __last - (long int) __first) /[ex] 4;


;; Function static void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_S_copy(_CharT*, const _CharT*, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type) [with _CharT = wchar_t; _Traits = std::char_traits<wchar_t>; _Alloc = std::allocator<wchar_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


if (__n == 1)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::char_traits<wchar_t>::assign ((char_type &) NON_LVALUE_EXPR <__d>, (const char_type &) NON_LVALUE_EXPR <__s>) >>>>>;
  }
else
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::char_traits<wchar_t>::copy (__d, __s, __n) >>>>>;
  }


;; Function typename std::iterator_traits<_Iterator>::iterator_category std::__iterator_category(const _Iter&) [with _Iter = const char16_t*; typename std::iterator_traits<_Iterator>::iterator_category = std::random_access_iterator_tag] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = TARGET_EXPR <D.114833, {}>>>;


;; Function typename std::iterator_traits<_Iterator>::difference_type std::__distance(_RandomAccessIterator, _RandomAccessIterator, std::random_access_iterator_tag) [with _RandomAccessIterator = const char16_t*; typename std::iterator_traits<_Iterator>::difference_type = long int] (null)
;; enabled by -tree-original


return <retval> = ((long int) __last - (long int) __first) /[ex] 2;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::max_size() const [with _CharT = char16_t; _Traits = std::char_traits<char16_t>; _Alloc = std::allocator<char16_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (std::allocator_traits<std::allocator<char16_t> >::max_size ((const struct allocator_type &) (const struct allocator_type *) std::__cxx11::basic_string<char16_t>::_M_get_allocator (this)) + 18446744073709551615) / 2>>
   >>>;


;; Function static _Tp* std::allocator_traits<std::allocator<_CharT> >::allocate(std::allocator_traits<std::allocator<_CharT> >::allocator_type&, std::allocator_traits<std::allocator<_CharT> >::size_type) [with _Tp = char16_t; std::allocator_traits<std::allocator<_CharT> >::pointer = char16_t*; std::allocator_traits<std::allocator<_CharT> >::allocator_type = std::allocator<char16_t>; std::allocator_traits<std::allocator<_CharT> >::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (char16_t *) __gnu_cxx::new_allocator<char16_t>::allocate ((struct new_allocator *) (struct allocator_type *) __a, __n, 0B)>>;


;; Function static void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_S_copy(_CharT*, const _CharT*, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type) [with _CharT = char16_t; _Traits = std::char_traits<char16_t>; _Alloc = std::allocator<char16_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


if (__n == 1)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::char_traits<char16_t>::assign ((char_type &) NON_LVALUE_EXPR <__d>, (const char_type &) NON_LVALUE_EXPR <__s>) >>>>>;
  }
else
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::char_traits<char16_t>::copy (__d, __s, __n) >>>>>;
  }


;; Function _Tp* std::__addressof(_Tp&) [with _Tp = const char16_t] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (const char16_t *) __r
   >>>;


;; Function typename std::iterator_traits<_Iterator>::iterator_category std::__iterator_category(const _Iter&) [with _Iter = const char32_t*; typename std::iterator_traits<_Iterator>::iterator_category = std::random_access_iterator_tag] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = TARGET_EXPR <D.114840, {}>>>;


;; Function typename std::iterator_traits<_Iterator>::difference_type std::__distance(_RandomAccessIterator, _RandomAccessIterator, std::random_access_iterator_tag) [with _RandomAccessIterator = const char32_t*; typename std::iterator_traits<_Iterator>::difference_type = long int] (null)
;; enabled by -tree-original


return <retval> = ((long int) __last - (long int) __first) /[ex] 4;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::max_size() const [with _CharT = char32_t; _Traits = std::char_traits<char32_t>; _Alloc = std::allocator<char32_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (std::allocator_traits<std::allocator<char32_t> >::max_size ((const struct allocator_type &) (const struct allocator_type *) std::__cxx11::basic_string<char32_t>::_M_get_allocator (this)) + 18446744073709551615) / 2>>
   >>>;


;; Function static _Tp* std::allocator_traits<std::allocator<_CharT> >::allocate(std::allocator_traits<std::allocator<_CharT> >::allocator_type&, std::allocator_traits<std::allocator<_CharT> >::size_type) [with _Tp = char32_t; std::allocator_traits<std::allocator<_CharT> >::pointer = char32_t*; std::allocator_traits<std::allocator<_CharT> >::allocator_type = std::allocator<char32_t>; std::allocator_traits<std::allocator<_CharT> >::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (char32_t *) __gnu_cxx::new_allocator<char32_t>::allocate ((struct new_allocator *) (struct allocator_type *) __a, __n, 0B)>>;


;; Function static void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_S_copy(_CharT*, const _CharT*, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type) [with _CharT = char32_t; _Traits = std::char_traits<char32_t>; _Alloc = std::allocator<char32_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


if (__n == 1)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::char_traits<char32_t>::assign ((char_type &) NON_LVALUE_EXPR <__d>, (const char_type &) NON_LVALUE_EXPR <__s>) >>>>>;
  }
else
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::char_traits<char32_t>::copy (__d, __s, __n) >>>>>;
  }


;; Function _Tp* std::__addressof(_Tp&) [with _Tp = const char32_t] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (const char32_t *) __r
   >>>;


;; Function __gnu_cxx::new_allocator<_Tp>::size_type __gnu_cxx::new_allocator<_Tp>::max_size() const [with _Tp = char; __gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 18446744073709551615 / 1
   >>>;


;; Function std::allocator< <template-parameter-1-1> >::allocator(const std::allocator<_Tp1>&) [with _Tp1 = std::mutex; _Tp = std::_Sp_counted_ptr_inplace<std::mutex, std::allocator<std::mutex>, (__gnu_cxx::_Lock_policy)2u>] (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<std::_Sp_counted_ptr_inplace<std::mutex, std::allocator<std::mutex>, (__gnu_cxx::_Lock_policy)2u> >::new_allocator ((struct new_allocator *) this) >>>>>;
    try
      {
        
      }
    catch
      {
        __gnu_cxx::new_allocator<std::_Sp_counted_ptr_inplace<std::mutex, std::allocator<std::mutex>, (__gnu_cxx::_Lock_policy)2u> >::~new_allocator ((struct new_allocator *) this);
      }
  }
   >>>;


;; Function std::allocator< <template-parameter-1-1> >::~allocator() [with _Tp = std::_Sp_counted_ptr_inplace<std::mutex, std::allocator<std::mutex>, (__gnu_cxx::_Lock_policy)2u>] (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  {
    try
      {
        
      }
    finally
      {
        __gnu_cxx::new_allocator<std::_Sp_counted_ptr_inplace<std::mutex, std::allocator<std::mutex>, (__gnu_cxx::_Lock_policy)2u> >::~new_allocator ((struct new_allocator *) this);
      }
  }
  <D.114851>:;
   >>>;


;; Function std::__allocated_ptr<_Alloc> std::__allocate_guarded(_Alloc&) [with _Alloc = std::allocator<std::_Sp_counted_ptr_inplace<std::mutex, std::allocator<std::mutex>, (__gnu_cxx::_Lock_policy)2u> >] (null)
;; enabled by -tree-original


<<cleanup_point return *<retval> = TARGET_EXPR <D.114875, <<< Unknown tree: aggr_init_expr
  6
  __comp_ctor 
  D.114875
  (struct __allocated_ptr *) <<< Unknown tree: void_cst >>>
  (struct allocator &) (struct allocator *) __a
  std::allocator_traits<std::allocator<std::_Sp_counted_ptr_inplace<std::mutex, std::allocator<std::mutex>, (__gnu_cxx::_Lock_policy)2u> > >::allocate ((struct allocator_type &) (struct allocator *) __a, 1) >>>>>>;


;; Function std::__allocated_ptr<_Alloc>::~__allocated_ptr() [with _Alloc = std::allocator<std::_Sp_counted_ptr_inplace<std::mutex, std::allocator<std::mutex>, (__gnu_cxx::_Lock_policy)2u> >] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    try
      {
        if (((struct __allocated_ptr *) this)->_M_ptr != 0B)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator_traits<std::allocator<std::_Sp_counted_ptr_inplace<std::mutex, std::allocator<std::mutex>, (__gnu_cxx::_Lock_policy)2u> > >::deallocate ((struct allocator_type &) NON_LVALUE_EXPR <((struct __allocated_ptr *) this)->_M_alloc>, ((struct __allocated_ptr *) this)->_M_ptr, 1) >>>>>;
          }
      }
    finally
      {
        *(struct 
        {
          struct allocator * _M_alloc;
          struct _Sp_counted_ptr_inplace * _M_ptr;
        } &) this = {CLOBBER};
      }
  }
  <D.114877>:;
   >>>;


;; Function std::__allocated_ptr<_Alloc>::__allocated_ptr(std::__allocated_ptr<_Alloc>&&) [with _Alloc = std::allocator<std::_Sp_counted_ptr_inplace<std::mutex, std::allocator<std::mutex>, (__gnu_cxx::_Lock_policy)2u> >] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __allocated_ptr *) this)->_M_alloc = __gd->_M_alloc) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __allocated_ptr *) this)->_M_ptr = __gd->_M_ptr) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__gd->_M_ptr = 0B) >>>>>;
  }
   >>>;


;; Function std::__allocated_ptr<_Alloc>::value_type* std::__allocated_ptr<_Alloc>::get() [with _Alloc = std::allocator<std::_Sp_counted_ptr_inplace<std::mutex, std::allocator<std::mutex>, (__gnu_cxx::_Lock_policy)2u> >; std::__allocated_ptr<_Alloc>::value_type = std::_Sp_counted_ptr_inplace<std::mutex, std::allocator<std::mutex>, (__gnu_cxx::_Lock_policy)2u>] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = std::__allocated_ptr<std::allocator<std::_Sp_counted_ptr_inplace<std::mutex, std::allocator<std::mutex>, (__gnu_cxx::_Lock_policy)2u> > >::_S_raw_ptr (this, ((struct __allocated_ptr *) this)->_M_ptr)>>;


;; Function std::allocator< <template-parameter-1-1> >::allocator(const std::allocator< <template-parameter-1-1> >&) [with _Tp = std::mutex] (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<std::mutex>::new_allocator ((struct new_allocator *) this, (const struct new_allocator &) (const struct new_allocator *) (const struct allocator *) __a) >>>>>;
    try
      {
        
      }
    catch
      {
        __gnu_cxx::new_allocator<std::mutex>::~new_allocator ((struct new_allocator *) this);
      }
  }
   >>>;


;; Function std::_Sp_ebo_helper<0, std::allocator<std::mutex>, true>::~_Sp_ebo_helper() (null)
;; enabled by -tree-original


{
  try
    {
      
    }
  finally
    {
      std::allocator<std::mutex>::~allocator ((struct allocator *) this);
    }
}
<D.114906>:;


;; Function std::_Sp_counted_ptr_inplace<std::mutex, std::allocator<std::mutex>, (__gnu_cxx::_Lock_policy)2u>::_Impl::~_Impl() (null)
;; enabled by -tree-original


{
  try
    {
      try
        {
          
        }
      finally
        {
          std::_Sp_ebo_helper<0, std::allocator<std::mutex>, true>::~_Sp_ebo_helper ((struct _Sp_ebo_helper *) this);
        }
    }
  finally
    {
      *(struct 
      {
        struct __aligned_buffer _M_storage;
      } &) this = {CLOBBER};
    }
}
<D.114904>:;


;; Function std::_Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp>::_Sp_counted_ptr_inplace(_Alloc, _Args&& ...) [with _Args = {}; _Tp = std::mutex; _Alloc = std::allocator<std::mutex>; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2u>::_Sp_counted_base (&((struct _Sp_counted_ptr_inplace *) this)->D.112990) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Sp_counted_ptr_inplace *) this)->D.112990._vptr._Sp_counted_base = &_ZTVSt23_Sp_counted_ptr_inplaceISt5mutexSaIS0_ELN9__gnu_cxx12_Lock_policyE2EE + 16) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Sp_counted_ptr_inplace<std::mutex, std::allocator<std::mutex>, (__gnu_cxx::_Lock_policy)2u>::_Impl::_Impl (&((struct _Sp_counted_ptr_inplace *) this)->_M_impl, &TARGET_EXPR <D.114902, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.114902
  (struct allocator *) <<< Unknown tree: void_cst >>>
  (const struct allocator &) (const struct allocator *) (struct allocator *) __a >>>>) >>>>>;
      try
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator_traits<std::allocator<std::mutex> >::construct<std::mutex> ((struct allocator_type &) (struct allocator *) __a, std::_Sp_counted_ptr_inplace<std::mutex, std::allocator<std::mutex>, (__gnu_cxx::_Lock_policy)2u>::_M_ptr (this)) >>>>>;
        }
      catch
        {
          std::_Sp_counted_ptr_inplace<std::mutex, std::allocator<std::mutex>, (__gnu_cxx::_Lock_policy)2u>::_Impl::~_Impl (&((struct _Sp_counted_ptr_inplace *) this)->_M_impl);
        }
    }
  catch
    {
      std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2u>::~_Sp_counted_base (&((struct _Sp_counted_ptr_inplace *) this)->D.112990);
    }
}


;; Function std::__allocated_ptr<_Alloc>& std::__allocated_ptr<_Alloc>::operator=(std::nullptr_t) [with _Alloc = std::allocator<std::_Sp_counted_ptr_inplace<std::mutex, std::allocator<std::mutex>, (__gnu_cxx::_Lock_policy)2u> >; std::nullptr_t = std::nullptr_t] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __allocated_ptr *) this)->_M_ptr = 0B) >>>>>;
  return <retval> = (struct __allocated_ptr &) (struct __allocated_ptr *) this;
   >>>;


;; Function constexpr typename std::remove_reference< <template-parameter-1-1> >::type&& std::move(_Tp&&) [with _Tp = std::__future_base::_Result_base::_Deleter&; typename std::remove_reference< <template-parameter-1-1> >::type = std::__future_base::_Result_base::_Deleter] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct type &) (struct type *) NON_LVALUE_EXPR <(struct type &) __t>
   >>>;


;; Function void std::swap(_Tp&, _Tp&) [with _Tp = std::__future_base::_Result_base::_Deleter] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    struct _Deleter __tmp;

        struct _Deleter __tmp;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__tmp = *(struct _Deleter &) (struct type *) std::move<std::__future_base::_Result_base::_Deleter&> ((struct _Deleter &) (struct _Deleter *) __a)) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  *(struct _Deleter *) __a;, (struct _Deleter &) (struct type *) std::move<std::__future_base::_Result_base::_Deleter&> ((struct _Deleter &) (struct _Deleter *) __b);;, <<< Unknown tree: void_cst >>> >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  *(struct _Deleter *) __b;, (struct _Deleter &) (struct type *) std::move<std::__future_base::_Result_base::_Deleter&> ((struct _Deleter &) &__tmp);;, <<< Unknown tree: void_cst >>> >>>>>;
  }
   >>>;


;; Function std::allocator< <template-parameter-1-1> >::allocator(const std::allocator<_Tp1>&) [with _Tp1 = std::__future_base::_State_baseV2; _Tp = std::_Sp_counted_ptr_inplace<std::__future_base::_State_baseV2, std::allocator<std::__future_base::_State_baseV2>, (__gnu_cxx::_Lock_policy)2u>] (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<std::_Sp_counted_ptr_inplace<std::__future_base::_State_baseV2, std::allocator<std::__future_base::_State_baseV2>, (__gnu_cxx::_Lock_policy)2u> >::new_allocator ((struct new_allocator *) this) >>>>>;
    try
      {
        
      }
    catch
      {
        __gnu_cxx::new_allocator<std::_Sp_counted_ptr_inplace<std::__future_base::_State_baseV2, std::allocator<std::__future_base::_State_baseV2>, (__gnu_cxx::_Lock_policy)2u> >::~new_allocator ((struct new_allocator *) this);
      }
  }
   >>>;


;; Function std::allocator< <template-parameter-1-1> >::~allocator() [with _Tp = std::_Sp_counted_ptr_inplace<std::__future_base::_State_baseV2, std::allocator<std::__future_base::_State_baseV2>, (__gnu_cxx::_Lock_policy)2u>] (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  {
    try
      {
        
      }
    finally
      {
        __gnu_cxx::new_allocator<std::_Sp_counted_ptr_inplace<std::__future_base::_State_baseV2, std::allocator<std::__future_base::_State_baseV2>, (__gnu_cxx::_Lock_policy)2u> >::~new_allocator ((struct new_allocator *) this);
      }
  }
  <D.115003>:;
   >>>;


;; Function std::__allocated_ptr<_Alloc> std::__allocate_guarded(_Alloc&) [with _Alloc = std::allocator<std::_Sp_counted_ptr_inplace<std::__future_base::_State_baseV2, std::allocator<std::__future_base::_State_baseV2>, (__gnu_cxx::_Lock_policy)2u> >] (null)
;; enabled by -tree-original


<<cleanup_point return *<retval> = TARGET_EXPR <D.115027, <<< Unknown tree: aggr_init_expr
  6
  __comp_ctor 
  D.115027
  (struct __allocated_ptr *) <<< Unknown tree: void_cst >>>
  (struct allocator &) (struct allocator *) __a
  std::allocator_traits<std::allocator<std::_Sp_counted_ptr_inplace<std::__future_base::_State_baseV2, std::allocator<std::__future_base::_State_baseV2>, (__gnu_cxx::_Lock_policy)2u> > >::allocate ((struct allocator_type &) (struct allocator *) __a, 1) >>>>>>;


;; Function std::__allocated_ptr<_Alloc>::~__allocated_ptr() [with _Alloc = std::allocator<std::_Sp_counted_ptr_inplace<std::__future_base::_State_baseV2, std::allocator<std::__future_base::_State_baseV2>, (__gnu_cxx::_Lock_policy)2u> >] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    try
      {
        if (((struct __allocated_ptr *) this)->_M_ptr != 0B)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator_traits<std::allocator<std::_Sp_counted_ptr_inplace<std::__future_base::_State_baseV2, std::allocator<std::__future_base::_State_baseV2>, (__gnu_cxx::_Lock_policy)2u> > >::deallocate ((struct allocator_type &) NON_LVALUE_EXPR <((struct __allocated_ptr *) this)->_M_alloc>, ((struct __allocated_ptr *) this)->_M_ptr, 1) >>>>>;
          }
      }
    finally
      {
        *(struct 
        {
          struct allocator * _M_alloc;
          struct _Sp_counted_ptr_inplace * _M_ptr;
        } &) this = {CLOBBER};
      }
  }
  <D.115029>:;
   >>>;


;; Function std::__allocated_ptr<_Alloc>::__allocated_ptr(std::__allocated_ptr<_Alloc>&&) [with _Alloc = std::allocator<std::_Sp_counted_ptr_inplace<std::__future_base::_State_baseV2, std::allocator<std::__future_base::_State_baseV2>, (__gnu_cxx::_Lock_policy)2u> >] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __allocated_ptr *) this)->_M_alloc = __gd->_M_alloc) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __allocated_ptr *) this)->_M_ptr = __gd->_M_ptr) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__gd->_M_ptr = 0B) >>>>>;
  }
   >>>;


;; Function std::__allocated_ptr<_Alloc>::value_type* std::__allocated_ptr<_Alloc>::get() [with _Alloc = std::allocator<std::_Sp_counted_ptr_inplace<std::__future_base::_State_baseV2, std::allocator<std::__future_base::_State_baseV2>, (__gnu_cxx::_Lock_policy)2u> >; std::__allocated_ptr<_Alloc>::value_type = std::_Sp_counted_ptr_inplace<std::__future_base::_State_baseV2, std::allocator<std::__future_base::_State_baseV2>, (__gnu_cxx::_Lock_policy)2u>] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = std::__allocated_ptr<std::allocator<std::_Sp_counted_ptr_inplace<std::__future_base::_State_baseV2, std::allocator<std::__future_base::_State_baseV2>, (__gnu_cxx::_Lock_policy)2u> > >::_S_raw_ptr (this, ((struct __allocated_ptr *) this)->_M_ptr)>>;


;; Function std::allocator< <template-parameter-1-1> >::allocator(const std::allocator< <template-parameter-1-1> >&) [with _Tp = std::__future_base::_State_baseV2] (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<std::__future_base::_State_baseV2>::new_allocator ((struct new_allocator *) this, (const struct new_allocator &) (const struct new_allocator *) (const struct allocator *) __a) >>>>>;
    try
      {
        
      }
    catch
      {
        __gnu_cxx::new_allocator<std::__future_base::_State_baseV2>::~new_allocator ((struct new_allocator *) this);
      }
  }
   >>>;


;; Function std::_Sp_ebo_helper<0, std::allocator<std::__future_base::_State_baseV2>, true>::~_Sp_ebo_helper() (null)
;; enabled by -tree-original


{
  try
    {
      
    }
  finally
    {
      std::allocator<std::__future_base::_State_baseV2>::~allocator ((struct allocator *) this);
    }
}
<D.115058>:;


;; Function std::_Sp_counted_ptr_inplace<std::__future_base::_State_baseV2, std::allocator<std::__future_base::_State_baseV2>, (__gnu_cxx::_Lock_policy)2u>::_Impl::~_Impl() (null)
;; enabled by -tree-original


{
  try
    {
      try
        {
          
        }
      finally
        {
          std::_Sp_ebo_helper<0, std::allocator<std::__future_base::_State_baseV2>, true>::~_Sp_ebo_helper ((struct _Sp_ebo_helper *) this);
        }
    }
  finally
    {
      *(struct 
      {
        struct __aligned_buffer _M_storage;
      } &) this = {CLOBBER};
    }
}
<D.115056>:;


;; Function std::_Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp>::_Sp_counted_ptr_inplace(_Alloc, _Args&& ...) [with _Args = {}; _Tp = std::__future_base::_State_baseV2; _Alloc = std::allocator<std::__future_base::_State_baseV2>; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2u>::_Sp_counted_base (&((struct _Sp_counted_ptr_inplace *) this)->D.113767) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Sp_counted_ptr_inplace *) this)->D.113767._vptr._Sp_counted_base = &_ZTVSt23_Sp_counted_ptr_inplaceINSt13__future_base13_State_baseV2ESaIS1_ELN9__gnu_cxx12_Lock_policyE2EE + 16) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Sp_counted_ptr_inplace<std::__future_base::_State_baseV2, std::allocator<std::__future_base::_State_baseV2>, (__gnu_cxx::_Lock_policy)2u>::_Impl::_Impl (&((struct _Sp_counted_ptr_inplace *) this)->_M_impl, &TARGET_EXPR <D.115054, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.115054
  (struct allocator *) <<< Unknown tree: void_cst >>>
  (const struct allocator &) (const struct allocator *) (struct allocator *) __a >>>>) >>>>>;
      try
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator_traits<std::allocator<std::__future_base::_State_baseV2> >::construct<std::__future_base::_State_baseV2> ((struct allocator_type &) (struct allocator *) __a, std::_Sp_counted_ptr_inplace<std::__future_base::_State_baseV2, std::allocator<std::__future_base::_State_baseV2>, (__gnu_cxx::_Lock_policy)2u>::_M_ptr (this)) >>>>>;
        }
      catch
        {
          std::_Sp_counted_ptr_inplace<std::__future_base::_State_baseV2, std::allocator<std::__future_base::_State_baseV2>, (__gnu_cxx::_Lock_policy)2u>::_Impl::~_Impl (&((struct _Sp_counted_ptr_inplace *) this)->_M_impl);
        }
    }
  catch
    {
      std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2u>::~_Sp_counted_base (&((struct _Sp_counted_ptr_inplace *) this)->D.113767);
    }
}


;; Function std::__allocated_ptr<_Alloc>& std::__allocated_ptr<_Alloc>::operator=(std::nullptr_t) [with _Alloc = std::allocator<std::_Sp_counted_ptr_inplace<std::__future_base::_State_baseV2, std::allocator<std::__future_base::_State_baseV2>, (__gnu_cxx::_Lock_policy)2u> >; std::nullptr_t = std::nullptr_t] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __allocated_ptr *) this)->_M_ptr = 0B) >>>>>;
  return <retval> = (struct __allocated_ptr &) (struct __allocated_ptr *) this;
   >>>;


;; Function _Tp& std::reference_wrapper<_Tp>::get() const [with _Tp = std::thread] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct thread &) (struct thread *) ((const struct reference_wrapper *) this)->_M_data
   >>>;


;; Function std::_Mem_fn_base<_MemFunPtr, __is_mem_fn>::result_type std::_Mem_fn_base<_MemFunPtr, __is_mem_fn>::operator()(std::_Mem_fn_base<_MemFunPtr, __is_mem_fn>::_Class&, _Args&& ...) const [with _Args = {}; _Req = void; _MemFunPtr = void (std::thread::*)(); bool __is_mem_fn = true; std::_Mem_fn_base<_MemFunPtr, __is_mem_fn>::result_type = void; std::_Mem_fn_base<_MemFunPtr, __is_mem_fn>::_Class = std::thread] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (((long int) ((const struct _Mem_fn_base *) this)->_M_pmf.__pfn & 1) == 0) ? (void thread::<Ta344> (struct thread *) *) ((const struct _Mem_fn_base *) this)->_M_pmf.__pfn : (void thread::<Ta344> (struct thread *) *) (void thread::<Ta344> (struct thread *) * const) *(*(int (*__vtbl_ptr_type) () * *) ((struct _Class *) __object + (sizetype) ((const struct _Mem_fn_base *) this)->_M_pmf.__delta) + (sizetype) ((long int) ((const struct _Mem_fn_base *) this)->_M_pmf.__pfn + -1)) ((struct _Class *) __object + (sizetype) ((const struct _Mem_fn_base *) this)->_M_pmf.__delta) >>>>>;
return;


;; Function std::__shared_ptr<_Tp, _Lp>::__shared_ptr(std::_Sp_make_shared_tag, const _Alloc&, _Args&& ...) [with _Alloc = std::allocator<int>; _Args = {long int (&)(int, int), const std::allocator<int>&}; _Tp = std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __shared_ptr *) this)->_M_ptr = 0B) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__shared_count<>::__shared_count<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, std::allocator<int>, long int (&)(int, int), const std::allocator<int>&> (&((struct __shared_ptr *) this)->_M_refcount, TARGET_EXPR <D.115165, __tag>;, <<< Unknown tree: empty_class_expr >>>;, 0B, (const struct allocator &) (const struct allocator *) __a, (long int (&<T105d3>) (int, int)) (long int (*<T105d2>) (int, int)) std::forward<long int (&)(int, int)> ((long int (&<T15f36>) (int, int)) (long int (*<T105d2>) (int, int)) __args#0), (const struct allocator &) (const struct allocator *) std::forward<const std::allocator<int>&> ((const struct type &) (const struct allocator *) __args#1)) >>>>>;
  try
    {
      {
        void * __p;

                void * __p;
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__p = std::__shared_count<>::_M_get_deleter (&((struct __shared_ptr *) this)->_M_refcount, (const struct type_info &) (const struct type_info *) &_ZTISt19_Sp_make_shared_tag)) >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __shared_ptr *) this)->_M_ptr = (struct _Task_state *) __p) >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  std::__enable_shared_from_this_helper<(__gnu_cxx::_Lock_policy)2u> ((const struct __shared_count &) (const struct __shared_count *) &((struct __shared_ptr *) this)->_M_refcount, ((struct __shared_ptr *) this)->_M_ptr, ((struct __shared_ptr *) this)->_M_ptr) >>>>>;
      }
    }
  catch
    {
      std::__shared_count<>::~__shared_count (&((struct __shared_ptr *) this)->_M_refcount);
    }
}


;; Function std::__shared_ptr<_Tp, _Lp>::__shared_ptr(std::__shared_ptr<_Tp, _Lp>&&) [with _Tp = std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __shared_ptr *) this)->_M_ptr = __r->_M_ptr) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __shared_ptr *) this)->_M_refcount = <<< Unknown tree: aggr_init_expr
  4
  __comp_ctor 
  D.115172
  (struct __shared_count *) <<< Unknown tree: void_cst >>> >>>) >>>>>;
    try
      {
        <<cleanup_point <<< Unknown tree: expr_stmt
  std::__shared_count<>::_M_swap (&((struct __shared_ptr *) this)->_M_refcount, (struct __shared_count &) &__r->_M_refcount) >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__r->_M_ptr = 0B) >>>>>;
      }
    catch
      {
        std::__shared_count<>::~__shared_count (&((struct __shared_ptr *) this)->_M_refcount);
      }
  }
   >>>;


;; Function __gnu_cxx::new_allocator<_Tp>::size_type __gnu_cxx::new_allocator<_Tp>::max_size() const [with _Tp = std::packaged_task<long int(int, int)>; __gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 18446744073709551615 / 16
   >>>;


;; Function static _ForwardIterator std::__uninitialized_copy<_TrivialValueTypes>::__uninit_copy(_InputIterator, _InputIterator, _ForwardIterator) [with _InputIterator = std::move_iterator<std::packaged_task<long int(int, int)>*>; _ForwardIterator = std::packaged_task<long int(int, int)>*; bool _TrivialValueTypes = false] (null)
;; enabled by -tree-original


{
  struct packaged_task * __cur = __result;

    struct packaged_task * __cur = __result;
  <<< Unknown tree: try_block
  while (1)
    {
      if (<<cleanup_point std::operator!=<std::packaged_task<long int(int, int)>*> ((const struct move_iterator &) (const struct move_iterator *) &__first, (const struct move_iterator &) (const struct move_iterator *) &__last)>>) (void) 0; else goto <D.115192>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Construct<std::packaged_task<long int(int, int)>, std::packaged_task<long int(int, int)> > (std::__addressof<std::packaged_task<long int(int, int)> > ((struct packaged_task &) NON_LVALUE_EXPR <__cur>), (struct packaged_task &) (struct packaged_task *) std::move_iterator<std::packaged_task<long int(int, int)>*>::operator* (&__first)) >>>>>;
      <<cleanup_point (void) std::move_iterator<std::packaged_task<long int(int, int)>*>::operator++ (&__first);, (void)  ++__cur;>>;
    }
  <D.115192>:;
  return <retval> = __cur;
  <<< Unknown tree: handler
  
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) __cxa_begin_catch (__builtin_eh_pointer (0)) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Destroy<std::packaged_task<long int(int, int)>*> (__result, __cur) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  <<< Unknown tree: throw_expr
  __cxa_rethrow () >>> >>>>>;
    }
  finally
    {
      __cxa_end_catch ();
    } >>> >>>;
}


;; Function __gnu_cxx::new_allocator<_Tp>::size_type __gnu_cxx::new_allocator<_Tp>::max_size() const [with _Tp = std::future<long int>; __gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 18446744073709551615 / 16
   >>>;


;; Function static _ForwardIterator std::__uninitialized_copy<_TrivialValueTypes>::__uninit_copy(_InputIterator, _InputIterator, _ForwardIterator) [with _InputIterator = std::move_iterator<std::future<long int>*>; _ForwardIterator = std::future<long int>*; bool _TrivialValueTypes = false] (null)
;; enabled by -tree-original


{
  struct future * __cur = __result;

    struct future * __cur = __result;
  <<< Unknown tree: try_block
  while (1)
    {
      if (<<cleanup_point std::operator!=<std::future<long int>*> ((const struct move_iterator &) (const struct move_iterator *) &__first, (const struct move_iterator &) (const struct move_iterator *) &__last)>>) (void) 0; else goto <D.115210>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Construct<std::future<long int>, std::future<long int> > (std::__addressof<std::future<long int> > ((struct future &) NON_LVALUE_EXPR <__cur>), (struct future &) (struct future *) std::move_iterator<std::future<long int>*>::operator* (&__first)) >>>>>;
      <<cleanup_point (void) std::move_iterator<std::future<long int>*>::operator++ (&__first);, (void)  ++__cur;>>;
    }
  <D.115210>:;
  return <retval> = __cur;
  <<< Unknown tree: handler
  
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) __cxa_begin_catch (__builtin_eh_pointer (0)) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Destroy<std::future<long int>*> (__result, __cur) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  <<< Unknown tree: throw_expr
  __cxa_rethrow () >>> >>>>>;
    }
  finally
    {
      __cxa_end_catch ();
    } >>> >>>;
}


;; Function constexpr typename std::remove_reference< <template-parameter-1-1> >::type&& std::move(_Tp&&) [with _Tp = std::__future_base::_Task_state_base<long int(int, int)>*&; typename std::remove_reference< <template-parameter-1-1> >::type = std::__future_base::_Task_state_base<long int(int, int)>*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct _Task_state_base * &) (struct _Task_state_base * *) (struct _Task_state_base * &) __t
   >>>;


;; Function void std::swap(_Tp&, _Tp&) [with _Tp = std::__future_base::_Task_state_base<long int(int, int)>*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    struct _Task_state_base * __tmp;

        struct _Task_state_base * __tmp;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__tmp = *std::move<std::__future_base::_Task_state_base<long int(int, int)>*&> ((struct _Task_state_base * &) (struct _Task_state_base * *) __a)) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__a = *std::move<std::__future_base::_Task_state_base<long int(int, int)>*&> ((struct _Task_state_base * &) (struct _Task_state_base * *) __b)) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__b = *std::move<std::__future_base::_Task_state_base<long int(int, int)>*&> ((struct _Task_state_base * &) &__tmp)) >>>>>;
  }
   >>>;


;; Function std::__shared_ptr<_Tp, _Lp>::__shared_ptr(std::_Sp_make_shared_tag, const _Alloc&, _Args&& ...) [with _Alloc = std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >; _Args = {std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)>}; _Tp = std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __shared_ptr *) this)->_M_ptr = 0B) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__shared_count<>::__shared_count<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >, std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >, std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > (&((struct __shared_ptr *) this)->_M_refcount, TARGET_EXPR <D.115240, __tag>;, <<< Unknown tree: empty_class_expr >>>;, 0B, (const struct allocator &) (const struct allocator *) __a, (struct _Bind_simple &) (struct _Bind_simple *) std::forward<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > ((struct type &) (struct _Bind_simple *) __args#0)) >>>>>;
  try
    {
      {
        void * __p;

                void * __p;
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__p = std::__shared_count<>::_M_get_deleter (&((struct __shared_ptr *) this)->_M_refcount, (const struct type_info &) (const struct type_info *) &_ZTISt19_Sp_make_shared_tag)) >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __shared_ptr *) this)->_M_ptr = (struct _Impl *) __p) >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  std::__enable_shared_from_this_helper<(__gnu_cxx::_Lock_policy)2u> ((const struct __shared_count &) (const struct __shared_count *) &((struct __shared_ptr *) this)->_M_refcount, ((struct __shared_ptr *) this)->_M_ptr, ((struct __shared_ptr *) this)->_M_ptr) >>>>>;
      }
    }
  catch
    {
      std::__shared_count<>::~__shared_count (&((struct __shared_ptr *) this)->_M_refcount);
    }
}


;; Function static std::allocator_traits<std::allocator<_CharT> >::size_type std::allocator_traits<std::allocator<_CharT> >::max_size(const allocator_type&) [with _Tp = std::thread*; std::allocator_traits<std::allocator<_CharT> >::size_type = long unsigned int; std::allocator_traits<std::allocator<_CharT> >::allocator_type = std::allocator<std::thread*>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = __gnu_cxx::new_allocator<std::thread*>::max_size ((const struct new_allocator *) (const struct allocator_type *) __a)>>
   >>>;


;; Function const _Tp_alloc_type& std::_Vector_base<_Tp, _Alloc>::_M_get_Tp_allocator() const [with _Tp = std::thread*; _Alloc = std::allocator<std::thread*>; std::_Vector_base<_Tp, _Alloc>::_Tp_alloc_type = std::allocator<std::thread*>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (const struct _Tp_alloc_type &) (const struct _Tp_alloc_type *) (const struct allocator *) &((const struct _Vector_base *) this)->_M_impl
   >>>;


;; Function _Tp* __gnu_cxx::new_allocator<_Tp>::allocate(__gnu_cxx::new_allocator<_Tp>::size_type, const void*) [with _Tp = std::thread*; __gnu_cxx::new_allocator<_Tp>::pointer = std::thread**; __gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int] (null)
;; enabled by -tree-original


if (<<cleanup_point __gnu_cxx::new_allocator<std::thread*>::max_size (this) < __n>>)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_bad_alloc () >>>>>;
  }
<<cleanup_point return <retval> = (struct thread * *) operator new (8 * __n)>>;


;; Function std::move_iterator<_Iterator>::move_iterator(std::move_iterator<_Iterator>::iterator_type) [with _Iterator = std::thread**; std::move_iterator<_Iterator>::iterator_type = std::thread**] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct move_iterator *) this)->_M_current = __i) >>>>>;
}


;; Function _ForwardIterator std::uninitialized_copy(_InputIterator, _InputIterator, _ForwardIterator) [with _InputIterator = std::move_iterator<std::thread**>; _ForwardIterator = std::thread**] (null)
;; enabled by -tree-original


{
  typedef struct thread * _ValueType1;
  typedef struct thread * _ValueType2;
  typedef struct thread * & _RefType1;
  typedef struct thread * & _RefType2;
  const bool __assignable = 1;

  <<cleanup_point   const bool __assignable = 1;>>;
  <<cleanup_point return <retval> = std::__uninitialized_copy<true>::__uninit_copy<std::move_iterator<std::thread**>, std::thread**> (TARGET_EXPR <D.115338, __first>, TARGET_EXPR <D.115339, __last>, __result)>>;
}


;; Function typename std::iterator_traits<_Iterator>::iterator_category std::__iterator_category(const _Iter&) [with _Iter = char*; typename std::iterator_traits<_Iterator>::iterator_category = std::random_access_iterator_tag] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = TARGET_EXPR <D.115341, {}>>>;


;; Function typename std::iterator_traits<_Iterator>::difference_type std::__distance(_RandomAccessIterator, _RandomAccessIterator, std::random_access_iterator_tag) [with _RandomAccessIterator = char*; typename std::iterator_traits<_Iterator>::difference_type = long int] (null)
;; enabled by -tree-original


return <retval> = (long int) __last - (long int) __first;


;; Function typename std::iterator_traits<_Iterator>::iterator_category std::__iterator_category(const _Iter&) [with _Iter = wchar_t*; typename std::iterator_traits<_Iterator>::iterator_category = std::random_access_iterator_tag] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = TARGET_EXPR <D.115344, {}>>>;


;; Function typename std::iterator_traits<_Iterator>::difference_type std::__distance(_RandomAccessIterator, _RandomAccessIterator, std::random_access_iterator_tag) [with _RandomAccessIterator = wchar_t*; typename std::iterator_traits<_Iterator>::difference_type = long int] (null)
;; enabled by -tree-original


return <retval> = ((long int) __last - (long int) __first) /[ex] 4;


;; Function static std::allocator_traits<std::allocator<_CharT> >::size_type std::allocator_traits<std::allocator<_CharT> >::max_size(const allocator_type&) [with _Tp = char16_t; std::allocator_traits<std::allocator<_CharT> >::size_type = long unsigned int; std::allocator_traits<std::allocator<_CharT> >::allocator_type = std::allocator<char16_t>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = __gnu_cxx::new_allocator<char16_t>::max_size ((const struct new_allocator *) (const struct allocator_type *) __a)>>
   >>>;


;; Function const allocator_type& std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_get_allocator() const [with _CharT = char16_t; _Traits = std::char_traits<char16_t>; _Alloc = std::allocator<char16_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::allocator_type = std::allocator<char16_t>] (null)
;; enabled by -tree-original


return <retval> = (const struct allocator_type &) (const struct allocator *) &((const struct basic_string *) this)->_M_dataplus;


;; Function _Tp* __gnu_cxx::new_allocator<_Tp>::allocate(__gnu_cxx::new_allocator<_Tp>::size_type, const void*) [with _Tp = char16_t; __gnu_cxx::new_allocator<_Tp>::pointer = char16_t*; __gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int] (null)
;; enabled by -tree-original


if (<<cleanup_point __gnu_cxx::new_allocator<char16_t>::max_size (this) < __n>>)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_bad_alloc () >>>>>;
  }
<<cleanup_point return <retval> = (char16_t *) operator new (2 * __n)>>;


;; Function static std::allocator_traits<std::allocator<_CharT> >::size_type std::allocator_traits<std::allocator<_CharT> >::max_size(const allocator_type&) [with _Tp = char32_t; std::allocator_traits<std::allocator<_CharT> >::size_type = long unsigned int; std::allocator_traits<std::allocator<_CharT> >::allocator_type = std::allocator<char32_t>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = __gnu_cxx::new_allocator<char32_t>::max_size ((const struct new_allocator *) (const struct allocator_type *) __a)>>
   >>>;


;; Function const allocator_type& std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_get_allocator() const [with _CharT = char32_t; _Traits = std::char_traits<char32_t>; _Alloc = std::allocator<char32_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::allocator_type = std::allocator<char32_t>] (null)
;; enabled by -tree-original


return <retval> = (const struct allocator_type &) (const struct allocator *) &((const struct basic_string *) this)->_M_dataplus;


;; Function _Tp* __gnu_cxx::new_allocator<_Tp>::allocate(__gnu_cxx::new_allocator<_Tp>::size_type, const void*) [with _Tp = char32_t; __gnu_cxx::new_allocator<_Tp>::pointer = char32_t*; __gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int] (null)
;; enabled by -tree-original


if (<<cleanup_point __gnu_cxx::new_allocator<char32_t>::max_size (this) < __n>>)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_bad_alloc () >>>>>;
  }
<<cleanup_point return <retval> = (char32_t *) operator new (4 * __n)>>;


;; Function __gnu_cxx::new_allocator<_Tp>::new_allocator() [with _Tp = std::_Sp_counted_ptr_inplace<std::mutex, std::allocator<std::mutex>, (__gnu_cxx::_Lock_policy)2u>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    
  }
   >>>;


;; Function __gnu_cxx::new_allocator<_Tp>::~new_allocator() [with _Tp = std::_Sp_counted_ptr_inplace<std::mutex, std::allocator<std::mutex>, (__gnu_cxx::_Lock_policy)2u>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    
  }
  <D.115356>:;
   >>>;


;; Function static _Tp* std::allocator_traits<std::allocator<_CharT> >::allocate(std::allocator_traits<std::allocator<_CharT> >::allocator_type&, std::allocator_traits<std::allocator<_CharT> >::size_type) [with _Tp = std::_Sp_counted_ptr_inplace<std::mutex, std::allocator<std::mutex>, (__gnu_cxx::_Lock_policy)2u>; std::allocator_traits<std::allocator<_CharT> >::pointer = std::_Sp_counted_ptr_inplace<std::mutex, std::allocator<std::mutex>, (__gnu_cxx::_Lock_policy)2u>*; std::allocator_traits<std::allocator<_CharT> >::allocator_type = std::allocator<std::_Sp_counted_ptr_inplace<std::mutex, std::allocator<std::mutex>, (__gnu_cxx::_Lock_policy)2u> >; std::allocator_traits<std::allocator<_CharT> >::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (struct _Sp_counted_ptr_inplace *) __gnu_cxx::new_allocator<std::_Sp_counted_ptr_inplace<std::mutex, std::allocator<std::mutex>, (__gnu_cxx::_Lock_policy)2u> >::allocate ((struct new_allocator *) (struct allocator_type *) __a, __n, 0B)>>;


;; Function std::__allocated_ptr<_Alloc>::__allocated_ptr(_Alloc&, std::__allocated_ptr<_Alloc>::pointer) [with _Alloc = std::allocator<std::_Sp_counted_ptr_inplace<std::mutex, std::allocator<std::mutex>, (__gnu_cxx::_Lock_policy)2u> >; std::__allocated_ptr<_Alloc>::pointer = std::_Sp_counted_ptr_inplace<std::mutex, std::allocator<std::mutex>, (__gnu_cxx::_Lock_policy)2u>*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __allocated_ptr *) this)->_M_alloc = (struct allocator *) __a) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __allocated_ptr *) this)->_M_ptr = __ptr) >>>>>;
  }
   >>>;


;; Function static void std::allocator_traits<std::allocator<_CharT> >::deallocate(std::allocator_traits<std::allocator<_CharT> >::allocator_type&, std::allocator_traits<std::allocator<_CharT> >::pointer, std::allocator_traits<std::allocator<_CharT> >::size_type) [with _Tp = std::_Sp_counted_ptr_inplace<std::mutex, std::allocator<std::mutex>, (__gnu_cxx::_Lock_policy)2u>; std::allocator_traits<std::allocator<_CharT> >::allocator_type = std::allocator<std::_Sp_counted_ptr_inplace<std::mutex, std::allocator<std::mutex>, (__gnu_cxx::_Lock_policy)2u> >; std::allocator_traits<std::allocator<_CharT> >::pointer = std::_Sp_counted_ptr_inplace<std::mutex, std::allocator<std::mutex>, (__gnu_cxx::_Lock_policy)2u>*; std::allocator_traits<std::allocator<_CharT> >::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<std::_Sp_counted_ptr_inplace<std::mutex, std::allocator<std::mutex>, (__gnu_cxx::_Lock_policy)2u> >::deallocate ((struct new_allocator *) (struct allocator_type *) __a, __p, __n) >>>>>;


;; Function std::__allocated_ptr<_Alloc>::value_type* std::__allocated_ptr<_Alloc>::_S_raw_ptr(std::__allocated_ptr<_Alloc>::value_type*) [with _Alloc = std::allocator<std::_Sp_counted_ptr_inplace<std::mutex, std::allocator<std::mutex>, (__gnu_cxx::_Lock_policy)2u> >; std::__allocated_ptr<_Alloc>::value_type = std::_Sp_counted_ptr_inplace<std::mutex, std::allocator<std::mutex>, (__gnu_cxx::_Lock_policy)2u>] (null)
;; enabled by -tree-original


return <retval> = __ptr;


;; Function __gnu_cxx::new_allocator<_Tp>::new_allocator(const __gnu_cxx::new_allocator<_Tp>&) [with _Tp = std::mutex] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    
  }
   >>>;


;; Function constexpr std::_Mutex_base<(__gnu_cxx::_Lock_policy)2u>::_Mutex_base() (null)
;; enabled by -tree-original


{
  
}


;; Function std::_Sp_counted_base<_Lp>::_Sp_counted_base() [with __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Mutex_base<(__gnu_cxx::_Lock_policy)2u>::_Mutex_base ((struct _Mutex_base *) this) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Sp_counted_base *) this)->_vptr._Sp_counted_base = &_ZTVSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE2EE + 16) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Sp_counted_base *) this)->_M_use_count = 1) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Sp_counted_base *) this)->_M_weak_count = 1) >>>>>;
  }
   >>>;


;; Function constexpr std::aligned_storage<40ul, 8ul>::aligned_storage() (null)
;; enabled by -tree-original


{
  
}


;; Function __gnu_cxx::__aligned_buffer<_Tp>::__aligned_buffer() [with _Tp = std::mutex] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::aligned_storage<40ul, 8ul>::aligned_storage ((struct aligned_storage *) this) >>>>>;
}


;; Function std::_Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp>::_Impl::_Impl(_Alloc) [with _Tp = std::mutex; _Alloc = std::allocator<std::mutex>; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Sp_ebo_helper<0, std::allocator<std::mutex>, true>::_Sp_ebo_helper ((struct _Sp_ebo_helper *) this, (const struct allocator &) (const struct allocator *) (struct allocator *) __a) >>>>>;
    try
      {
        <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::__aligned_buffer<std::mutex>::__aligned_buffer (&((struct _Impl *) this)->_M_storage) >>>>>;
      }
    catch
      {
        std::_Sp_ebo_helper<0, std::allocator<std::mutex>, true>::~_Sp_ebo_helper ((struct _Sp_ebo_helper *) this);
      }
  }
   >>>;


;; Function _Tp* std::_Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp>::_M_ptr() [with _Tp = std::mutex; _Alloc = std::allocator<std::mutex>; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = __gnu_cxx::__aligned_buffer<std::mutex>::_M_ptr (&((struct _Sp_counted_ptr_inplace *) this)->_M_impl._M_storage)>>
   >>>;


;; Function static void std::allocator_traits<std::allocator<_CharT> >::construct(std::allocator_traits<std::allocator<_CharT> >::allocator_type&, _Up*, _Args&& ...) [with _Up = std::mutex; _Args = {}; _Tp = std::mutex; std::allocator_traits<std::allocator<_CharT> >::allocator_type = std::allocator<std::mutex>] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<std::mutex>::construct<std::mutex> ((struct new_allocator *) (struct allocator_type *) __a, __p) >>>>>;


;; Function __gnu_cxx::new_allocator<_Tp>::new_allocator() [with _Tp = std::_Sp_counted_ptr_inplace<std::__future_base::_State_baseV2, std::allocator<std::__future_base::_State_baseV2>, (__gnu_cxx::_Lock_policy)2u>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    
  }
   >>>;


;; Function __gnu_cxx::new_allocator<_Tp>::~new_allocator() [with _Tp = std::_Sp_counted_ptr_inplace<std::__future_base::_State_baseV2, std::allocator<std::__future_base::_State_baseV2>, (__gnu_cxx::_Lock_policy)2u>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    
  }
  <D.115419>:;
   >>>;


;; Function static _Tp* std::allocator_traits<std::allocator<_CharT> >::allocate(std::allocator_traits<std::allocator<_CharT> >::allocator_type&, std::allocator_traits<std::allocator<_CharT> >::size_type) [with _Tp = std::_Sp_counted_ptr_inplace<std::__future_base::_State_baseV2, std::allocator<std::__future_base::_State_baseV2>, (__gnu_cxx::_Lock_policy)2u>; std::allocator_traits<std::allocator<_CharT> >::pointer = std::_Sp_counted_ptr_inplace<std::__future_base::_State_baseV2, std::allocator<std::__future_base::_State_baseV2>, (__gnu_cxx::_Lock_policy)2u>*; std::allocator_traits<std::allocator<_CharT> >::allocator_type = std::allocator<std::_Sp_counted_ptr_inplace<std::__future_base::_State_baseV2, std::allocator<std::__future_base::_State_baseV2>, (__gnu_cxx::_Lock_policy)2u> >; std::allocator_traits<std::allocator<_CharT> >::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (struct _Sp_counted_ptr_inplace *) __gnu_cxx::new_allocator<std::_Sp_counted_ptr_inplace<std::__future_base::_State_baseV2, std::allocator<std::__future_base::_State_baseV2>, (__gnu_cxx::_Lock_policy)2u> >::allocate ((struct new_allocator *) (struct allocator_type *) __a, __n, 0B)>>;


;; Function std::__allocated_ptr<_Alloc>::__allocated_ptr(_Alloc&, std::__allocated_ptr<_Alloc>::pointer) [with _Alloc = std::allocator<std::_Sp_counted_ptr_inplace<std::__future_base::_State_baseV2, std::allocator<std::__future_base::_State_baseV2>, (__gnu_cxx::_Lock_policy)2u> >; std::__allocated_ptr<_Alloc>::pointer = std::_Sp_counted_ptr_inplace<std::__future_base::_State_baseV2, std::allocator<std::__future_base::_State_baseV2>, (__gnu_cxx::_Lock_policy)2u>*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __allocated_ptr *) this)->_M_alloc = (struct allocator *) __a) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __allocated_ptr *) this)->_M_ptr = __ptr) >>>>>;
  }
   >>>;


;; Function static void std::allocator_traits<std::allocator<_CharT> >::deallocate(std::allocator_traits<std::allocator<_CharT> >::allocator_type&, std::allocator_traits<std::allocator<_CharT> >::pointer, std::allocator_traits<std::allocator<_CharT> >::size_type) [with _Tp = std::_Sp_counted_ptr_inplace<std::__future_base::_State_baseV2, std::allocator<std::__future_base::_State_baseV2>, (__gnu_cxx::_Lock_policy)2u>; std::allocator_traits<std::allocator<_CharT> >::allocator_type = std::allocator<std::_Sp_counted_ptr_inplace<std::__future_base::_State_baseV2, std::allocator<std::__future_base::_State_baseV2>, (__gnu_cxx::_Lock_policy)2u> >; std::allocator_traits<std::allocator<_CharT> >::pointer = std::_Sp_counted_ptr_inplace<std::__future_base::_State_baseV2, std::allocator<std::__future_base::_State_baseV2>, (__gnu_cxx::_Lock_policy)2u>*; std::allocator_traits<std::allocator<_CharT> >::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<std::_Sp_counted_ptr_inplace<std::__future_base::_State_baseV2, std::allocator<std::__future_base::_State_baseV2>, (__gnu_cxx::_Lock_policy)2u> >::deallocate ((struct new_allocator *) (struct allocator_type *) __a, __p, __n) >>>>>;


;; Function std::__allocated_ptr<_Alloc>::value_type* std::__allocated_ptr<_Alloc>::_S_raw_ptr(std::__allocated_ptr<_Alloc>::value_type*) [with _Alloc = std::allocator<std::_Sp_counted_ptr_inplace<std::__future_base::_State_baseV2, std::allocator<std::__future_base::_State_baseV2>, (__gnu_cxx::_Lock_policy)2u> >; std::__allocated_ptr<_Alloc>::value_type = std::_Sp_counted_ptr_inplace<std::__future_base::_State_baseV2, std::allocator<std::__future_base::_State_baseV2>, (__gnu_cxx::_Lock_policy)2u>] (null)
;; enabled by -tree-original


return <retval> = __ptr;


;; Function __gnu_cxx::new_allocator<_Tp>::new_allocator(const __gnu_cxx::new_allocator<_Tp>&) [with _Tp = std::__future_base::_State_baseV2] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    
  }
   >>>;


;; Function constexpr std::aligned_storage<32ul, 8ul>::aligned_storage() (null)
;; enabled by -tree-original


{
  
}


;; Function __gnu_cxx::__aligned_buffer<_Tp>::__aligned_buffer() [with _Tp = std::__future_base::_State_baseV2] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::aligned_storage<32ul, 8ul>::aligned_storage ((struct aligned_storage *) this) >>>>>;
}


;; Function std::_Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp>::_Impl::_Impl(_Alloc) [with _Tp = std::__future_base::_State_baseV2; _Alloc = std::allocator<std::__future_base::_State_baseV2>; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Sp_ebo_helper<0, std::allocator<std::__future_base::_State_baseV2>, true>::_Sp_ebo_helper ((struct _Sp_ebo_helper *) this, (const struct allocator &) (const struct allocator *) (struct allocator *) __a) >>>>>;
    try
      {
        <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::__aligned_buffer<std::__future_base::_State_baseV2>::__aligned_buffer (&((struct _Impl *) this)->_M_storage) >>>>>;
      }
    catch
      {
        std::_Sp_ebo_helper<0, std::allocator<std::__future_base::_State_baseV2>, true>::~_Sp_ebo_helper ((struct _Sp_ebo_helper *) this);
      }
  }
   >>>;


;; Function _Tp* std::_Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp>::_M_ptr() [with _Tp = std::__future_base::_State_baseV2; _Alloc = std::allocator<std::__future_base::_State_baseV2>; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = __gnu_cxx::__aligned_buffer<std::__future_base::_State_baseV2>::_M_ptr (&((struct _Sp_counted_ptr_inplace *) this)->_M_impl._M_storage)>>
   >>>;


;; Function static void std::allocator_traits<std::allocator<_CharT> >::construct(std::allocator_traits<std::allocator<_CharT> >::allocator_type&, _Up*, _Args&& ...) [with _Up = std::__future_base::_State_baseV2; _Args = {}; _Tp = std::__future_base::_State_baseV2; std::allocator_traits<std::allocator<_CharT> >::allocator_type = std::allocator<std::__future_base::_State_baseV2>] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<std::__future_base::_State_baseV2>::construct<std::__future_base::_State_baseV2> ((struct new_allocator *) (struct allocator_type *) __a, __p) >>>>>;


;; Function constexpr typename std::remove_reference< <template-parameter-1-1> >::type&& std::move(_Tp&&) [with _Tp = const std::allocator<int>&; typename std::remove_reference< <template-parameter-1-1> >::type = const std::allocator<int>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (const struct type &) (const struct type *) NON_LVALUE_EXPR <(const struct type &) __t>
   >>>;


;; Function std::__shared_count<_Lp>::__shared_count(std::_Sp_make_shared_tag, _Tp*, const _Alloc&, _Args&& ...) [with _Tp = std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>; _Alloc = std::allocator<int>; _Args = {long int (&)(int, int), const std::allocator<int>&}; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __shared_count *) this)->_M_pi = 0B) >>>>>;
  {
    typedef struct _Sp_cp_type _Sp_cp_type;
    struct __allocator_type __a2;
    struct __allocated_ptr __guard;
    struct _Sp_cp_type * __mem;

        struct __allocator_type __a2;
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator<std::_Sp_counted_ptr_inplace<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, std::allocator<int>, (__gnu_cxx::_Lock_policy)2u> >::allocator<int> (&__a2, (const struct allocator &) (const struct allocator *) __a) >>>>>;
    try
      {
                struct __allocated_ptr __guard;
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__guard = <<< Unknown tree: aggr_init_expr
  4
  __allocate_guarded
  D.116064
  (struct allocator &) &__a2 >>>) >>>>>;
        try
          {
                        struct _Sp_cp_type * __mem;
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__mem = std::__allocated_ptr<std::allocator<std::_Sp_counted_ptr_inplace<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, std::allocator<int>, (__gnu_cxx::_Lock_policy)2u> > >::get (&__guard)) >>>>>;
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (TARGET_EXPR <D.116196, &TARGET_EXPR <D.116195, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.116195
  (struct allocator *) <<< Unknown tree: void_cst >>>
  (const struct allocator &) (const struct type *) std::move<const std::allocator<int>&> ((const struct allocator &) (const struct allocator *) __a) >>>>>;, TARGET_EXPR <D.116197, (long int (&<T105d3>) (int, int)) (long int (*<T105d2>) (int, int)) std::forward<long int (&)(int, int)> ((long int (&<T15f36>) (int, int)) (long int (*<T105d2>) (int, int)) __args#0)>;;, TARGET_EXPR <D.116198, (const struct allocator &) (const struct allocator *) std::forward<const std::allocator<int>&> ((const struct type &) (const struct allocator *) __args#1)>;;, TARGET_EXPR <D.116080, (void *) TARGET_EXPR <D.116078, __mem>>;, TARGET_EXPR <D.116079, operator new (64, NON_LVALUE_EXPR <D.116080>)>;;, (struct _Sp_cp_type *) D.116079 != 0B ? try
    {
      std::_Sp_counted_ptr_inplace<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, std::allocator<int>, (__gnu_cxx::_Lock_policy)2u>::_Sp_counted_ptr_inplace<long int (&)(int, int), const std::allocator<int>&> ((struct _Sp_cp_type *) D.116079, NON_LVALUE_EXPR <D.116196>, NON_LVALUE_EXPR <D.116197>, NON_LVALUE_EXPR <D.116198>);
    }
  catch
    {
      operator delete (D.116079, NON_LVALUE_EXPR <D.116080>);
    }, (struct _Sp_cp_type *) D.116079; : (struct _Sp_cp_type *) D.116079;) >>>>>;
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __shared_count *) this)->_M_pi = (struct _Sp_counted_base *) __mem) >>>>>;
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::__allocated_ptr<std::allocator<std::_Sp_counted_ptr_inplace<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, std::allocator<int>, (__gnu_cxx::_Lock_policy)2u> > >::operator= (&__guard, 0) >>>>>;
          }
        finally
          {
            std::__allocated_ptr<std::allocator<std::_Sp_counted_ptr_inplace<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, std::allocator<int>, (__gnu_cxx::_Lock_policy)2u> > >::~__allocated_ptr (&__guard);
          }
      }
    finally
      {
        std::allocator<std::_Sp_counted_ptr_inplace<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, std::allocator<int>, (__gnu_cxx::_Lock_policy)2u> >::~allocator (&__a2);
      }
  }
}


;; Function bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&) [with _Iterator = std::packaged_task<long int(int, int)>*] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = !std::operator==<std::packaged_task<long int(int, int)>*> ((const struct move_iterator &) (const struct move_iterator *) __x, (const struct move_iterator &) (const struct move_iterator *) __y)>>;


;; Function std::move_iterator<_Iterator>& std::move_iterator<_Iterator>::operator++() [with _Iterator = std::packaged_task<long int(int, int)>*] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void)  ++((struct move_iterator *) this)->_M_current >>>>>;
return <retval> = (struct move_iterator &) (struct move_iterator *) this;


;; Function std::move_iterator<_Iterator>::reference std::move_iterator<_Iterator>::operator*() const [with _Iterator = std::packaged_task<long int(int, int)>*; std::move_iterator<_Iterator>::reference = std::packaged_task<long int(int, int)>&&] (null)
;; enabled by -tree-original


return <retval> = (struct packaged_task &) (struct packaged_task *) NON_LVALUE_EXPR <(struct packaged_task &) ((const struct move_iterator *) this)->_M_current>;


;; Function void std::_Construct(_T1*, _Args&& ...) [with _T1 = std::packaged_task<long int(int, int)>; _Args = {std::packaged_task<long int(int, int)>}] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (TARGET_EXPR <D.116228, (struct packaged_task &) (struct packaged_task *) std::forward<std::packaged_task<long int(int, int)> > ((struct type &) (struct packaged_task *) __args#0)>;, TARGET_EXPR <D.116226, (void *) __p>;, TARGET_EXPR <D.116227, operator new (16, NON_LVALUE_EXPR <D.116226>)>;;, (struct packaged_task *) D.116227 != 0B ? try
    {
      std::packaged_task<long int(int, int)>::packaged_task ((struct packaged_task *) D.116227, NON_LVALUE_EXPR <D.116228>);
    }
  catch
    {
      operator delete (D.116227, NON_LVALUE_EXPR <D.116226>);
    }, (struct packaged_task *) D.116227; : (struct packaged_task *) D.116227;) >>>>>;


;; Function bool std::operator!=(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&) [with _Iterator = std::future<long int>*] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = !std::operator==<std::future<long int>*> ((const struct move_iterator &) (const struct move_iterator *) __x, (const struct move_iterator &) (const struct move_iterator *) __y)>>;


;; Function std::move_iterator<_Iterator>& std::move_iterator<_Iterator>::operator++() [with _Iterator = std::future<long int>*] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void)  ++((struct move_iterator *) this)->_M_current >>>>>;
return <retval> = (struct move_iterator &) (struct move_iterator *) this;


;; Function std::move_iterator<_Iterator>::reference std::move_iterator<_Iterator>::operator*() const [with _Iterator = std::future<long int>*; std::move_iterator<_Iterator>::reference = std::future<long int>&&] (null)
;; enabled by -tree-original


return <retval> = (struct future &) (struct future *) NON_LVALUE_EXPR <(struct future &) ((const struct move_iterator *) this)->_M_current>;


;; Function void std::_Construct(_T1*, _Args&& ...) [with _T1 = std::future<long int>; _Args = {std::future<long int>}] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (TARGET_EXPR <D.116241, (struct future &) (struct future *) std::forward<std::future<long int> > ((struct type &) (struct future *) __args#0)>;, TARGET_EXPR <D.116239, (void *) __p>;, TARGET_EXPR <D.116240, operator new (16, NON_LVALUE_EXPR <D.116239>)>;;, (struct future *) D.116240 != 0B ? try
    {
      std::future<long int>::future ((struct future *) D.116240, NON_LVALUE_EXPR <D.116241>);
    }
  catch
    {
      operator delete (D.116240, NON_LVALUE_EXPR <D.116239>);
    }, (struct future *) D.116240; : (struct future *) D.116240;) >>>>>;


;; Function constexpr typename std::remove_reference< <template-parameter-1-1> >::type&& std::move(_Tp&&) [with _Tp = const std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >&; typename std::remove_reference< <template-parameter-1-1> >::type = const std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (const struct type &) (const struct type *) NON_LVALUE_EXPR <(const struct type &) __t>
   >>>;


;; Function std::__shared_count<_Lp>::__shared_count(std::_Sp_make_shared_tag, _Tp*, const _Alloc&, _Args&& ...) [with _Tp = std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >; _Alloc = std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >; _Args = {std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)>}; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __shared_count *) this)->_M_pi = 0B) >>>>>;
  {
    typedef struct _Sp_cp_type _Sp_cp_type;
    struct __allocator_type __a2;
    struct __allocated_ptr __guard;
    struct _Sp_cp_type * __mem;

        struct __allocator_type __a2;
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator<std::_Sp_counted_ptr_inplace<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >, std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >, (__gnu_cxx::_Lock_policy)2u> >::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > > (&__a2, (const struct allocator &) (const struct allocator *) __a) >>>>>;
    try
      {
                struct __allocated_ptr __guard;
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__guard = <<< Unknown tree: aggr_init_expr
  4
  __allocate_guarded
  D.116749
  (struct allocator &) &__a2 >>>) >>>>>;
        try
          {
                        struct _Sp_cp_type * __mem;
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__mem = std::__allocated_ptr<std::allocator<std::_Sp_counted_ptr_inplace<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >, std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >, (__gnu_cxx::_Lock_policy)2u> > >::get (&__guard)) >>>>>;
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (TARGET_EXPR <D.116882, &TARGET_EXPR <D.116881, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.116881
  (struct allocator *) <<< Unknown tree: void_cst >>>
  (const struct allocator &) (const struct type *) std::move<const std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >&> ((const struct allocator &) (const struct allocator *) __a) >>>>>;, TARGET_EXPR <D.116883, (struct _Bind_simple &) (struct _Bind_simple *) std::forward<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > ((struct type &) (struct _Bind_simple *) __args#0)>;;, TARGET_EXPR <D.116769, (void *) TARGET_EXPR <D.116767, __mem>>;, TARGET_EXPR <D.116768, operator new (64, NON_LVALUE_EXPR <D.116769>)>;;, (struct _Sp_cp_type *) D.116768 != 0B ? try
    {
      std::_Sp_counted_ptr_inplace<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >, std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >, (__gnu_cxx::_Lock_policy)2u>::_Sp_counted_ptr_inplace<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > ((struct _Sp_cp_type *) D.116768, NON_LVALUE_EXPR <D.116882>, NON_LVALUE_EXPR <D.116883>);
    }
  catch
    {
      operator delete (D.116768, NON_LVALUE_EXPR <D.116769>);
    }, (struct _Sp_cp_type *) D.116768; : (struct _Sp_cp_type *) D.116768;) >>>>>;
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __shared_count *) this)->_M_pi = (struct _Sp_counted_base *) __mem) >>>>>;
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::__allocated_ptr<std::allocator<std::_Sp_counted_ptr_inplace<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >, std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >, (__gnu_cxx::_Lock_policy)2u> > >::operator= (&__guard, 0) >>>>>;
          }
        finally
          {
            std::__allocated_ptr<std::allocator<std::_Sp_counted_ptr_inplace<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >, std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >, (__gnu_cxx::_Lock_policy)2u> > >::~__allocated_ptr (&__guard);
          }
      }
    finally
      {
        std::allocator<std::_Sp_counted_ptr_inplace<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >, std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >, (__gnu_cxx::_Lock_policy)2u> >::~allocator (&__a2);
      }
  }
}


;; Function __gnu_cxx::new_allocator<_Tp>::size_type __gnu_cxx::new_allocator<_Tp>::max_size() const [with _Tp = std::thread*; __gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 18446744073709551615 / 8
   >>>;


;; Function static _ForwardIterator std::__uninitialized_copy<true>::__uninit_copy(_InputIterator, _InputIterator, _ForwardIterator) [with _InputIterator = std::move_iterator<std::thread**>; _ForwardIterator = std::thread**] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = std::copy<std::move_iterator<std::thread**>, std::thread**> (TARGET_EXPR <D.116906, __first>, TARGET_EXPR <D.116907, __last>, __result)>>;


;; Function __gnu_cxx::new_allocator<_Tp>::size_type __gnu_cxx::new_allocator<_Tp>::max_size() const [with _Tp = char16_t; __gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 18446744073709551615 / 2
   >>>;


;; Function __gnu_cxx::new_allocator<_Tp>::size_type __gnu_cxx::new_allocator<_Tp>::max_size() const [with _Tp = char32_t; __gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 18446744073709551615 / 4
   >>>;


;; Function _Tp* __gnu_cxx::new_allocator<_Tp>::allocate(__gnu_cxx::new_allocator<_Tp>::size_type, const void*) [with _Tp = std::_Sp_counted_ptr_inplace<std::mutex, std::allocator<std::mutex>, (__gnu_cxx::_Lock_policy)2u>; __gnu_cxx::new_allocator<_Tp>::pointer = std::_Sp_counted_ptr_inplace<std::mutex, std::allocator<std::mutex>, (__gnu_cxx::_Lock_policy)2u>*; __gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int] (null)
;; enabled by -tree-original


if (<<cleanup_point __gnu_cxx::new_allocator<std::_Sp_counted_ptr_inplace<std::mutex, std::allocator<std::mutex>, (__gnu_cxx::_Lock_policy)2u> >::max_size (this) < __n>>)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_bad_alloc () >>>>>;
  }
<<cleanup_point return <retval> = (struct _Sp_counted_ptr_inplace *) operator new (56 * __n)>>;


;; Function void __gnu_cxx::new_allocator<_Tp>::deallocate(__gnu_cxx::new_allocator<_Tp>::pointer, __gnu_cxx::new_allocator<_Tp>::size_type) [with _Tp = std::_Sp_counted_ptr_inplace<std::mutex, std::allocator<std::mutex>, (__gnu_cxx::_Lock_policy)2u>; __gnu_cxx::new_allocator<_Tp>::pointer = std::_Sp_counted_ptr_inplace<std::mutex, std::allocator<std::mutex>, (__gnu_cxx::_Lock_policy)2u>*; __gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  operator delete ((void *) __p) >>>>>;


;; Function std::_Sp_ebo_helper<_Nm, _Tp, true>::_Sp_ebo_helper(const _Tp&) [with int _Nm = 0; _Tp = std::allocator<std::mutex>] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator<std::mutex>::allocator ((struct allocator *) this, (const struct allocator &) (const struct allocator *) __tp) >>>>>;
  try
    {
      
    }
  catch
    {
      std::allocator<std::mutex>::~allocator ((struct allocator *) this);
    }
}


;; Function _Tp* __gnu_cxx::__aligned_buffer<_Tp>::_M_ptr() [with _Tp = std::mutex] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct mutex *) __gnu_cxx::__aligned_buffer<std::mutex>::_M_addr (this)>>
   >>>;


;; Function constexpr std::__mutex_base::__mutex_base() (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __mutex_base *) this)->_M_mutex = {.__data={.__lock=0, .__count=0, .__owner=0, .__nusers=0, .__kind=0, .__spins=0, .__elision=0, .__list={.__prev=0B, .__next=0B}}}) >>>>>;
}


;; Function constexpr std::mutex::mutex() (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__mutex_base::__mutex_base (&((struct mutex *) this)->D.58537) >>>>>;
}


;; Function void __gnu_cxx::new_allocator<_Tp>::construct(_Up*, _Args&& ...) [with _Up = std::mutex; _Args = {}; _Tp = std::mutex] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (TARGET_EXPR <D.116917, (void *) __p>;, TARGET_EXPR <D.116918, operator new (40, NON_LVALUE_EXPR <D.116917>)>;;, (struct mutex *) D.116918 != 0B ? try
    {
      *(struct mutex *) D.116918 = <<< Unknown tree: aggr_init_expr
  4
  __comp_ctor 
  D.116925
  (struct mutex *) <<< Unknown tree: void_cst >>> >>>;
    }
  catch
    {
      operator delete (D.116918, NON_LVALUE_EXPR <D.116917>);
    }, (struct mutex *) D.116918; : (struct mutex *) D.116918;) >>>>>;


;; Function _Tp* __gnu_cxx::new_allocator<_Tp>::allocate(__gnu_cxx::new_allocator<_Tp>::size_type, const void*) [with _Tp = std::_Sp_counted_ptr_inplace<std::__future_base::_State_baseV2, std::allocator<std::__future_base::_State_baseV2>, (__gnu_cxx::_Lock_policy)2u>; __gnu_cxx::new_allocator<_Tp>::pointer = std::_Sp_counted_ptr_inplace<std::__future_base::_State_baseV2, std::allocator<std::__future_base::_State_baseV2>, (__gnu_cxx::_Lock_policy)2u>*; __gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int] (null)
;; enabled by -tree-original


if (<<cleanup_point __gnu_cxx::new_allocator<std::_Sp_counted_ptr_inplace<std::__future_base::_State_baseV2, std::allocator<std::__future_base::_State_baseV2>, (__gnu_cxx::_Lock_policy)2u> >::max_size (this) < __n>>)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_bad_alloc () >>>>>;
  }
<<cleanup_point return <retval> = (struct _Sp_counted_ptr_inplace *) operator new (48 * __n)>>;


;; Function void __gnu_cxx::new_allocator<_Tp>::deallocate(__gnu_cxx::new_allocator<_Tp>::pointer, __gnu_cxx::new_allocator<_Tp>::size_type) [with _Tp = std::_Sp_counted_ptr_inplace<std::__future_base::_State_baseV2, std::allocator<std::__future_base::_State_baseV2>, (__gnu_cxx::_Lock_policy)2u>; __gnu_cxx::new_allocator<_Tp>::pointer = std::_Sp_counted_ptr_inplace<std::__future_base::_State_baseV2, std::allocator<std::__future_base::_State_baseV2>, (__gnu_cxx::_Lock_policy)2u>*; __gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  operator delete ((void *) __p) >>>>>;


;; Function std::_Sp_ebo_helper<_Nm, _Tp, true>::_Sp_ebo_helper(const _Tp&) [with int _Nm = 0; _Tp = std::allocator<std::__future_base::_State_baseV2>] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator<std::__future_base::_State_baseV2>::allocator ((struct allocator *) this, (const struct allocator &) (const struct allocator *) __tp) >>>>>;
  try
    {
      
    }
  catch
    {
      std::allocator<std::__future_base::_State_baseV2>::~allocator ((struct allocator *) this);
    }
}


;; Function _Tp* __gnu_cxx::__aligned_buffer<_Tp>::_M_ptr() [with _Tp = std::__future_base::_State_baseV2] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct _State_baseV2 *) __gnu_cxx::__aligned_buffer<std::__future_base::_State_baseV2>::_M_addr (this)>>
   >>>;


;; Function void __gnu_cxx::new_allocator<_Tp>::construct(_Up*, _Args&& ...) [with _Up = std::__future_base::_State_baseV2; _Args = {}; _Tp = std::__future_base::_State_baseV2] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (TARGET_EXPR <D.116933, (void *) __p>;, TARGET_EXPR <D.116934, operator new (32, NON_LVALUE_EXPR <D.116933>)>;;, (struct _State_baseV2 *) D.116934 != 0B ? try
    {
      *(struct _State_baseV2 *) D.116934 = <<< Unknown tree: aggr_init_expr
  4
  __comp_ctor 
  D.116935
  (struct _State_baseV2 *) <<< Unknown tree: void_cst >>> >>>;
    }
  catch
    {
      operator delete (D.116934, NON_LVALUE_EXPR <D.116933>);
    }, (struct _State_baseV2 *) D.116934; : (struct _State_baseV2 *) D.116934;) >>>>>;


;; Function std::allocator< <template-parameter-1-1> >::allocator(const std::allocator<_Tp1>&) [with _Tp1 = int; _Tp = std::_Sp_counted_ptr_inplace<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, std::allocator<int>, (__gnu_cxx::_Lock_policy)2u>] (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<std::_Sp_counted_ptr_inplace<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, std::allocator<int>, (__gnu_cxx::_Lock_policy)2u> >::new_allocator ((struct new_allocator *) this) >>>>>;
    try
      {
        
      }
    catch
      {
        __gnu_cxx::new_allocator<std::_Sp_counted_ptr_inplace<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, std::allocator<int>, (__gnu_cxx::_Lock_policy)2u> >::~new_allocator ((struct new_allocator *) this);
      }
  }
   >>>;


;; Function std::allocator< <template-parameter-1-1> >::~allocator() [with _Tp = std::_Sp_counted_ptr_inplace<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, std::allocator<int>, (__gnu_cxx::_Lock_policy)2u>] (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  {
    try
      {
        
      }
    finally
      {
        __gnu_cxx::new_allocator<std::_Sp_counted_ptr_inplace<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, std::allocator<int>, (__gnu_cxx::_Lock_policy)2u> >::~new_allocator ((struct new_allocator *) this);
      }
  }
  <D.116940>:;
   >>>;


;; Function std::__allocated_ptr<_Alloc> std::__allocate_guarded(_Alloc&) [with _Alloc = std::allocator<std::_Sp_counted_ptr_inplace<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, std::allocator<int>, (__gnu_cxx::_Lock_policy)2u> >] (null)
;; enabled by -tree-original


<<cleanup_point return *<retval> = TARGET_EXPR <D.116964, <<< Unknown tree: aggr_init_expr
  6
  __comp_ctor 
  D.116964
  (struct __allocated_ptr *) <<< Unknown tree: void_cst >>>
  (struct allocator &) (struct allocator *) __a
  std::allocator_traits<std::allocator<std::_Sp_counted_ptr_inplace<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, std::allocator<int>, (__gnu_cxx::_Lock_policy)2u> > >::allocate ((struct allocator_type &) (struct allocator *) __a, 1) >>>>>>;


;; Function std::__allocated_ptr<_Alloc>::~__allocated_ptr() [with _Alloc = std::allocator<std::_Sp_counted_ptr_inplace<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, std::allocator<int>, (__gnu_cxx::_Lock_policy)2u> >] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    try
      {
        if (((struct __allocated_ptr *) this)->_M_ptr != 0B)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator_traits<std::allocator<std::_Sp_counted_ptr_inplace<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, std::allocator<int>, (__gnu_cxx::_Lock_policy)2u> > >::deallocate ((struct allocator_type &) NON_LVALUE_EXPR <((struct __allocated_ptr *) this)->_M_alloc>, ((struct __allocated_ptr *) this)->_M_ptr, 1) >>>>>;
          }
      }
    finally
      {
        *(struct 
        {
          struct allocator * _M_alloc;
          struct _Sp_counted_ptr_inplace * _M_ptr;
        } &) this = {CLOBBER};
      }
  }
  <D.116966>:;
   >>>;


;; Function std::__allocated_ptr<_Alloc>::__allocated_ptr(std::__allocated_ptr<_Alloc>&&) [with _Alloc = std::allocator<std::_Sp_counted_ptr_inplace<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, std::allocator<int>, (__gnu_cxx::_Lock_policy)2u> >] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __allocated_ptr *) this)->_M_alloc = __gd->_M_alloc) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __allocated_ptr *) this)->_M_ptr = __gd->_M_ptr) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__gd->_M_ptr = 0B) >>>>>;
  }
   >>>;


;; Function std::__allocated_ptr<_Alloc>::value_type* std::__allocated_ptr<_Alloc>::get() [with _Alloc = std::allocator<std::_Sp_counted_ptr_inplace<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, std::allocator<int>, (__gnu_cxx::_Lock_policy)2u> >; std::__allocated_ptr<_Alloc>::value_type = std::_Sp_counted_ptr_inplace<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, std::allocator<int>, (__gnu_cxx::_Lock_policy)2u>] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = std::__allocated_ptr<std::allocator<std::_Sp_counted_ptr_inplace<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, std::allocator<int>, (__gnu_cxx::_Lock_policy)2u> > >::_S_raw_ptr (this, ((struct __allocated_ptr *) this)->_M_ptr)>>;


;; Function std::allocator< <template-parameter-1-1> >::allocator(const std::allocator< <template-parameter-1-1> >&) [with _Tp = int] (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<int>::new_allocator ((struct new_allocator *) this, (const struct new_allocator &) (const struct new_allocator *) (const struct allocator *) __a) >>>>>;
    try
      {
        
      }
    catch
      {
        __gnu_cxx::new_allocator<int>::~new_allocator ((struct new_allocator *) this);
      }
  }
   >>>;


;; Function std::_Sp_ebo_helper<0, std::allocator<int>, true>::~_Sp_ebo_helper() (null)
;; enabled by -tree-original


{
  try
    {
      
    }
  finally
    {
      std::allocator<int>::~allocator ((struct allocator *) this);
    }
}
<D.116995>:;


;; Function std::_Sp_counted_ptr_inplace<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, std::allocator<int>, (__gnu_cxx::_Lock_policy)2u>::_Impl::~_Impl() (null)
;; enabled by -tree-original


{
  try
    {
      try
        {
          
        }
      finally
        {
          std::_Sp_ebo_helper<0, std::allocator<int>, true>::~_Sp_ebo_helper ((struct _Sp_ebo_helper *) this);
        }
    }
  finally
    {
      *(struct 
      {
        struct __aligned_buffer _M_storage;
      } &) this = {CLOBBER};
    }
}
<D.116993>:;


;; Function std::_Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp>::_Sp_counted_ptr_inplace(_Alloc, _Args&& ...) [with _Args = {long int (&)(int, int), const std::allocator<int>&}; _Tp = std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>; _Alloc = std::allocator<int>; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2u>::_Sp_counted_base (&((struct _Sp_counted_ptr_inplace *) this)->D.115717) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Sp_counted_ptr_inplace *) this)->D.115717._vptr._Sp_counted_base = &_ZTVSt23_Sp_counted_ptr_inplaceINSt13__future_base11_Task_stateIPFliiESaIiES2_EES4_LN9__gnu_cxx12_Lock_policyE2EE + 16) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Sp_counted_ptr_inplace<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, std::allocator<int>, (__gnu_cxx::_Lock_policy)2u>::_Impl::_Impl (&((struct _Sp_counted_ptr_inplace *) this)->_M_impl, &TARGET_EXPR <D.116991, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.116991
  (struct allocator *) <<< Unknown tree: void_cst >>>
  (const struct allocator &) (const struct allocator *) (struct allocator *) __a >>>>) >>>>>;
      try
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator_traits<std::allocator<int> >::construct<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, long int (&)(int, int), const std::allocator<int>&> ((struct allocator_type &) (struct allocator *) __a, std::_Sp_counted_ptr_inplace<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, std::allocator<int>, (__gnu_cxx::_Lock_policy)2u>::_M_ptr (this), (long int (&<T105d3>) (int, int)) (long int (*<T105d2>) (int, int)) std::forward<long int (&)(int, int)> ((long int (&<T15f36>) (int, int)) (long int (*<T105d2>) (int, int)) __args#0), (const struct allocator &) (const struct allocator *) std::forward<const std::allocator<int>&> ((const struct type &) (const struct allocator *) __args#1)) >>>>>;
        }
      catch
        {
          std::_Sp_counted_ptr_inplace<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, std::allocator<int>, (__gnu_cxx::_Lock_policy)2u>::_Impl::~_Impl (&((struct _Sp_counted_ptr_inplace *) this)->_M_impl);
        }
    }
  catch
    {
      std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2u>::~_Sp_counted_base (&((struct _Sp_counted_ptr_inplace *) this)->D.115717);
    }
}


;; Function std::__allocated_ptr<_Alloc>& std::__allocated_ptr<_Alloc>::operator=(std::nullptr_t) [with _Alloc = std::allocator<std::_Sp_counted_ptr_inplace<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, std::allocator<int>, (__gnu_cxx::_Lock_policy)2u> >; std::nullptr_t = std::nullptr_t] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __allocated_ptr *) this)->_M_ptr = 0B) >>>>>;
  return <retval> = (struct __allocated_ptr &) (struct __allocated_ptr *) this;
   >>>;


;; Function bool std::operator==(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&) [with _Iterator = std::packaged_task<long int(int, int)>*] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = std::move_iterator<std::packaged_task<long int(int, int)>*>::base ((const struct move_iterator *) __x) == std::move_iterator<std::packaged_task<long int(int, int)>*>::base ((const struct move_iterator *) __y)>>;


;; Function bool std::operator==(const std::move_iterator<_Iterator>&, const std::move_iterator<_Iterator>&) [with _Iterator = std::future<long int>*] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = std::move_iterator<std::future<long int>*>::base ((const struct move_iterator *) __x) == std::move_iterator<std::future<long int>*>::base ((const struct move_iterator *) __y)>>;


;; Function std::allocator< <template-parameter-1-1> >::allocator(const std::allocator<_Tp1>&) [with _Tp1 = std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >; _Tp = std::_Sp_counted_ptr_inplace<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >, std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >, (__gnu_cxx::_Lock_policy)2u>] (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<std::_Sp_counted_ptr_inplace<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >, std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >, (__gnu_cxx::_Lock_policy)2u> >::new_allocator ((struct new_allocator *) this) >>>>>;
    try
      {
        
      }
    catch
      {
        __gnu_cxx::new_allocator<std::_Sp_counted_ptr_inplace<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >, std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >, (__gnu_cxx::_Lock_policy)2u> >::~new_allocator ((struct new_allocator *) this);
      }
  }
   >>>;


;; Function std::allocator< <template-parameter-1-1> >::~allocator() [with _Tp = std::_Sp_counted_ptr_inplace<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >, std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >, (__gnu_cxx::_Lock_policy)2u>] (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  {
    try
      {
        
      }
    finally
      {
        __gnu_cxx::new_allocator<std::_Sp_counted_ptr_inplace<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >, std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >, (__gnu_cxx::_Lock_policy)2u> >::~new_allocator ((struct new_allocator *) this);
      }
  }
  <D.117086>:;
   >>>;


;; Function std::__allocated_ptr<_Alloc> std::__allocate_guarded(_Alloc&) [with _Alloc = std::allocator<std::_Sp_counted_ptr_inplace<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >, std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >, (__gnu_cxx::_Lock_policy)2u> >] (null)
;; enabled by -tree-original


<<cleanup_point return *<retval> = TARGET_EXPR <D.117110, <<< Unknown tree: aggr_init_expr
  6
  __comp_ctor 
  D.117110
  (struct __allocated_ptr *) <<< Unknown tree: void_cst >>>
  (struct allocator &) (struct allocator *) __a
  std::allocator_traits<std::allocator<std::_Sp_counted_ptr_inplace<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >, std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >, (__gnu_cxx::_Lock_policy)2u> > >::allocate ((struct allocator_type &) (struct allocator *) __a, 1) >>>>>>;


;; Function std::__allocated_ptr<_Alloc>::~__allocated_ptr() [with _Alloc = std::allocator<std::_Sp_counted_ptr_inplace<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >, std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >, (__gnu_cxx::_Lock_policy)2u> >] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    try
      {
        if (((struct __allocated_ptr *) this)->_M_ptr != 0B)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator_traits<std::allocator<std::_Sp_counted_ptr_inplace<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >, std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >, (__gnu_cxx::_Lock_policy)2u> > >::deallocate ((struct allocator_type &) NON_LVALUE_EXPR <((struct __allocated_ptr *) this)->_M_alloc>, ((struct __allocated_ptr *) this)->_M_ptr, 1) >>>>>;
          }
      }
    finally
      {
        *(struct 
        {
          struct allocator * _M_alloc;
          struct _Sp_counted_ptr_inplace * _M_ptr;
        } &) this = {CLOBBER};
      }
  }
  <D.117112>:;
   >>>;


;; Function std::__allocated_ptr<_Alloc>::__allocated_ptr(std::__allocated_ptr<_Alloc>&&) [with _Alloc = std::allocator<std::_Sp_counted_ptr_inplace<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >, std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >, (__gnu_cxx::_Lock_policy)2u> >] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __allocated_ptr *) this)->_M_alloc = __gd->_M_alloc) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __allocated_ptr *) this)->_M_ptr = __gd->_M_ptr) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__gd->_M_ptr = 0B) >>>>>;
  }
   >>>;


;; Function std::__allocated_ptr<_Alloc>::value_type* std::__allocated_ptr<_Alloc>::get() [with _Alloc = std::allocator<std::_Sp_counted_ptr_inplace<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >, std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >, (__gnu_cxx::_Lock_policy)2u> >; std::__allocated_ptr<_Alloc>::value_type = std::_Sp_counted_ptr_inplace<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >, std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >, (__gnu_cxx::_Lock_policy)2u>] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = std::__allocated_ptr<std::allocator<std::_Sp_counted_ptr_inplace<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >, std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >, (__gnu_cxx::_Lock_policy)2u> > >::_S_raw_ptr (this, ((struct __allocated_ptr *) this)->_M_ptr)>>;


;; Function std::allocator< <template-parameter-1-1> >::allocator(const std::allocator< <template-parameter-1-1> >&) [with _Tp = std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >] (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >::new_allocator ((struct new_allocator *) this, (const struct new_allocator &) (const struct new_allocator *) (const struct allocator *) __a) >>>>>;
    try
      {
        
      }
    catch
      {
        __gnu_cxx::new_allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >::~new_allocator ((struct new_allocator *) this);
      }
  }
   >>>;


;; Function std::_Sp_ebo_helper<0, std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >, true>::~_Sp_ebo_helper() (null)
;; enabled by -tree-original


{
  try
    {
      
    }
  finally
    {
      std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >::~allocator ((struct allocator *) this);
    }
}
<D.117141>:;


;; Function std::_Sp_counted_ptr_inplace<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >, std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >, (__gnu_cxx::_Lock_policy)2u>::_Impl::~_Impl() (null)
;; enabled by -tree-original


{
  try
    {
      try
        {
          
        }
      finally
        {
          std::_Sp_ebo_helper<0, std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >, true>::~_Sp_ebo_helper ((struct _Sp_ebo_helper *) this);
        }
    }
  finally
    {
      *(struct 
      {
        struct __aligned_buffer _M_storage;
      } &) this = {CLOBBER};
    }
}
<D.117139>:;


;; Function std::_Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp>::_Sp_counted_ptr_inplace(_Alloc, _Args&& ...) [with _Args = {std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)>}; _Tp = std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >; _Alloc = std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2u>::_Sp_counted_base (&((struct _Sp_counted_ptr_inplace *) this)->D.116402) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Sp_counted_ptr_inplace *) this)->D.116402._vptr._Sp_counted_base = &_ZTVSt23_Sp_counted_ptr_inplaceINSt6thread5_ImplISt12_Bind_simpleIFSt13packaged_taskIFliiEEiiEEEESaIS8_ELN9__gnu_cxx12_Lock_policyE2EE + 16) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Sp_counted_ptr_inplace<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >, std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >, (__gnu_cxx::_Lock_policy)2u>::_Impl::_Impl (&((struct _Sp_counted_ptr_inplace *) this)->_M_impl, &TARGET_EXPR <D.117137, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.117137
  (struct allocator *) <<< Unknown tree: void_cst >>>
  (const struct allocator &) (const struct allocator *) (struct allocator *) __a >>>>) >>>>>;
      try
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator_traits<std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > > >::construct<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >, std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > ((struct allocator_type &) (struct allocator *) __a, std::_Sp_counted_ptr_inplace<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >, std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >, (__gnu_cxx::_Lock_policy)2u>::_M_ptr (this), (struct _Bind_simple &) (struct _Bind_simple *) std::forward<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > ((struct type &) (struct _Bind_simple *) __args#0)) >>>>>;
        }
      catch
        {
          std::_Sp_counted_ptr_inplace<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >, std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >, (__gnu_cxx::_Lock_policy)2u>::_Impl::~_Impl (&((struct _Sp_counted_ptr_inplace *) this)->_M_impl);
        }
    }
  catch
    {
      std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2u>::~_Sp_counted_base (&((struct _Sp_counted_ptr_inplace *) this)->D.116402);
    }
}


;; Function std::__allocated_ptr<_Alloc>& std::__allocated_ptr<_Alloc>::operator=(std::nullptr_t) [with _Alloc = std::allocator<std::_Sp_counted_ptr_inplace<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >, std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >, (__gnu_cxx::_Lock_policy)2u> >; std::nullptr_t = std::nullptr_t] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __allocated_ptr *) this)->_M_ptr = 0B) >>>>>;
  return <retval> = (struct __allocated_ptr &) (struct __allocated_ptr *) this;
   >>>;


;; Function _OI std::copy(_II, _II, _OI) [with _II = std::move_iterator<std::thread**>; _OI = std::thread**] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = std::__copy_move_a2<true, std::thread**, std::thread**> (std::__miter_base<std::move_iterator<std::thread**> > (TARGET_EXPR <D.117242, __first>), std::__miter_base<std::move_iterator<std::thread**> > (TARGET_EXPR <D.117243, __last>), __result)>>;


;; Function __gnu_cxx::new_allocator<_Tp>::size_type __gnu_cxx::new_allocator<_Tp>::max_size() const [with _Tp = std::_Sp_counted_ptr_inplace<std::mutex, std::allocator<std::mutex>, (__gnu_cxx::_Lock_policy)2u>; __gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 18446744073709551615 / 56
   >>>;


;; Function void* __gnu_cxx::__aligned_buffer<_Tp>::_M_addr() [with _Tp = std::mutex] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (void *) &((struct __aligned_buffer *) this)->_M_storage
   >>>;


;; Function __gnu_cxx::new_allocator<_Tp>::size_type __gnu_cxx::new_allocator<_Tp>::max_size() const [with _Tp = std::_Sp_counted_ptr_inplace<std::__future_base::_State_baseV2, std::allocator<std::__future_base::_State_baseV2>, (__gnu_cxx::_Lock_policy)2u>; __gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 18446744073709551615 / 48
   >>>;


;; Function void* __gnu_cxx::__aligned_buffer<_Tp>::_M_addr() [with _Tp = std::__future_base::_State_baseV2] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (void *) &((struct __aligned_buffer *) this)->_M_storage
   >>>;


;; Function __gnu_cxx::new_allocator<_Tp>::new_allocator() [with _Tp = std::_Sp_counted_ptr_inplace<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, std::allocator<int>, (__gnu_cxx::_Lock_policy)2u>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    
  }
   >>>;


;; Function __gnu_cxx::new_allocator<_Tp>::~new_allocator() [with _Tp = std::_Sp_counted_ptr_inplace<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, std::allocator<int>, (__gnu_cxx::_Lock_policy)2u>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    
  }
  <D.117256>:;
   >>>;


;; Function static _Tp* std::allocator_traits<std::allocator<_CharT> >::allocate(std::allocator_traits<std::allocator<_CharT> >::allocator_type&, std::allocator_traits<std::allocator<_CharT> >::size_type) [with _Tp = std::_Sp_counted_ptr_inplace<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, std::allocator<int>, (__gnu_cxx::_Lock_policy)2u>; std::allocator_traits<std::allocator<_CharT> >::pointer = std::_Sp_counted_ptr_inplace<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, std::allocator<int>, (__gnu_cxx::_Lock_policy)2u>*; std::allocator_traits<std::allocator<_CharT> >::allocator_type = std::allocator<std::_Sp_counted_ptr_inplace<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, std::allocator<int>, (__gnu_cxx::_Lock_policy)2u> >; std::allocator_traits<std::allocator<_CharT> >::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (struct _Sp_counted_ptr_inplace *) __gnu_cxx::new_allocator<std::_Sp_counted_ptr_inplace<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, std::allocator<int>, (__gnu_cxx::_Lock_policy)2u> >::allocate ((struct new_allocator *) (struct allocator_type *) __a, __n, 0B)>>;


;; Function std::__allocated_ptr<_Alloc>::__allocated_ptr(_Alloc&, std::__allocated_ptr<_Alloc>::pointer) [with _Alloc = std::allocator<std::_Sp_counted_ptr_inplace<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, std::allocator<int>, (__gnu_cxx::_Lock_policy)2u> >; std::__allocated_ptr<_Alloc>::pointer = std::_Sp_counted_ptr_inplace<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, std::allocator<int>, (__gnu_cxx::_Lock_policy)2u>*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __allocated_ptr *) this)->_M_alloc = (struct allocator *) __a) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __allocated_ptr *) this)->_M_ptr = __ptr) >>>>>;
  }
   >>>;


;; Function static void std::allocator_traits<std::allocator<_CharT> >::deallocate(std::allocator_traits<std::allocator<_CharT> >::allocator_type&, std::allocator_traits<std::allocator<_CharT> >::pointer, std::allocator_traits<std::allocator<_CharT> >::size_type) [with _Tp = std::_Sp_counted_ptr_inplace<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, std::allocator<int>, (__gnu_cxx::_Lock_policy)2u>; std::allocator_traits<std::allocator<_CharT> >::allocator_type = std::allocator<std::_Sp_counted_ptr_inplace<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, std::allocator<int>, (__gnu_cxx::_Lock_policy)2u> >; std::allocator_traits<std::allocator<_CharT> >::pointer = std::_Sp_counted_ptr_inplace<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, std::allocator<int>, (__gnu_cxx::_Lock_policy)2u>*; std::allocator_traits<std::allocator<_CharT> >::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<std::_Sp_counted_ptr_inplace<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, std::allocator<int>, (__gnu_cxx::_Lock_policy)2u> >::deallocate ((struct new_allocator *) (struct allocator_type *) __a, __p, __n) >>>>>;


;; Function std::__allocated_ptr<_Alloc>::value_type* std::__allocated_ptr<_Alloc>::_S_raw_ptr(std::__allocated_ptr<_Alloc>::value_type*) [with _Alloc = std::allocator<std::_Sp_counted_ptr_inplace<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, std::allocator<int>, (__gnu_cxx::_Lock_policy)2u> >; std::__allocated_ptr<_Alloc>::value_type = std::_Sp_counted_ptr_inplace<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, std::allocator<int>, (__gnu_cxx::_Lock_policy)2u>] (null)
;; enabled by -tree-original


return <retval> = __ptr;


;; Function __gnu_cxx::new_allocator<_Tp>::new_allocator(const __gnu_cxx::new_allocator<_Tp>&) [with _Tp = int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    
  }
   >>>;


;; Function constexpr std::aligned_storage<48ul, 8ul>::aligned_storage() (null)
;; enabled by -tree-original


{
  
}


;; Function __gnu_cxx::__aligned_buffer<_Tp>::__aligned_buffer() [with _Tp = std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::aligned_storage<48ul, 8ul>::aligned_storage ((struct aligned_storage *) this) >>>>>;
}


;; Function std::_Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp>::_Impl::_Impl(_Alloc) [with _Tp = std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>; _Alloc = std::allocator<int>; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Sp_ebo_helper<0, std::allocator<int>, true>::_Sp_ebo_helper ((struct _Sp_ebo_helper *) this, (const struct allocator &) (const struct allocator *) (struct allocator *) __a) >>>>>;
    try
      {
        <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::__aligned_buffer<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)> >::__aligned_buffer (&((struct _Impl *) this)->_M_storage) >>>>>;
      }
    catch
      {
        std::_Sp_ebo_helper<0, std::allocator<int>, true>::~_Sp_ebo_helper ((struct _Sp_ebo_helper *) this);
      }
  }
   >>>;


;; Function _Tp* std::_Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp>::_M_ptr() [with _Tp = std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>; _Alloc = std::allocator<int>; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = __gnu_cxx::__aligned_buffer<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)> >::_M_ptr (&((struct _Sp_counted_ptr_inplace *) this)->_M_impl._M_storage)>>
   >>>;


;; Function static void std::allocator_traits<std::allocator<_CharT> >::construct(std::allocator_traits<std::allocator<_CharT> >::allocator_type&, _Up*, _Args&& ...) [with _Up = std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>; _Args = {long int (&)(int, int), const std::allocator<int>&}; _Tp = int; std::allocator_traits<std::allocator<_CharT> >::allocator_type = std::allocator<int>] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<int>::construct<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, long int (&)(int, int), const std::allocator<int>&> ((struct new_allocator *) (struct allocator_type *) __a, __p, (long int (&<T105d3>) (int, int)) (long int (*<T105d2>) (int, int)) std::forward<long int (&)(int, int)> ((long int (&<T15f36>) (int, int)) (long int (*<T105d2>) (int, int)) __args#0), (const struct allocator &) (const struct allocator *) std::forward<const std::allocator<int>&> ((const struct type &) (const struct allocator *) __args#1)) >>>>>;


;; Function std::move_iterator<_Iterator>::iterator_type std::move_iterator<_Iterator>::base() const [with _Iterator = std::packaged_task<long int(int, int)>*; std::move_iterator<_Iterator>::iterator_type = std::packaged_task<long int(int, int)>*] (null)
;; enabled by -tree-original


return <retval> = (struct packaged_task *) ((const struct move_iterator *) this)->_M_current;


;; Function std::move_iterator<_Iterator>::iterator_type std::move_iterator<_Iterator>::base() const [with _Iterator = std::future<long int>*; std::move_iterator<_Iterator>::iterator_type = std::future<long int>*] (null)
;; enabled by -tree-original


return <retval> = (struct future *) ((const struct move_iterator *) this)->_M_current;


;; Function __gnu_cxx::new_allocator<_Tp>::new_allocator() [with _Tp = std::_Sp_counted_ptr_inplace<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >, std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >, (__gnu_cxx::_Lock_policy)2u>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    
  }
   >>>;


;; Function __gnu_cxx::new_allocator<_Tp>::~new_allocator() [with _Tp = std::_Sp_counted_ptr_inplace<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >, std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >, (__gnu_cxx::_Lock_policy)2u>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    
  }
  <D.117293>:;
   >>>;


;; Function static _Tp* std::allocator_traits<std::allocator<_CharT> >::allocate(std::allocator_traits<std::allocator<_CharT> >::allocator_type&, std::allocator_traits<std::allocator<_CharT> >::size_type) [with _Tp = std::_Sp_counted_ptr_inplace<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >, std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >, (__gnu_cxx::_Lock_policy)2u>; std::allocator_traits<std::allocator<_CharT> >::pointer = std::_Sp_counted_ptr_inplace<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >, std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >, (__gnu_cxx::_Lock_policy)2u>*; std::allocator_traits<std::allocator<_CharT> >::allocator_type = std::allocator<std::_Sp_counted_ptr_inplace<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >, std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >, (__gnu_cxx::_Lock_policy)2u> >; std::allocator_traits<std::allocator<_CharT> >::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (struct _Sp_counted_ptr_inplace *) __gnu_cxx::new_allocator<std::_Sp_counted_ptr_inplace<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >, std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >, (__gnu_cxx::_Lock_policy)2u> >::allocate ((struct new_allocator *) (struct allocator_type *) __a, __n, 0B)>>;


;; Function std::__allocated_ptr<_Alloc>::__allocated_ptr(_Alloc&, std::__allocated_ptr<_Alloc>::pointer) [with _Alloc = std::allocator<std::_Sp_counted_ptr_inplace<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >, std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >, (__gnu_cxx::_Lock_policy)2u> >; std::__allocated_ptr<_Alloc>::pointer = std::_Sp_counted_ptr_inplace<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >, std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >, (__gnu_cxx::_Lock_policy)2u>*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __allocated_ptr *) this)->_M_alloc = (struct allocator *) __a) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __allocated_ptr *) this)->_M_ptr = __ptr) >>>>>;
  }
   >>>;


;; Function static void std::allocator_traits<std::allocator<_CharT> >::deallocate(std::allocator_traits<std::allocator<_CharT> >::allocator_type&, std::allocator_traits<std::allocator<_CharT> >::pointer, std::allocator_traits<std::allocator<_CharT> >::size_type) [with _Tp = std::_Sp_counted_ptr_inplace<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >, std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >, (__gnu_cxx::_Lock_policy)2u>; std::allocator_traits<std::allocator<_CharT> >::allocator_type = std::allocator<std::_Sp_counted_ptr_inplace<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >, std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >, (__gnu_cxx::_Lock_policy)2u> >; std::allocator_traits<std::allocator<_CharT> >::pointer = std::_Sp_counted_ptr_inplace<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >, std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >, (__gnu_cxx::_Lock_policy)2u>*; std::allocator_traits<std::allocator<_CharT> >::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<std::_Sp_counted_ptr_inplace<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >, std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >, (__gnu_cxx::_Lock_policy)2u> >::deallocate ((struct new_allocator *) (struct allocator_type *) __a, __p, __n) >>>>>;


;; Function std::__allocated_ptr<_Alloc>::value_type* std::__allocated_ptr<_Alloc>::_S_raw_ptr(std::__allocated_ptr<_Alloc>::value_type*) [with _Alloc = std::allocator<std::_Sp_counted_ptr_inplace<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >, std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >, (__gnu_cxx::_Lock_policy)2u> >; std::__allocated_ptr<_Alloc>::value_type = std::_Sp_counted_ptr_inplace<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >, std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >, (__gnu_cxx::_Lock_policy)2u>] (null)
;; enabled by -tree-original


return <retval> = __ptr;


;; Function __gnu_cxx::new_allocator<_Tp>::new_allocator(const __gnu_cxx::new_allocator<_Tp>&) [with _Tp = std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    
  }
   >>>;


;; Function __gnu_cxx::__aligned_buffer<_Tp>::__aligned_buffer() [with _Tp = std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::aligned_storage<48ul, 8ul>::aligned_storage ((struct aligned_storage *) this) >>>>>;
}


;; Function std::_Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp>::_Impl::_Impl(_Alloc) [with _Tp = std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >; _Alloc = std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Sp_ebo_helper<0, std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >, true>::_Sp_ebo_helper ((struct _Sp_ebo_helper *) this, (const struct allocator &) (const struct allocator *) (struct allocator *) __a) >>>>>;
    try
      {
        <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::__aligned_buffer<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >::__aligned_buffer (&((struct _Impl *) this)->_M_storage) >>>>>;
      }
    catch
      {
        std::_Sp_ebo_helper<0, std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >, true>::~_Sp_ebo_helper ((struct _Sp_ebo_helper *) this);
      }
  }
   >>>;


;; Function _Tp* std::_Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp>::_M_ptr() [with _Tp = std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >; _Alloc = std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = __gnu_cxx::__aligned_buffer<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >::_M_ptr (&((struct _Sp_counted_ptr_inplace *) this)->_M_impl._M_storage)>>
   >>>;


;; Function static void std::allocator_traits<std::allocator<_CharT> >::construct(std::allocator_traits<std::allocator<_CharT> >::allocator_type&, _Up*, _Args&& ...) [with _Up = std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >; _Args = {std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)>}; _Tp = std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >; std::allocator_traits<std::allocator<_CharT> >::allocator_type = std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >::construct<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >, std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > ((struct new_allocator *) (struct allocator_type *) __a, __p, (struct _Bind_simple &) (struct _Bind_simple *) std::forward<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > ((struct type &) (struct _Bind_simple *) __args#0)) >>>>>;


;; Function typename std::_Miter_base<_Iterator>::iterator_type std::__miter_base(_Iterator) [with _Iterator = std::move_iterator<std::thread**>; typename std::_Miter_base<_Iterator>::iterator_type = std::thread**] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = std::_Iter_base<std::move_iterator<std::thread**>, true>::_S_base (TARGET_EXPR <D.117321, __it>)>>;


;; Function _OI std::__copy_move_a2(_II, _II, _OI) [with bool _IsMove = true; _II = std::thread**; _OI = std::thread**] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = std::__copy_move_a<true, std::thread**, std::thread**> (std::__niter_base<std::thread**> (__first), std::__niter_base<std::thread**> (__last), std::__niter_base<std::thread**> (__result))>>;


;; Function _Tp* __gnu_cxx::new_allocator<_Tp>::allocate(__gnu_cxx::new_allocator<_Tp>::size_type, const void*) [with _Tp = std::_Sp_counted_ptr_inplace<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, std::allocator<int>, (__gnu_cxx::_Lock_policy)2u>; __gnu_cxx::new_allocator<_Tp>::pointer = std::_Sp_counted_ptr_inplace<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, std::allocator<int>, (__gnu_cxx::_Lock_policy)2u>*; __gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int] (null)
;; enabled by -tree-original


if (<<cleanup_point __gnu_cxx::new_allocator<std::_Sp_counted_ptr_inplace<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, std::allocator<int>, (__gnu_cxx::_Lock_policy)2u> >::max_size (this) < __n>>)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_bad_alloc () >>>>>;
  }
<<cleanup_point return <retval> = (struct _Sp_counted_ptr_inplace *) operator new (64 * __n)>>;


;; Function void __gnu_cxx::new_allocator<_Tp>::deallocate(__gnu_cxx::new_allocator<_Tp>::pointer, __gnu_cxx::new_allocator<_Tp>::size_type) [with _Tp = std::_Sp_counted_ptr_inplace<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, std::allocator<int>, (__gnu_cxx::_Lock_policy)2u>; __gnu_cxx::new_allocator<_Tp>::pointer = std::_Sp_counted_ptr_inplace<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, std::allocator<int>, (__gnu_cxx::_Lock_policy)2u>*; __gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  operator delete ((void *) __p) >>>>>;


;; Function std::_Sp_ebo_helper<_Nm, _Tp, true>::_Sp_ebo_helper(const _Tp&) [with int _Nm = 0; _Tp = std::allocator<int>] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator<int>::allocator ((struct allocator *) this, (const struct allocator &) (const struct allocator *) __tp) >>>>>;
  try
    {
      
    }
  catch
    {
      std::allocator<int>::~allocator ((struct allocator *) this);
    }
}


;; Function _Tp* __gnu_cxx::__aligned_buffer<_Tp>::_M_ptr() [with _Tp = std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct _Task_state *) __gnu_cxx::__aligned_buffer<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)> >::_M_addr (this)>>
   >>>;


;; Function void __gnu_cxx::new_allocator<_Tp>::construct(_Up*, _Args&& ...) [with _Up = std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>; _Args = {long int (&)(int, int), const std::allocator<int>&}; _Tp = int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (TARGET_EXPR <D.117498, (long int (&<T105d3>) (int, int)) (long int (*<T105d2>) (int, int)) std::forward<long int (&)(int, int)> ((long int (&<T15f36>) (int, int)) (long int (*<T105d2>) (int, int)) __args#0)>;, TARGET_EXPR <D.117499, (const struct allocator &) (const struct allocator *) std::forward<const std::allocator<int>&> ((const struct type &) (const struct allocator *) __args#1)>;;, TARGET_EXPR <D.117350, (void *) __p>;, TARGET_EXPR <D.117351, operator new (48, NON_LVALUE_EXPR <D.117350>)>;;, (struct _Task_state *) D.117351 != 0B ? try
    {
      std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>::_Task_state<long int (&)(int, int)> ((struct _Task_state *) D.117351, NON_LVALUE_EXPR <D.117498>, NON_LVALUE_EXPR <D.117499>);
    }
  catch
    {
      operator delete (D.117351, NON_LVALUE_EXPR <D.117350>);
    }, (struct _Task_state *) D.117351; : (struct _Task_state *) D.117351;) >>>>>;


;; Function _Tp* __gnu_cxx::new_allocator<_Tp>::allocate(__gnu_cxx::new_allocator<_Tp>::size_type, const void*) [with _Tp = std::_Sp_counted_ptr_inplace<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >, std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >, (__gnu_cxx::_Lock_policy)2u>; __gnu_cxx::new_allocator<_Tp>::pointer = std::_Sp_counted_ptr_inplace<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >, std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >, (__gnu_cxx::_Lock_policy)2u>*; __gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int] (null)
;; enabled by -tree-original


if (<<cleanup_point __gnu_cxx::new_allocator<std::_Sp_counted_ptr_inplace<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >, std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >, (__gnu_cxx::_Lock_policy)2u> >::max_size (this) < __n>>)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_bad_alloc () >>>>>;
  }
<<cleanup_point return <retval> = (struct _Sp_counted_ptr_inplace *) operator new (64 * __n)>>;


;; Function void __gnu_cxx::new_allocator<_Tp>::deallocate(__gnu_cxx::new_allocator<_Tp>::pointer, __gnu_cxx::new_allocator<_Tp>::size_type) [with _Tp = std::_Sp_counted_ptr_inplace<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >, std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >, (__gnu_cxx::_Lock_policy)2u>; __gnu_cxx::new_allocator<_Tp>::pointer = std::_Sp_counted_ptr_inplace<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >, std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >, (__gnu_cxx::_Lock_policy)2u>*; __gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  operator delete ((void *) __p) >>>>>;


;; Function std::_Sp_ebo_helper<_Nm, _Tp, true>::_Sp_ebo_helper(const _Tp&) [with int _Nm = 0; _Tp = std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >::allocator ((struct allocator *) this, (const struct allocator &) (const struct allocator *) __tp) >>>>>;
  try
    {
      
    }
  catch
    {
      std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >::~allocator ((struct allocator *) this);
    }
}


;; Function _Tp* __gnu_cxx::__aligned_buffer<_Tp>::_M_ptr() [with _Tp = std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct _Impl *) __gnu_cxx::__aligned_buffer<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >::_M_addr (this)>>
   >>>;


;; Function void __gnu_cxx::new_allocator<_Tp>::construct(_Up*, _Args&& ...) [with _Up = std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >; _Args = {std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)>}; _Tp = std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (TARGET_EXPR <D.117554, (struct _Bind_simple &) (struct _Bind_simple *) std::forward<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > ((struct type &) (struct _Bind_simple *) __args#0)>;, TARGET_EXPR <D.117507, (void *) __p>;, TARGET_EXPR <D.117508, operator new (48, NON_LVALUE_EXPR <D.117507>)>;;, (struct _Impl *) D.117508 != 0B ? try
    {
      std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >::_Impl ((struct _Impl *) D.117508, NON_LVALUE_EXPR <D.117554>);
    }
  catch
    {
      operator delete (D.117508, NON_LVALUE_EXPR <D.117507>);
    }, (struct _Impl *) D.117508; : (struct _Impl *) D.117508;) >>>>>;


;; Function static std::_Iter_base<_Iterator, true>::iterator_type std::_Iter_base<_Iterator, true>::_S_base(_Iterator) [with _Iterator = std::move_iterator<std::thread**>; std::_Iter_base<_Iterator, true>::iterator_type = std::thread**] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (struct thread * *) std::move_iterator<std::thread**>::base (&__it)>>;


;; Function typename std::_Niter_base<_Iterator>::iterator_type std::__niter_base(_Iterator) [with _Iterator = std::thread**; typename std::_Niter_base<_Iterator>::iterator_type = std::thread**] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = std::_Iter_base<std::thread**, false>::_S_base (__it)>>;


;; Function _OI std::__copy_move_a(_II, _II, _OI) [with bool _IsMove = true; _II = std::thread**; _OI = std::thread**] (null)
;; enabled by -tree-original


{
  typedef struct thread * _ValueTypeI;
  typedef struct thread * _ValueTypeO;
  typedef struct _Category _Category;
  const bool __simple = 1;

  <<cleanup_point   const bool __simple = 1;>>;
  <<cleanup_point return <retval> = std::__copy_move<true, true, std::random_access_iterator_tag>::__copy_m<std::thread*> ((struct thread * const *) __first, (struct thread * const *) __last, __result)>>;
}


;; Function __gnu_cxx::new_allocator<_Tp>::size_type __gnu_cxx::new_allocator<_Tp>::max_size() const [with _Tp = std::_Sp_counted_ptr_inplace<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, std::allocator<int>, (__gnu_cxx::_Lock_policy)2u>; __gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 18446744073709551615 / 64
   >>>;


;; Function void* __gnu_cxx::__aligned_buffer<_Tp>::_M_addr() [with _Tp = std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (void *) &((struct __aligned_buffer *) this)->_M_storage
   >>>;


;; Function virtual std::__future_base::_State_baseV2::~_State_baseV2() (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _State_baseV2 *) this)->_vptr._State_baseV2 = &_ZTVNSt13__future_base13_State_baseV2E + 16) >>>>>;
  try
    {
      try
        {
          
        }
      finally
        {
          std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>::~unique_ptr (&((struct _State_baseV2 *) this)->_M_result);
        }
    }
  finally
    {
      *(struct 
      {
        int (*__vtbl_ptr_type) () * _vptr._State_baseV2;
        struct _Ptr_type _M_result;
        struct __atomic_futex_unsigned _M_status;
        struct atomic_flag _M_retrieved;
        struct once_flag _M_once;
      } &) this = {CLOBBER};
    }
}
<D.117611>:;
if ((__in_chrg & 1) != 0)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  operator delete ((void *) this, 32) >>>>>;
  }


;; Function virtual std::__future_base::_Task_state_base<long int(int, int)>::~_Task_state_base() (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Task_state_base *) this)->D.98645._vptr._State_baseV2 = &_ZTVNSt13__future_base16_Task_state_baseIFliiEEE + 16) >>>>>;
  try
    {
      try
        {
          try
            {
              
            }
          finally
            {
              std::unique_ptr<std::__future_base::_Result<long int>, std::__future_base::_Result_base::_Deleter>::~unique_ptr (&((struct _Task_state_base *) this)->_M_result);
            }
        }
      finally
        {
          std::__future_base::_State_baseV2::~_State_baseV2 (&((struct _Task_state_base *) this)->D.98645);
        }
    }
  finally
    {
      *(struct 
      {
        struct 
        {
          int (*__vtbl_ptr_type) () * _vptr._State_baseV2;
          struct _Ptr_type _M_result;
          struct __atomic_futex_unsigned _M_status;
          struct atomic_flag _M_retrieved;
          struct once_flag _M_once;
        } D.98646;
        struct _Ptr_type _M_result;
      } &) this = {CLOBBER};
    }
}
<D.117609>:;
if ((__in_chrg & 1) != 0)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  operator delete ((void *) this, 40) >>>>>;
  }


;; Function std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>::_Impl::~_Impl() (null)
;; enabled by -tree-original


{
  try
    {
      try
        {
          
        }
      finally
        {
          std::allocator<int>::~allocator ((struct allocator *) this);
        }
    }
  finally
    {
      *(struct 
      {
        long int (*<T105d2>) (int, int) _M_fn;
      } &) this = {CLOBBER};
    }
}
<D.117639>:;


;; Function std::__future_base::_Task_state<_Fn, _Alloc, _Res(_Args ...)>::_Task_state(_Fn2&&, const _Alloc&) [with _Fn2 = long int (&)(int, int); _Fn = long int (*)(int, int); _Alloc = std::allocator<int>; _Res = long int; _Args = {int, int}] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__future_base::_Task_state_base<long int(int, int)>::_Task_state_base<std::allocator<int> > (&((struct _Task_state *) this)->D.109886, (const struct allocator &) (const struct allocator *) __a) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Task_state *) this)->D.109886.D.98645._vptr._State_baseV2 = &_ZTVNSt13__future_base11_Task_stateIPFliiESaIiES1_EE + 16) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>::_Impl::_Impl<long int (&)(int, int)> (&((struct _Task_state *) this)->_M_impl, (long int (&<T105d3>) (int, int)) (long int (*<T105d2>) (int, int)) std::forward<long int (&)(int, int)> ((long int (&<T15f36>) (int, int)) (long int (*<T105d2>) (int, int)) __fn), (const struct allocator &) (const struct allocator *) __a) >>>>>;
      try
        {
          
        }
      catch
        {
          std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>::_Impl::~_Impl (&((struct _Task_state *) this)->_M_impl);
        }
    }
  catch
    {
      std::__future_base::_Task_state_base<long int(int, int)>::~_Task_state_base (&((struct _Task_state *) this)->D.109886);
    }
}


;; Function __gnu_cxx::new_allocator<_Tp>::size_type __gnu_cxx::new_allocator<_Tp>::max_size() const [with _Tp = std::_Sp_counted_ptr_inplace<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >, std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >, (__gnu_cxx::_Lock_policy)2u>; __gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 18446744073709551615 / 64
   >>>;


;; Function void* __gnu_cxx::__aligned_buffer<_Tp>::_M_addr() [with _Tp = std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (void *) &((struct __aligned_buffer *) this)->_M_storage
   >>>;


;; Function constexpr std::__shared_ptr<_Tp, _Lp>::__shared_ptr() [with _Tp = std::thread::_Impl_base; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __shared_ptr *) this)->_M_ptr = 0B) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __shared_ptr *) this)->_M_refcount = <<< Unknown tree: aggr_init_expr
  4
  __comp_ctor 
  D.117653
  (struct __shared_count *) <<< Unknown tree: void_cst >>> >>>) >>>>>;
    try
      {
        
      }
    catch
      {
        std::__shared_count<>::~__shared_count (&((struct __shared_ptr *) this)->_M_refcount);
      }
  }
   >>>;


;; Function constexpr std::shared_ptr<_Tp>::shared_ptr() [with _Tp = std::thread::_Impl_base] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__shared_ptr<std::thread::_Impl_base, (__gnu_cxx::_Lock_policy)2u>::__shared_ptr (&((struct shared_ptr *) this)->D.52702) >>>>>;
    try
      {
        
      }
    catch
      {
        std::__shared_ptr<std::thread::_Impl_base, (__gnu_cxx::_Lock_policy)2u>::~__shared_ptr (&((struct shared_ptr *) this)->D.52702);
      }
  }
   >>>;


;; Function constexpr std::thread::_Impl_base::_Impl_base() (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Impl_base *) this)->_vptr._Impl_base = &_ZTVNSt6thread10_Impl_baseE + 16) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::shared_ptr<std::thread::_Impl_base>::shared_ptr (&((struct _Impl_base *) this)->_M_this_ptr) >>>>>;
  try
    {
      
    }
  catch
    {
      std::shared_ptr<std::thread::_Impl_base>::~shared_ptr (&((struct _Impl_base *) this)->_M_this_ptr);
    }
}


;; Function std::thread::_Impl<_Callable>::_Impl(_Callable&&) [with _Callable = std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)>] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::thread::_Impl_base::_Impl_base (&((struct _Impl *) this)->D.103772) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Impl *) this)->D.103772._vptr._Impl_base = &_ZTVNSt6thread5_ImplISt12_Bind_simpleIFSt13packaged_taskIFliiEEiiEEEE + 16) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)>::_Bind_simple (&((struct _Impl *) this)->_M_func, (struct _Bind_simple &) (struct _Bind_simple *) std::forward<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > ((struct type &) (struct _Bind_simple *) __f)) >>>>>;
      try
        {
          
        }
      catch
        {
          std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)>::~_Bind_simple (&((struct _Impl *) this)->_M_func);
        }
    }
  catch
    {
      std::thread::_Impl_base::~_Impl_base (&((struct _Impl *) this)->D.103772);
    }
}


;; Function std::move_iterator<_Iterator>::iterator_type std::move_iterator<_Iterator>::base() const [with _Iterator = std::thread**; std::move_iterator<_Iterator>::iterator_type = std::thread**] (null)
;; enabled by -tree-original


return <retval> = (struct thread * *) ((const struct move_iterator *) this)->_M_current;


;; Function static std::_Iter_base<_Iterator, _HasBase>::iterator_type std::_Iter_base<_Iterator, _HasBase>::_S_base(_Iterator) [with _Iterator = std::thread**; bool _HasBase = false; std::_Iter_base<_Iterator, _HasBase>::iterator_type = std::thread**] (null)
;; enabled by -tree-original


return <retval> = (struct thread * *) __it;


;; Function static _Tp* std::__copy_move<_IsMove, true, std::random_access_iterator_tag>::__copy_m(const _Tp*, const _Tp*, _Tp*) [with _Tp = std::thread*; bool _IsMove = true] (null)
;; enabled by -tree-original


{
  const ptrdiff_t _Num = ((long int) __last - (long int) __first) /[ex] 8;

    const ptrdiff_t _Num = ((long int) __last - (long int) __first) /[ex] 8;
  if ((long int) _Num != 0)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) __builtin_memmove ((void *) __result, (const void *) __first, 8 * (long unsigned int) _Num) >>>>>;
    }
  return <retval> = __result + (sizetype) ((long unsigned int) _Num * 8);
}


;; Function std::__future_base::_Task_state_base<_Res(_Args ...)>::_Task_state_base(const _Alloc&) [with _Alloc = std::allocator<int>; _Res = long int; _Args = {int, int}] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__future_base::_State_baseV2::_State_baseV2 (&((struct _Task_state_base *) this)->D.98645) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Task_state_base *) this)->D.98645._vptr._State_baseV2 = &_ZTVNSt13__future_base16_Task_state_baseIFliiEEE + 16) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Task_state_base *) this)->_M_result = TARGET_EXPR <D.117758, <<< Unknown tree: aggr_init_expr
  4
  _S_allocate_result
  D.117758
  (const struct allocator &) (const struct allocator *) __a >>>>) >>>>>;
      try
        {
          
        }
      catch
        {
          std::unique_ptr<std::__future_base::_Result<long int>, std::__future_base::_Result_base::_Deleter>::~unique_ptr (&((struct _Task_state_base *) this)->_M_result);
        }
    }
  catch
    {
      std::__future_base::_State_baseV2::~_State_baseV2 (&((struct _Task_state_base *) this)->D.98645);
    }
}


;; Function std::unique_ptr<_Tp, _Dp>::~unique_ptr() [with _Tp = std::__future_base::_Result<long int>; _Dp = std::__future_base::_Result_base::_Deleter] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    try
      {
        {
          struct _Result * & __ptr;

                    struct _Result * & __ptr;
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__ptr = (struct _Result * &) (struct _Result * *) std::get<0ul, std::__future_base::_Result<long int>*, std::__future_base::_Result_base::_Deleter> ((struct tuple &) &((struct unique_ptr *) this)->_M_t)) >>>>>;
          if (*__ptr != 0B)
            {
              <<cleanup_point <<< Unknown tree: expr_stmt
  std::__future_base::_Result_base::_Deleter::operator() ((struct deleter_type *) std::unique_ptr<std::__future_base::_Result<long int>, std::__future_base::_Result_base::_Deleter>::get_deleter (this), (struct _Result_base *) *__ptr) >>>>>;
            }
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__ptr = 0B) >>>>>;
        }
      }
    finally
      {
        *(struct 
        {
          struct __tuple_type _M_t;
        } &) this = {CLOBBER};
      }
  }
  <D.117763>:;
   >>>;


;; Function std::__future_base::_Task_state<_Fn, _Alloc, _Res(_Args ...)>::_Impl::_Impl(_Fn2&&, const _Alloc&) [with _Fn2 = long int (&)(int, int); _Fn = long int (*)(int, int); _Alloc = std::allocator<int>; _Res = long int; _Args = {int, int}] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator<int>::allocator ((struct allocator *) this, (const struct allocator &) (const struct allocator *) __a) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Impl *) this)->_M_fn = (long int (*<T105d2>) (int, int)) std::forward<long int (&)(int, int)> ((long int (&<T15f36>) (int, int)) (long int (*<T105d2>) (int, int)) __fn)) >>>>>;
    }
  catch
    {
      std::allocator<int>::~allocator ((struct allocator *) this);
    }
}


;; Function static std::__future_base::_Ptr<std::__future_base::_Result<_Res> > std::__future_base::_S_allocate_result(const std::allocator<_T2>&) [with _Res = long int; _Tp = int; std::__future_base::_Ptr<std::__future_base::_Result<_Res> > = std::unique_ptr<std::__future_base::_Result<long int>, std::__future_base::_Result_base::_Deleter>] (null)
;; enabled by -tree-original


<<cleanup_point return *<retval> = TARGET_EXPR <D.117813, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.117813
  (struct unique_ptr *) <<< Unknown tree: void_cst >>>
  TARGET_EXPR <D.117785, operator new (32)>;, try
    {
      std::__future_base::_Result<long int>::_Result ((struct _Result *) D.117785);
    }
  catch
    {
      operator delete (D.117785, 32);
    }, (struct _Result *) D.117785; >>>>>>;


;; Function constexpr std::_Head_base<_Idx, _Head, false>::_Head_base(_UHead&&) [with _UHead = std::__future_base::_Result<long int>*; long unsigned int _Idx = 0ul; _Head = std::__future_base::_Result<long int>*] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Head_base *) this)->_M_head_impl = *std::forward<std::__future_base::_Result<long int>*> ((struct _Result * &) (struct _Result * *) __h)) >>>>>;
}


;; Function constexpr std::_Tuple_impl<_Idx, _Head, _Tail ...>::_Tuple_impl(_UHead&&, _UTail&& ...) [with _UHead = std::__future_base::_Result<long int>*; _UTail = {std::__future_base::_Result_base::_Deleter}; <template-parameter-2-3> = void; long unsigned int _Idx = 0ul; _Head = std::__future_base::_Result<long int>*; _Tail = {std::__future_base::_Result_base::_Deleter}] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Tuple_impl<1ul, std::__future_base::_Result_base::_Deleter>::_Tuple_impl<std::__future_base::_Result_base::_Deleter> ((struct _Tuple_impl *) this, (struct _Deleter &) (struct _Deleter *) std::forward<std::__future_base::_Result_base::_Deleter> ((struct type &) (struct _Deleter *) __tail#0)) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Head_base<0ul, std::__future_base::_Result<long int>*, false>::_Head_base<std::__future_base::_Result<long int>*> (&((struct _Tuple_impl *) this)->D.97692, (struct _Result * &) (struct _Result * *) std::forward<std::__future_base::_Result<long int>*> ((struct _Result * &) (struct _Result * *) __head)) >>>>>;
}


;; Function constexpr std::tuple<_T1, _T2>::tuple(_U1&&, _U2&&) [with _U1 = std::__future_base::_Result<long int>*; _U2 = std::__future_base::_Result_base::_Deleter; <template-parameter-2-3> = void; _T1 = std::__future_base::_Result<long int>*; _T2 = std::__future_base::_Result_base::_Deleter] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Tuple_impl<0ul, std::__future_base::_Result<long int>*, std::__future_base::_Result_base::_Deleter>::_Tuple_impl<std::__future_base::_Result<long int>*, std::__future_base::_Result_base::_Deleter, void> (&((struct tuple *) this)->D.98360, (struct _Result * &) (struct _Result * *) std::forward<std::__future_base::_Result<long int>*> ((struct _Result * &) (struct _Result * *) __a1), (struct _Deleter &) (struct _Deleter *) std::forward<std::__future_base::_Result_base::_Deleter> ((struct type &) (struct _Deleter *) __a2)) >>>>>;
}


;; Function std::unique_ptr<_Tp, _Dp>::unique_ptr(std::unique_ptr<_Tp, _Dp>&&) [with _Tp = std::__future_base::_Result<long int>; _Dp = std::__future_base::_Result_base::_Deleter] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::tuple<std::__future_base::_Result<long int>*, std::__future_base::_Result_base::_Deleter>::tuple<std::__future_base::_Result<long int>*, std::__future_base::_Result_base::_Deleter, void> (&((struct unique_ptr *) this)->_M_t, (struct _Result * &) &TARGET_EXPR <D.117833, std::unique_ptr<std::__future_base::_Result<long int>, std::__future_base::_Result_base::_Deleter>::release ((struct unique_ptr *) __u)>, (struct _Deleter &) (struct _Deleter *) std::forward<std::__future_base::_Result_base::_Deleter> ((struct type &) (struct deleter_type *) std::unique_ptr<std::__future_base::_Result<long int>, std::__future_base::_Result_base::_Deleter>::get_deleter ((struct unique_ptr *) __u))) >>>>>;
  }
   >>>;


;; Function constexpr std::aligned_storage<8ul, 8ul>::aligned_storage() (null)
;; enabled by -tree-original


{
  
}


;; Function __gnu_cxx::__aligned_buffer<_Tp>::__aligned_buffer() [with _Tp = long int] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::aligned_storage<8ul, 8ul>::aligned_storage ((struct aligned_storage *) this) >>>>>;
}


;; Function std::__future_base::_Result<_Res>::_Result() [with _Res = long int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__future_base::_Result_base::_Result_base (&((struct _Result *) this)->D.98954) >>>>>;
    try
      {
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Result *) this)->D.98954._vptr._Result_base = &_ZTVNSt13__future_base7_ResultIlEE + 16) >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::__aligned_buffer<long int>::__aligned_buffer (&((struct _Result *) this)->_M_storage) >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Result *) this)->_M_initialized = 0) >>>>>;
      }
    catch
      {
        std::__future_base::_Result_base::~_Result_base (&((struct _Result *) this)->D.98954);
      }
  }
   >>>;


;; Function constexpr _Tp&& std::forward(typename std::remove_reference<_From>::type&) [with _Tp = std::__future_base::_Result<long int>*&; typename std::remove_reference<_From>::type = std::__future_base::_Result<long int>*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct _Result * &) (struct _Result * *) (struct _Result * &) (struct _Result * *) __t
   >>>;


;; Function constexpr std::_Head_base<_Idx, _Head, false>::_Head_base(_UHead&&) [with _UHead = std::__future_base::_Result<long int>*&; long unsigned int _Idx = 0ul; _Head = std::__future_base::_Result<long int>*] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Head_base *) this)->_M_head_impl = *std::forward<std::__future_base::_Result<long int>*&> ((struct _Result * &) (struct _Result * *) __h)) >>>>>;
}


;; Function constexpr std::_Tuple_impl<_Idx, _Head, _Tail ...>::_Tuple_impl(_UHead&&, _UTail&& ...) [with _UHead = std::__future_base::_Result<long int>*&; _UTail = {std::__future_base::_Result_base::_Deleter}; <template-parameter-2-3> = void; long unsigned int _Idx = 0ul; _Head = std::__future_base::_Result<long int>*; _Tail = {std::__future_base::_Result_base::_Deleter}] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Tuple_impl<1ul, std::__future_base::_Result_base::_Deleter>::_Tuple_impl<std::__future_base::_Result_base::_Deleter> ((struct _Tuple_impl *) this, (struct _Deleter &) (struct _Deleter *) std::forward<std::__future_base::_Result_base::_Deleter> ((struct type &) (struct _Deleter *) __tail#0)) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Head_base<0ul, std::__future_base::_Result<long int>*, false>::_Head_base<std::__future_base::_Result<long int>*&> (&((struct _Tuple_impl *) this)->D.97692, (struct _Result * &) (struct _Result * *) std::forward<std::__future_base::_Result<long int>*&> ((struct _Result * &) (struct _Result * *) __head)) >>>>>;
}


;; Function constexpr std::tuple<_T1, _T2>::tuple(_U1&&, _U2&&) [with _U1 = std::__future_base::_Result<long int>*&; _U2 = std::__future_base::_Result_base::_Deleter; <template-parameter-2-3> = void; _T1 = std::__future_base::_Result<long int>*; _T2 = std::__future_base::_Result_base::_Deleter] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Tuple_impl<0ul, std::__future_base::_Result<long int>*, std::__future_base::_Result_base::_Deleter>::_Tuple_impl<std::__future_base::_Result<long int>*&, std::__future_base::_Result_base::_Deleter, void> (&((struct tuple *) this)->D.98360, (struct _Result * &) (struct _Result * *) std::forward<std::__future_base::_Result<long int>*&> ((struct _Result * &) (struct _Result * *) __a1), (struct _Deleter &) (struct _Deleter *) std::forward<std::__future_base::_Result_base::_Deleter> ((struct type &) (struct _Deleter *) __a2)) >>>>>;
}


;; Function std::unique_ptr<_Tp, _Dp>::unique_ptr(std::unique_ptr<_Tp, _Dp>::pointer) [with _Tp = std::__future_base::_Result<long int>; _Dp = std::__future_base::_Result_base::_Deleter; std::unique_ptr<_Tp, _Dp>::pointer = std::__future_base::_Result<long int>*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::tuple<std::__future_base::_Result<long int>*, std::__future_base::_Result_base::_Deleter>::tuple<std::__future_base::_Result<long int>*&, std::__future_base::_Result_base::_Deleter, void> (&((struct unique_ptr *) this)->_M_t, (struct _Result * &) &__p, (struct _Deleter &) &TARGET_EXPR <D.117877, {}>) >>>>>;
  }
   >>>;


;; Function virtual std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>::~_Task_state() (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Task_state *) this)->D.109886.D.98645._vptr._State_baseV2 = &_ZTVNSt13__future_base11_Task_stateIPFliiESaIiES1_EE + 16) >>>>>;
  try
    {
      try
        {
          try
            {
              
            }
          finally
            {
              std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>::_Impl::~_Impl (&((struct _Task_state *) this)->_M_impl);
            }
        }
      finally
        {
          std::__future_base::_Task_state_base<long int(int, int)>::~_Task_state_base (&((struct _Task_state *) this)->D.109886);
        }
    }
  finally
    {
      *(struct 
      {
        struct 
        {
          struct 
          {
            int (*__vtbl_ptr_type) () * _vptr._State_baseV2;
            struct _Ptr_type _M_result;
            struct __atomic_futex_unsigned _M_status;
            struct atomic_flag _M_retrieved;
            struct once_flag _M_once;
          } D.98646;
          struct _Ptr_type _M_result;
        } D.109887;
        struct _Impl _M_impl;
      } &) this = {CLOBBER};
    }
}
<D.118044>:;
if ((__in_chrg & 1) != 0)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  operator delete ((void *) this, 48) >>>>>;
  }


;; Function virtual std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >::~_Impl() (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Impl *) this)->D.103772._vptr._Impl_base = &_ZTVNSt6thread5_ImplISt12_Bind_simpleIFSt13packaged_taskIFliiEEiiEEEE + 16) >>>>>;
  try
    {
      try
        {
          try
            {
              
            }
          finally
            {
              std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)>::~_Bind_simple (&((struct _Impl *) this)->_M_func);
            }
        }
      finally
        {
          std::thread::_Impl_base::~_Impl_base (&((struct _Impl *) this)->D.103772);
        }
    }
  finally
    {
      *(struct 
      {
        struct 
        {
          int (*__vtbl_ptr_type) () * _vptr._Impl_base;
          struct __shared_base_type _M_this_ptr;
        } D.103773;
        struct _Bind_simple _M_func;
      } &) this = {CLOBBER};
    }
}
<D.118053>:;
if ((__in_chrg & 1) != 0)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  operator delete ((void *) this, 48) >>>>>;
  }


;; Function virtual std::__future_base::_Result<void>::~_Result() (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Result *) this)->D.68681._vptr._Result_base = &_ZTVNSt13__future_base7_ResultIvEE + 16) >>>>>;
  try
    {
      try
        {
          
        }
      finally
        {
          std::__future_base::_Result_base::~_Result_base (&((struct _Result *) this)->D.68681);
        }
    }
  finally
    {
      *(struct 
      {
        struct 
        {
          int (*__vtbl_ptr_type) () * _vptr._Result_base;
          struct exception_ptr _M_error;
        } D.68682;
      } &) this = {CLOBBER};
    }
}
<D.118062>:;
if ((__in_chrg & 1) != 0)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  operator delete ((void *) this, 16) >>>>>;
  }


;; Function virtual __gnu_cxx::__concurrence_wait_error::~__concurrence_wait_error() (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __concurrence_wait_error *) this)->D.46416._vptr.exception = &_ZTVN9__gnu_cxx24__concurrence_wait_errorE + 16) >>>>>;
  try
    {
      try
        {
          
        }
      finally
        {
          std::exception::~exception (&((struct __concurrence_wait_error *) this)->D.46416);
        }
    }
  finally
    {
      *(struct 
      {
        struct 
        {
          int (*__vtbl_ptr_type) () * _vptr.exception;
        } D.46417;
      } &) this = {CLOBBER};
    }
}
<D.118071>:;
if ((__in_chrg & 1) != 0)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  operator delete ((void *) this, 8) >>>>>;
  }


;; Function virtual __gnu_cxx::__concurrence_broadcast_error::~__concurrence_broadcast_error() (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __concurrence_broadcast_error *) this)->D.46389._vptr.exception = &_ZTVN9__gnu_cxx29__concurrence_broadcast_errorE + 16) >>>>>;
  try
    {
      try
        {
          
        }
      finally
        {
          std::exception::~exception (&((struct __concurrence_broadcast_error *) this)->D.46389);
        }
    }
  finally
    {
      *(struct 
      {
        struct 
        {
          int (*__vtbl_ptr_type) () * _vptr.exception;
        } D.46390;
      } &) this = {CLOBBER};
    }
}
<D.118080>:;
if ((__in_chrg & 1) != 0)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  operator delete ((void *) this, 8) >>>>>;
  }


;; Function virtual __gnu_cxx::__concurrence_unlock_error::~__concurrence_unlock_error() (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __concurrence_unlock_error *) this)->D.46362._vptr.exception = &_ZTVN9__gnu_cxx26__concurrence_unlock_errorE + 16) >>>>>;
  try
    {
      try
        {
          
        }
      finally
        {
          std::exception::~exception (&((struct __concurrence_unlock_error *) this)->D.46362);
        }
    }
  finally
    {
      *(struct 
      {
        struct 
        {
          int (*__vtbl_ptr_type) () * _vptr.exception;
        } D.46363;
      } &) this = {CLOBBER};
    }
}
<D.118089>:;
if ((__in_chrg & 1) != 0)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  operator delete ((void *) this, 8) >>>>>;
  }


;; Function virtual __gnu_cxx::__concurrence_lock_error::~__concurrence_lock_error() (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __concurrence_lock_error *) this)->D.46335._vptr.exception = &_ZTVN9__gnu_cxx24__concurrence_lock_errorE + 16) >>>>>;
  try
    {
      try
        {
          
        }
      finally
        {
          std::exception::~exception (&((struct __concurrence_lock_error *) this)->D.46335);
        }
    }
  finally
    {
      *(struct 
      {
        struct 
        {
          int (*__vtbl_ptr_type) () * _vptr.exception;
        } D.46336;
      } &) this = {CLOBBER};
    }
}
<D.118098>:;
if ((__in_chrg & 1) != 0)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  operator delete ((void *) this, 8) >>>>>;
  }


;; Function void __static_initialization_and_destruction_0(int, int) (null)
;; enabled by -tree-original


if (__initialize_p == 1)
  {
    if (__priority == 65535)
      {
        <<cleanup_point <<< Unknown tree: expr_stmt
  std::ios_base::Init::Init (&__ioinit) >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) __cxa_atexit ((void (*<Tcd>) (void *)) __comp_dtor , (void *) &__ioinit, (void *) &__dso_handle) >>>>>;
      }
  }


;; Function std::_Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp>::~_Sp_counted_ptr_inplace() [with _Tp = std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >; _Alloc = std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Sp_counted_ptr_inplace *) this)->D.116402._vptr._Sp_counted_base = &_ZTVSt23_Sp_counted_ptr_inplaceINSt6thread5_ImplISt12_Bind_simpleIFSt13packaged_taskIFliiEEiiEEEESaIS8_ELN9__gnu_cxx12_Lock_policyE2EE + 16) >>>>>;
    try
      {
        try
          {
            try
              {
                
              }
            finally
              {
                std::_Sp_counted_ptr_inplace<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >, std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >, (__gnu_cxx::_Lock_policy)2u>::_Impl::~_Impl (&((struct _Sp_counted_ptr_inplace *) this)->_M_impl);
              }
          }
        finally
          {
            std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2u>::~_Sp_counted_base (&((struct _Sp_counted_ptr_inplace *) this)->D.116402);
          }
      }
    finally
      {
        *(struct 
        {
          struct 
          {
            int (*__vtbl_ptr_type) () * _vptr._Sp_counted_base;
            _Atomic_word _M_use_count;
            _Atomic_word _M_weak_count;
          } D.116403;
          struct _Impl _M_impl;
        } &) this = {CLOBBER};
      }
  }
  <D.118138>:;
  if ((__in_chrg & 1) != 0)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  operator delete ((void *) this, 64) >>>>>;
    }
   >>>;


;; Function void std::_Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp>::_M_dispose() [with _Tp = std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >; _Alloc = std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator_traits<std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > > >::destroy<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > > ((struct allocator_type &) (struct allocator *) std::_Sp_counted_ptr_inplace<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >, std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >, (__gnu_cxx::_Lock_policy)2u>::_Impl::_M_alloc (&((struct _Sp_counted_ptr_inplace *) this)->_M_impl), std::_Sp_counted_ptr_inplace<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >, std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >, (__gnu_cxx::_Lock_policy)2u>::_M_ptr (this)) >>>>>
   >>>;


;; Function void std::_Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp>::_M_destroy() [with _Tp = std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >; _Alloc = std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    struct __allocator_type __a;
    struct __allocated_ptr __guard_ptr;

        struct __allocator_type __a;
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator<std::_Sp_counted_ptr_inplace<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >, std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >, (__gnu_cxx::_Lock_policy)2u> >::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > > (&__a, (const struct allocator &) (const struct allocator *) std::_Sp_counted_ptr_inplace<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >, std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >, (__gnu_cxx::_Lock_policy)2u>::_Impl::_M_alloc (&((struct _Sp_counted_ptr_inplace *) this)->_M_impl)) >>>>>;
    try
      {
                struct __allocated_ptr __guard_ptr;
        <<cleanup_point <<< Unknown tree: expr_stmt
  std::__allocated_ptr<std::allocator<std::_Sp_counted_ptr_inplace<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >, std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >, (__gnu_cxx::_Lock_policy)2u> > >::__allocated_ptr (&__guard_ptr, (struct allocator &) &__a, (struct _Sp_counted_ptr_inplace *) this) >>>>>;
        try
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Sp_counted_ptr_inplace<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >, std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >, (__gnu_cxx::_Lock_policy)2u>::~_Sp_counted_ptr_inplace (this) >>>>>;
          }
        finally
          {
            std::__allocated_ptr<std::allocator<std::_Sp_counted_ptr_inplace<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >, std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >, (__gnu_cxx::_Lock_policy)2u> > >::~__allocated_ptr (&__guard_ptr);
          }
      }
    finally
      {
        std::allocator<std::_Sp_counted_ptr_inplace<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >, std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >, (__gnu_cxx::_Lock_policy)2u> >::~allocator (&__a);
      }
  }
   >>>;


;; Function void* std::_Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp>::_M_get_deleter(const std::type_info&) [with _Tp = std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >; _Alloc = std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  if (<<cleanup_point std::type_info::operator== ((const struct type_info *) __ti, (const struct type_info &) (const struct type_info *) &_ZTISt19_Sp_make_shared_tag)>>)
    {
      <<cleanup_point return <retval> = (void *) (struct type *) std::_Sp_counted_ptr_inplace<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >, std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >, (__gnu_cxx::_Lock_policy)2u>::_M_ptr (this)>>;
    }
  return <retval> = 0B;
   >>>;


;; Function std::_Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp>::~_Sp_counted_ptr_inplace() [with _Tp = std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>; _Alloc = std::allocator<int>; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Sp_counted_ptr_inplace *) this)->D.115717._vptr._Sp_counted_base = &_ZTVSt23_Sp_counted_ptr_inplaceINSt13__future_base11_Task_stateIPFliiESaIiES2_EES4_LN9__gnu_cxx12_Lock_policyE2EE + 16) >>>>>;
    try
      {
        try
          {
            try
              {
                
              }
            finally
              {
                std::_Sp_counted_ptr_inplace<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, std::allocator<int>, (__gnu_cxx::_Lock_policy)2u>::_Impl::~_Impl (&((struct _Sp_counted_ptr_inplace *) this)->_M_impl);
              }
          }
        finally
          {
            std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2u>::~_Sp_counted_base (&((struct _Sp_counted_ptr_inplace *) this)->D.115717);
          }
      }
    finally
      {
        *(struct 
        {
          struct 
          {
            int (*__vtbl_ptr_type) () * _vptr._Sp_counted_base;
            _Atomic_word _M_use_count;
            _Atomic_word _M_weak_count;
          } D.115718;
          struct _Impl _M_impl;
        } &) this = {CLOBBER};
      }
  }
  <D.118155>:;
  if ((__in_chrg & 1) != 0)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  operator delete ((void *) this, 64) >>>>>;
    }
   >>>;


;; Function void std::_Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp>::_M_dispose() [with _Tp = std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>; _Alloc = std::allocator<int>; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator_traits<std::allocator<int> >::destroy<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)> > ((struct allocator_type &) (struct allocator *) std::_Sp_counted_ptr_inplace<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, std::allocator<int>, (__gnu_cxx::_Lock_policy)2u>::_Impl::_M_alloc (&((struct _Sp_counted_ptr_inplace *) this)->_M_impl), std::_Sp_counted_ptr_inplace<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, std::allocator<int>, (__gnu_cxx::_Lock_policy)2u>::_M_ptr (this)) >>>>>
   >>>;


;; Function void std::_Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp>::_M_destroy() [with _Tp = std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>; _Alloc = std::allocator<int>; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    struct __allocator_type __a;
    struct __allocated_ptr __guard_ptr;

        struct __allocator_type __a;
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator<std::_Sp_counted_ptr_inplace<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, std::allocator<int>, (__gnu_cxx::_Lock_policy)2u> >::allocator<int> (&__a, (const struct allocator &) (const struct allocator *) std::_Sp_counted_ptr_inplace<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, std::allocator<int>, (__gnu_cxx::_Lock_policy)2u>::_Impl::_M_alloc (&((struct _Sp_counted_ptr_inplace *) this)->_M_impl)) >>>>>;
    try
      {
                struct __allocated_ptr __guard_ptr;
        <<cleanup_point <<< Unknown tree: expr_stmt
  std::__allocated_ptr<std::allocator<std::_Sp_counted_ptr_inplace<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, std::allocator<int>, (__gnu_cxx::_Lock_policy)2u> > >::__allocated_ptr (&__guard_ptr, (struct allocator &) &__a, (struct _Sp_counted_ptr_inplace *) this) >>>>>;
        try
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Sp_counted_ptr_inplace<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, std::allocator<int>, (__gnu_cxx::_Lock_policy)2u>::~_Sp_counted_ptr_inplace (this) >>>>>;
          }
        finally
          {
            std::__allocated_ptr<std::allocator<std::_Sp_counted_ptr_inplace<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, std::allocator<int>, (__gnu_cxx::_Lock_policy)2u> > >::~__allocated_ptr (&__guard_ptr);
          }
      }
    finally
      {
        std::allocator<std::_Sp_counted_ptr_inplace<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, std::allocator<int>, (__gnu_cxx::_Lock_policy)2u> >::~allocator (&__a);
      }
  }
   >>>;


;; Function void* std::_Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp>::_M_get_deleter(const std::type_info&) [with _Tp = std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>; _Alloc = std::allocator<int>; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  if (<<cleanup_point std::type_info::operator== ((const struct type_info *) __ti, (const struct type_info &) (const struct type_info *) &_ZTISt19_Sp_make_shared_tag)>>)
    {
      <<cleanup_point return <retval> = (void *) (struct type *) std::_Sp_counted_ptr_inplace<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, std::allocator<int>, (__gnu_cxx::_Lock_policy)2u>::_M_ptr (this)>>;
    }
  return <retval> = 0B;
   >>>;


;; Function std::_Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp>::~_Sp_counted_ptr_inplace() [with _Tp = std::__future_base::_State_baseV2; _Alloc = std::allocator<std::__future_base::_State_baseV2>; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Sp_counted_ptr_inplace *) this)->D.113767._vptr._Sp_counted_base = &_ZTVSt23_Sp_counted_ptr_inplaceINSt13__future_base13_State_baseV2ESaIS1_ELN9__gnu_cxx12_Lock_policyE2EE + 16) >>>>>;
    try
      {
        try
          {
            try
              {
                
              }
            finally
              {
                std::_Sp_counted_ptr_inplace<std::__future_base::_State_baseV2, std::allocator<std::__future_base::_State_baseV2>, (__gnu_cxx::_Lock_policy)2u>::_Impl::~_Impl (&((struct _Sp_counted_ptr_inplace *) this)->_M_impl);
              }
          }
        finally
          {
            std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2u>::~_Sp_counted_base (&((struct _Sp_counted_ptr_inplace *) this)->D.113767);
          }
      }
    finally
      {
        *(struct 
        {
          struct 
          {
            int (*__vtbl_ptr_type) () * _vptr._Sp_counted_base;
            _Atomic_word _M_use_count;
            _Atomic_word _M_weak_count;
          } D.113768;
          struct _Impl _M_impl;
        } &) this = {CLOBBER};
      }
  }
  <D.118172>:;
  if ((__in_chrg & 1) != 0)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  operator delete ((void *) this, 48) >>>>>;
    }
   >>>;


;; Function void std::_Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp>::_M_dispose() [with _Tp = std::__future_base::_State_baseV2; _Alloc = std::allocator<std::__future_base::_State_baseV2>; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator_traits<std::allocator<std::__future_base::_State_baseV2> >::destroy<std::__future_base::_State_baseV2> ((struct allocator_type &) (struct allocator *) std::_Sp_counted_ptr_inplace<std::__future_base::_State_baseV2, std::allocator<std::__future_base::_State_baseV2>, (__gnu_cxx::_Lock_policy)2u>::_Impl::_M_alloc (&((struct _Sp_counted_ptr_inplace *) this)->_M_impl), std::_Sp_counted_ptr_inplace<std::__future_base::_State_baseV2, std::allocator<std::__future_base::_State_baseV2>, (__gnu_cxx::_Lock_policy)2u>::_M_ptr (this)) >>>>>
   >>>;


;; Function void std::_Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp>::_M_destroy() [with _Tp = std::__future_base::_State_baseV2; _Alloc = std::allocator<std::__future_base::_State_baseV2>; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    struct __allocator_type __a;
    struct __allocated_ptr __guard_ptr;

        struct __allocator_type __a;
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator<std::_Sp_counted_ptr_inplace<std::__future_base::_State_baseV2, std::allocator<std::__future_base::_State_baseV2>, (__gnu_cxx::_Lock_policy)2u> >::allocator<std::__future_base::_State_baseV2> (&__a, (const struct allocator &) (const struct allocator *) std::_Sp_counted_ptr_inplace<std::__future_base::_State_baseV2, std::allocator<std::__future_base::_State_baseV2>, (__gnu_cxx::_Lock_policy)2u>::_Impl::_M_alloc (&((struct _Sp_counted_ptr_inplace *) this)->_M_impl)) >>>>>;
    try
      {
                struct __allocated_ptr __guard_ptr;
        <<cleanup_point <<< Unknown tree: expr_stmt
  std::__allocated_ptr<std::allocator<std::_Sp_counted_ptr_inplace<std::__future_base::_State_baseV2, std::allocator<std::__future_base::_State_baseV2>, (__gnu_cxx::_Lock_policy)2u> > >::__allocated_ptr (&__guard_ptr, (struct allocator &) &__a, (struct _Sp_counted_ptr_inplace *) this) >>>>>;
        try
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Sp_counted_ptr_inplace<std::__future_base::_State_baseV2, std::allocator<std::__future_base::_State_baseV2>, (__gnu_cxx::_Lock_policy)2u>::~_Sp_counted_ptr_inplace (this) >>>>>;
          }
        finally
          {
            std::__allocated_ptr<std::allocator<std::_Sp_counted_ptr_inplace<std::__future_base::_State_baseV2, std::allocator<std::__future_base::_State_baseV2>, (__gnu_cxx::_Lock_policy)2u> > >::~__allocated_ptr (&__guard_ptr);
          }
      }
    finally
      {
        std::allocator<std::_Sp_counted_ptr_inplace<std::__future_base::_State_baseV2, std::allocator<std::__future_base::_State_baseV2>, (__gnu_cxx::_Lock_policy)2u> >::~allocator (&__a);
      }
  }
   >>>;


;; Function void* std::_Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp>::_M_get_deleter(const std::type_info&) [with _Tp = std::__future_base::_State_baseV2; _Alloc = std::allocator<std::__future_base::_State_baseV2>; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  if (<<cleanup_point std::type_info::operator== ((const struct type_info *) __ti, (const struct type_info &) (const struct type_info *) &_ZTISt19_Sp_make_shared_tag)>>)
    {
      <<cleanup_point return <retval> = (void *) (struct type *) std::_Sp_counted_ptr_inplace<std::__future_base::_State_baseV2, std::allocator<std::__future_base::_State_baseV2>, (__gnu_cxx::_Lock_policy)2u>::_M_ptr (this)>>;
    }
  return <retval> = 0B;
   >>>;


;; Function std::_Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp>::~_Sp_counted_ptr_inplace() [with _Tp = std::mutex; _Alloc = std::allocator<std::mutex>; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Sp_counted_ptr_inplace *) this)->D.112990._vptr._Sp_counted_base = &_ZTVSt23_Sp_counted_ptr_inplaceISt5mutexSaIS0_ELN9__gnu_cxx12_Lock_policyE2EE + 16) >>>>>;
    try
      {
        try
          {
            try
              {
                
              }
            finally
              {
                std::_Sp_counted_ptr_inplace<std::mutex, std::allocator<std::mutex>, (__gnu_cxx::_Lock_policy)2u>::_Impl::~_Impl (&((struct _Sp_counted_ptr_inplace *) this)->_M_impl);
              }
          }
        finally
          {
            std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2u>::~_Sp_counted_base (&((struct _Sp_counted_ptr_inplace *) this)->D.112990);
          }
      }
    finally
      {
        *(struct 
        {
          struct 
          {
            int (*__vtbl_ptr_type) () * _vptr._Sp_counted_base;
            _Atomic_word _M_use_count;
            _Atomic_word _M_weak_count;
          } D.112991;
          struct _Impl _M_impl;
        } &) this = {CLOBBER};
      }
  }
  <D.118189>:;
  if ((__in_chrg & 1) != 0)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  operator delete ((void *) this, 56) >>>>>;
    }
   >>>;


;; Function void std::_Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp>::_M_dispose() [with _Tp = std::mutex; _Alloc = std::allocator<std::mutex>; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator_traits<std::allocator<std::mutex> >::destroy<std::mutex> ((struct allocator_type &) (struct allocator *) std::_Sp_counted_ptr_inplace<std::mutex, std::allocator<std::mutex>, (__gnu_cxx::_Lock_policy)2u>::_Impl::_M_alloc (&((struct _Sp_counted_ptr_inplace *) this)->_M_impl), std::_Sp_counted_ptr_inplace<std::mutex, std::allocator<std::mutex>, (__gnu_cxx::_Lock_policy)2u>::_M_ptr (this)) >>>>>
   >>>;


;; Function void std::_Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp>::_M_destroy() [with _Tp = std::mutex; _Alloc = std::allocator<std::mutex>; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    struct __allocator_type __a;
    struct __allocated_ptr __guard_ptr;

        struct __allocator_type __a;
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator<std::_Sp_counted_ptr_inplace<std::mutex, std::allocator<std::mutex>, (__gnu_cxx::_Lock_policy)2u> >::allocator<std::mutex> (&__a, (const struct allocator &) (const struct allocator *) std::_Sp_counted_ptr_inplace<std::mutex, std::allocator<std::mutex>, (__gnu_cxx::_Lock_policy)2u>::_Impl::_M_alloc (&((struct _Sp_counted_ptr_inplace *) this)->_M_impl)) >>>>>;
    try
      {
                struct __allocated_ptr __guard_ptr;
        <<cleanup_point <<< Unknown tree: expr_stmt
  std::__allocated_ptr<std::allocator<std::_Sp_counted_ptr_inplace<std::mutex, std::allocator<std::mutex>, (__gnu_cxx::_Lock_policy)2u> > >::__allocated_ptr (&__guard_ptr, (struct allocator &) &__a, (struct _Sp_counted_ptr_inplace *) this) >>>>>;
        try
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Sp_counted_ptr_inplace<std::mutex, std::allocator<std::mutex>, (__gnu_cxx::_Lock_policy)2u>::~_Sp_counted_ptr_inplace (this) >>>>>;
          }
        finally
          {
            std::__allocated_ptr<std::allocator<std::_Sp_counted_ptr_inplace<std::mutex, std::allocator<std::mutex>, (__gnu_cxx::_Lock_policy)2u> > >::~__allocated_ptr (&__guard_ptr);
          }
      }
    finally
      {
        std::allocator<std::_Sp_counted_ptr_inplace<std::mutex, std::allocator<std::mutex>, (__gnu_cxx::_Lock_policy)2u> >::~allocator (&__a);
      }
  }
   >>>;


;; Function void* std::_Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp>::_M_get_deleter(const std::type_info&) [with _Tp = std::mutex; _Alloc = std::allocator<std::mutex>; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  if (<<cleanup_point std::type_info::operator== ((const struct type_info *) __ti, (const struct type_info &) (const struct type_info *) &_ZTISt19_Sp_make_shared_tag)>>)
    {
      <<cleanup_point return <retval> = (void *) (struct type *) std::_Sp_counted_ptr_inplace<std::mutex, std::allocator<std::mutex>, (__gnu_cxx::_Lock_policy)2u>::_M_ptr (this)>>;
    }
  return <retval> = 0B;
   >>>;


;; Function static constexpr std::_Tuple_impl<_Idx, _Head, _Tail ...>::_Inherited& std::_Tuple_impl<_Idx, _Head, _Tail ...>::_M_tail(std::_Tuple_impl<_Idx, _Head, _Tail ...>&) [with long unsigned int _Idx = 0ul; _Head = std::reference_wrapper<long int (*)(int, int)>; _Tail = {int, int}; std::_Tuple_impl<_Idx, _Head, _Tail ...>::_Inherited = std::_Tuple_impl<1ul, int, int>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct _Inherited &) &((struct _Tuple_impl *) __t)->D.119317
   >>>;


;; Function static constexpr _Head& std::_Head_base<_Idx, _Head, false>::_M_head(std::_Head_base<_Idx, _Head, false>&) [with long unsigned int _Idx = 0ul; _Head = std::reference_wrapper<long int (*)(int, int)>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct reference_wrapper &) &__b->_M_head_impl
   >>>;


;; Function static constexpr _Head& std::_Tuple_impl<_Idx, _Head, _Tail ...>::_M_head(std::_Tuple_impl<_Idx, _Head, _Tail ...>&) [with long unsigned int _Idx = 0ul; _Head = std::reference_wrapper<long int (*)(int, int)>; _Tail = {int, int}] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct reference_wrapper &) (struct reference_wrapper *) std::_Head_base<0ul, std::reference_wrapper<long int (*)(int, int)>, false>::_M_head ((struct _Head_base &) &((struct _Tuple_impl *) __t)->D.119318)>>
   >>>;


;; Function constexpr _Tp&& std::forward(typename std::remove_reference<_From>::type&) [with _Tp = std::reference_wrapper<long int (*)(int, int)>; typename std::remove_reference<_From>::type = std::reference_wrapper<long int (*)(int, int)>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct reference_wrapper &) (struct reference_wrapper *) NON_LVALUE_EXPR <(struct reference_wrapper &) __t>
   >>>;


;; Function constexpr std::_Head_base<_Idx, _Head, false>::_Head_base(_UHead&&) [with _UHead = std::reference_wrapper<long int (*)(int, int)>; long unsigned int _Idx = 0ul; _Head = std::reference_wrapper<long int (*)(int, int)>] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Head_base *) this)->_M_head_impl = *(const struct reference_wrapper &) (const struct reference_wrapper *) std::forward<std::reference_wrapper<long int (*)(int, int)> > ((struct type &) (struct reference_wrapper *) __h)) >>>>>;
}


;; Function constexpr std::_Tuple_impl<_Idx, _Head, _Tail ...>::_Tuple_impl(std::_Tuple_impl<_Idx, _Head, _Tail ...>&&) [with long unsigned int _Idx = 0ul; _Head = std::reference_wrapper<long int (*)(int, int)>; _Tail = {int, int}] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Tuple_impl<1ul, int, int>::_Tuple_impl (&((struct _Tuple_impl *) this)->D.119317, (struct _Tuple_impl &) (struct type *) std::move<std::_Tuple_impl<1ul, int, int>&> ((struct _Tuple_impl &) (struct _Inherited *) std::_Tuple_impl<0ul, std::reference_wrapper<long int (*)(int, int)>, int, int>::_M_tail ((struct _Tuple_impl &) (struct _Tuple_impl *) __in))) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Head_base<0ul, std::reference_wrapper<long int (*)(int, int)>, false>::_Head_base<std::reference_wrapper<long int (*)(int, int)> > (&((struct _Tuple_impl *) this)->D.119318, (struct reference_wrapper &) (struct reference_wrapper *) std::forward<std::reference_wrapper<long int (*)(int, int)> > ((struct type &) (struct reference_wrapper *) std::_Tuple_impl<0ul, std::reference_wrapper<long int (*)(int, int)>, int, int>::_M_head ((struct _Tuple_impl &) (struct _Tuple_impl *) __in))) >>>>>;
  }
   >>>;


;; Function constexpr std::tuple< <template-parameter-1-1> >::tuple(std::tuple< <template-parameter-1-1> >&&) [with _Elements = {std::reference_wrapper<long int (*)(int, int)>, int, int}] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Tuple_impl<0ul, std::reference_wrapper<long int (*)(int, int)>, int, int>::_Tuple_impl (&((struct tuple *) this)->D.119777, (struct _Tuple_impl &) (struct _Tuple_impl *) NON_LVALUE_EXPR <(struct _Tuple_impl &) &((struct tuple *) D.119356)->D.119777>) >>>>>;
}


;; Function std::_Bind_simple<_Callable(_Args ...)>::_Bind_simple(std::_Bind_simple<_Callable(_Args ...)>&&) [with _Callable = std::reference_wrapper<long int (*)(int, int)>; _Args = {int, int}] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::tuple<std::reference_wrapper<long int (*)(int, int)>, int, int>::tuple (&((struct _Bind_simple *) this)->_M_bound, (struct tuple &) (struct tuple *) NON_LVALUE_EXPR <(struct tuple &) &D.118600->_M_bound>) >>>>>;
}


;; Function void std::__future_base::_Task_state<_Fn, _Alloc, _Res(_Args ...)>::_M_run(_Args&& ...) [with _Fn = long int (*)(int, int); _Alloc = std::allocator<int>; _Res = long int; _Args = {int, int}] (null)
;; enabled by -tree-original


{
  struct _Bind_simple __boundfn;

    struct _Bind_simple __boundfn;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__boundfn = <<< Unknown tree: aggr_init_expr
  6
  __bind_simple
  D.120120
  (struct reference_wrapper &) &TARGET_EXPR <D.118367, std::ref<long int (*)(int, int)> ((long int (*<T105d2>) (int, int) &) &((struct _Task_state *) this)->_M_impl._M_fn)>
  (int &) (type *) std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>::_S_maybe_wrap_ref<int> ((int &) (int *) std::forward<int> ((type &) (int *) __args#0))
  (int &) (type *) std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>::_S_maybe_wrap_ref<int> ((int &) (int *) std::forward<int> ((type &) (int *) __args#1)) >>>) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__future_base::_State_baseV2::_M_set_result (&((struct _Task_state *) this)->D.109886.D.98645, &TARGET_EXPR <D.120667, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.120667
  (struct function *) <<< Unknown tree: void_cst >>>
  TARGET_EXPR <D.120405, std::__future_base::_S_task_setter<std::unique_ptr<std::__future_base::_Result<long int>, std::__future_base::_Result_base::_Deleter>, std::_Bind_simple<std::reference_wrapper<long int (*)(int, int)>(int, int)> > ((struct unique_ptr &) &((struct _Task_state *) this)->D.109886._M_result, (struct _Bind_simple &) &__boundfn)> >>>>, 0) >>>>>;
}


;; Function void std::__future_base::_Task_state<_Fn, _Alloc, _Res(_Args ...)>::_M_run_delayed(_Args&& ..., std::weak_ptr<std::__future_base::_State_baseV2>) [with _Fn = long int (*)(int, int); _Alloc = std::allocator<int>; _Res = long int; _Args = {int, int}] (null)
;; enabled by -tree-original


{
  struct _Bind_simple __boundfn;

    struct _Bind_simple __boundfn;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__boundfn = <<< Unknown tree: aggr_init_expr
  6
  __bind_simple
  D.120672
  (struct reference_wrapper &) &TARGET_EXPR <D.120671, std::ref<long int (*)(int, int)> ((long int (*<T105d2>) (int, int) &) &((struct _Task_state *) this)->_M_impl._M_fn)>
  (int &) (type *) std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>::_S_maybe_wrap_ref<int> ((int &) (int *) std::forward<int> ((type &) (int *) __args#0))
  (int &) (type *) std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>::_S_maybe_wrap_ref<int> ((int &) (int *) std::forward<int> ((type &) (int *) __args#1)) >>>) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__future_base::_State_baseV2::_M_set_delayed_result (&((struct _Task_state *) this)->D.109886.D.98645, &TARGET_EXPR <D.120674, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.120674
  (struct function *) <<< Unknown tree: void_cst >>>
  TARGET_EXPR <D.120673, std::__future_base::_S_task_setter<std::unique_ptr<std::__future_base::_Result<long int>, std::__future_base::_Result_base::_Deleter>, std::_Bind_simple<std::reference_wrapper<long int (*)(int, int)>(int, int)> > ((struct unique_ptr &) &((struct _Task_state *) this)->D.109886._M_result, (struct _Bind_simple &) &__boundfn)> >>>>, &TARGET_EXPR <D.120675, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.120675
  (struct weak_ptr *) <<< Unknown tree: void_cst >>>
  (struct weak_ptr &) (struct type *) std::move<std::weak_ptr<std::__future_base::_State_baseV2>&> ((struct weak_ptr &) (struct weak_ptr *) __self) >>>>) >>>>>;
}


;; Function constexpr typename std::remove_reference< <template-parameter-1-1> >::type&& std::move(_Tp&&) [with _Tp = long int (*&)(int, int); typename std::remove_reference< <template-parameter-1-1> >::type = long int (*)(int, int)] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (long int (*type) (int, int) &) (long int (*type) (int, int) *) (long int (*type) (int, int) &) __t
   >>>;


;; Function std::shared_ptr<std::__future_base::_Task_state_base<_Res(_Args ...)> > std::__future_base::_Task_state<_Fn, _Alloc, _Res(_Args ...)>::_M_reset() [with _Fn = long int (*)(int, int); _Alloc = std::allocator<int>; _Res = long int; _Args = {int, int}] (null)
;; enabled by -tree-original


<<cleanup_point return *<retval> = TARGET_EXPR <D.120683, <<< Unknown tree: aggr_init_expr
  5
  __create_task_state
  D.120683
  (long int (*<T105d2>) (int, int) &) (long int (*type) (int, int) *) std::move<long int (*&)(int, int)> ((long int (*<T105d2>) (int, int) &) &((struct _Task_state *) this)->_M_impl._M_fn)
  (const struct allocator &) (const struct allocator *) &((struct _Task_state *) this)->_M_impl >>>>>>;


;; Function void std::thread::_Impl<_Callable>::_M_run() [with _Callable = std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)>] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)>::operator() (&((struct _Impl *) this)->_M_func) >>>>>;


;; Function void std::__future_base::_Result<_Res>::_M_destroy() [with _Res = long int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  if ((struct _Result *) this != 0B)
    {
      OBJ_TYPE_REF(*(((struct _Result *) this)->D.98954._vptr._Result_base + 16);(struct _Result)this->2) (this);
    }
  else
    {
      <<< Unknown tree: void_cst >>>
    } >>>>>;


;; Function std::__future_base::_Result<_Res>::~_Result() [with _Res = long int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Result *) this)->D.98954._vptr._Result_base = &_ZTVNSt13__future_base7_ResultIlEE + 16) >>>>>;
    try
      {
        try
          {
            if (((struct _Result *) this)->_M_initialized)
              {
                <<cleanup_point <<< Unknown tree: expr_stmt
  (void) *std::__future_base::_Result<long int>::_M_value (this) >>>>>;
              }
          }
        finally
          {
            std::__future_base::_Result_base::~_Result_base (&((struct _Result *) this)->D.98954);
          }
      }
    finally
      {
        *(struct 
        {
          struct 
          {
            int (*__vtbl_ptr_type) () * _vptr._Result_base;
            struct exception_ptr _M_error;
          } D.98955;
          struct __aligned_buffer _M_storage;
          bool _M_initialized;
        } &) this = {CLOBBER};
      }
  }
  <D.120687>:;
  if ((__in_chrg & 1) != 0)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  operator delete ((void *) this, 32) >>>>>;
    }
   >>>;


;; Function _Alloc& std::_Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp>::_Impl::_M_alloc() [with _Tp = std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >; _Alloc = std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct allocator &) (struct allocator *) std::_Sp_ebo_helper<0, std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >, true>::_S_get ((struct _Sp_ebo_helper &) (struct _Sp_ebo_helper *) this)>>
   >>>;


;; Function static void std::allocator_traits<std::allocator<_CharT> >::destroy(std::allocator_traits<std::allocator<_CharT> >::allocator_type&, _Up*) [with _Up = std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >; _Tp = std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >; std::allocator_traits<std::allocator<_CharT> >::allocator_type = std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >::destroy<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > > ((struct new_allocator *) (struct allocator_type *) __a, __p) >>>>>;


;; Function _Alloc& std::_Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp>::_Impl::_M_alloc() [with _Tp = std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>; _Alloc = std::allocator<int>; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct allocator &) (struct allocator *) std::_Sp_ebo_helper<0, std::allocator<int>, true>::_S_get ((struct _Sp_ebo_helper &) (struct _Sp_ebo_helper *) this)>>
   >>>;


;; Function static void std::allocator_traits<std::allocator<_CharT> >::destroy(std::allocator_traits<std::allocator<_CharT> >::allocator_type&, _Up*) [with _Up = std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>; _Tp = int; std::allocator_traits<std::allocator<_CharT> >::allocator_type = std::allocator<int>] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<int>::destroy<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)> > ((struct new_allocator *) (struct allocator_type *) __a, __p) >>>>>;


;; Function _Alloc& std::_Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp>::_Impl::_M_alloc() [with _Tp = std::__future_base::_State_baseV2; _Alloc = std::allocator<std::__future_base::_State_baseV2>; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct allocator &) (struct allocator *) std::_Sp_ebo_helper<0, std::allocator<std::__future_base::_State_baseV2>, true>::_S_get ((struct _Sp_ebo_helper &) (struct _Sp_ebo_helper *) this)>>
   >>>;


;; Function static void std::allocator_traits<std::allocator<_CharT> >::destroy(std::allocator_traits<std::allocator<_CharT> >::allocator_type&, _Up*) [with _Up = std::__future_base::_State_baseV2; _Tp = std::__future_base::_State_baseV2; std::allocator_traits<std::allocator<_CharT> >::allocator_type = std::allocator<std::__future_base::_State_baseV2>] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<std::__future_base::_State_baseV2>::destroy<std::__future_base::_State_baseV2> ((struct new_allocator *) (struct allocator_type *) __a, __p) >>>>>;


;; Function _Alloc& std::_Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp>::_Impl::_M_alloc() [with _Tp = std::mutex; _Alloc = std::allocator<std::mutex>; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct allocator &) (struct allocator *) std::_Sp_ebo_helper<0, std::allocator<std::mutex>, true>::_S_get ((struct _Sp_ebo_helper &) (struct _Sp_ebo_helper *) this)>>
   >>>;


;; Function static void std::allocator_traits<std::allocator<_CharT> >::destroy(std::allocator_traits<std::allocator<_CharT> >::allocator_type&, _Up*) [with _Up = std::mutex; _Tp = std::mutex; std::allocator_traits<std::allocator<_CharT> >::allocator_type = std::allocator<std::mutex>] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<std::mutex>::destroy<std::mutex> ((struct new_allocator *) (struct allocator_type *) __a, __p) >>>>>;


;; Function std::reference_wrapper<_Tp> std::ref(_Tp&) [with _Tp = long int (*)(int, int)] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = TARGET_EXPR <D.120716, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.120716
  (struct reference_wrapper *) <<< Unknown tree: void_cst >>>
  (long int (*<T105d2>) (int, int) &) (long int (*<T105d2>) (int, int) *) __t >>>>;, D.120716>>
   >>>;


;; Function static typename std::enable_if<(! std::is_lvalue_reference<_Tp>::value), _Tp>::type&& std::__future_base::_Task_state<_Fn, _Alloc, _Res(_Args ...)>::_S_maybe_wrap_ref(_Tp&&) [with _Tp = int; _Fn = long int (*)(int, int); _Alloc = std::allocator<int>; _Res = long int; _Args = {int, int}; typename std::enable_if<(! std::is_lvalue_reference<_Tp>::value), _Tp>::type = int] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (type &) (int *) std::forward<int> ((type &) (int *) __t)>>;


;; Function typename std::_Bind_simple_helper<_Func, _BoundArgs>::__type std::__bind_simple(_Callable&&, _Args&& ...) [with _Callable = std::reference_wrapper<long int (*)(int, int)>; _Args = {int, int}; typename std::_Bind_simple_helper<_Func, _BoundArgs>::__type = std::_Bind_simple<std::reference_wrapper<long int (*)(int, int)>(int, int)>] (null)
;; enabled by -tree-original


{
  typedef struct __helper_type __helper_type;
  typedef struct __maybe_type __maybe_type;
  typedef struct __result_type __result_type;

  <<cleanup_point return *<retval> = TARGET_EXPR <D.120737, <<< Unknown tree: aggr_init_expr
  7
  __comp_ctor 
  D.120737
  (struct _Bind_simple *) <<< Unknown tree: void_cst >>>
  (struct reference_wrapper &) (struct reference_wrapper *) std::_Maybe_wrap_member_pointer<std::reference_wrapper<long int (*)(int, int)> >::__do_wrap ((struct reference_wrapper &) (struct reference_wrapper *) std::forward<std::reference_wrapper<long int (*)(int, int)> > ((struct type &) (struct reference_wrapper *) __callable))
  (int &) (int *) std::forward<int> ((type &) (int *) __args#0)
  (int &) (int *) std::forward<int> ((type &) (int *) __args#1) >>>>>>;
}


;; Function static std::__future_base::_Task_setter<_Res_ptr, _BoundFn> std::__future_base::_S_task_setter(_Res_ptr&, _BoundFn&) [with _Res_ptr = std::unique_ptr<std::__future_base::_Result<long int>, std::__future_base::_Result_base::_Deleter>; _BoundFn = std::_Bind_simple<std::reference_wrapper<long int (*)(int, int)>(int, int)>; typename _Res_ptr::element_type::result_type = long int] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = TARGET_EXPR <D.120743, {._M_result=std::__addressof<std::unique_ptr<std::__future_base::_Result<long int>, std::__future_base::_Result_base::_Deleter> > ((struct unique_ptr &) (struct unique_ptr *) __ptr), ._M_fn=std::__addressof<std::_Bind_simple<std::reference_wrapper<long int (*)(int, int)>(int, int)> > ((struct _Bind_simple &) (struct _Bind_simple *) __call)}>>>;


;; Function constexpr typename std::remove_reference< <template-parameter-1-1> >::type&& std::move(_Tp&&) [with _Tp = std::__future_base::_Task_setter<std::unique_ptr<std::__future_base::_Result<long int>, std::__future_base::_Result_base::_Deleter>, std::_Bind_simple<std::reference_wrapper<long int (*)(int, int)>(int, int)>, long int>&; typename std::remove_reference< <template-parameter-1-1> >::type = std::__future_base::_Task_setter<std::unique_ptr<std::__future_base::_Result<long int>, std::__future_base::_Result_base::_Deleter>, std::_Bind_simple<std::reference_wrapper<long int (*)(int, int)>(int, int)>, long int>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct type &) (struct type *) NON_LVALUE_EXPR <(struct type &) __t>
   >>>;


;; Function std::function<_Res(_ArgTypes ...)>::function(_Functor) [with _Functor = std::__future_base::_Task_setter<std::unique_ptr<std::__future_base::_Result<long int>, std::__future_base::_Result_base::_Deleter>, std::_Bind_simple<std::reference_wrapper<long int (*)(int, int)>(int, int)>, long int>; <template-parameter-2-2> = void; <template-parameter-2-3> = void; _Res = std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>; _ArgTypes = {}] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Maybe_unary_or_binary_function<std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter> >::_Maybe_unary_or_binary_function ((struct _Maybe_unary_or_binary_function *) this) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Function_base::_Function_base (&((struct function *) this)->D.65694) >>>>>;
  try
    {
      {
        typedef struct _My_handler _My_handler;

        if (<<cleanup_point std::_Function_base::_Base_manager<std::__future_base::_Task_setter<std::unique_ptr<std::__future_base::_Result<long int>, std::__future_base::_Result_base::_Deleter>, std::_Bind_simple<std::reference_wrapper<long int (*)(int, int)>(int, int)>, long int> >::_M_not_empty_function<std::__future_base::_Task_setter<std::unique_ptr<std::__future_base::_Result<long int>, std::__future_base::_Result_base::_Deleter>, std::_Bind_simple<std::reference_wrapper<long int (*)(int, int)>(int, int)>, long int> > ((const struct _Task_setter &) (const struct _Task_setter *) &__f)>>)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Function_base::_Base_manager<std::__future_base::_Task_setter<std::unique_ptr<std::__future_base::_Result<long int>, std::__future_base::_Result_base::_Deleter>, std::_Bind_simple<std::reference_wrapper<long int (*)(int, int)>(int, int)>, long int> >::_M_init_functor ((union _Any_data &) &((struct function *) this)->D.65694._M_functor, (struct _Task_setter &) (struct type *) std::move<std::__future_base::_Task_setter<std::unique_ptr<std::__future_base::_Result<long int>, std::__future_base::_Result_base::_Deleter>, std::_Bind_simple<std::reference_wrapper<long int (*)(int, int)>(int, int)>, long int>&> ((struct _Task_setter &) &__f)) >>>>>;
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct function *) this)->_M_invoker = _M_invoke) >>>>>;
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct function *) this)->D.65694._M_manager = _M_manager) >>>>>;
          }
      }
    }
  catch
    {
      std::_Function_base::~_Function_base (&((struct function *) this)->D.65694);
    }
}


;; Function constexpr _Tp&& std::forward(typename std::remove_reference<_From>::type&) [with _Tp = long int (*)(int, int); typename std::remove_reference<_From>::type = long int (*)(int, int)] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (long int (*<T105d2>) (int, int) &) (long int (*<T105d2>) (int, int) *) (long int (*<T105d2>) (int, int) &) __t
   >>>;


;; Function std::shared_ptr<std::__future_base::_Task_state_base<_Signature> > std::__create_task_state(_Fn&&, const _Alloc&) [with _Signature = long int(int, int); _Fn = long int (*)(int, int); _Alloc = std::allocator<int>] (null)
;; enabled by -tree-original


{
  typedef long int (*_Fn2) (int, int) _Fn2;
  typedef struct _State _State;

  <<cleanup_point return *<retval> = TARGET_EXPR <D.120866, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.120866
  (struct shared_ptr *) <<< Unknown tree: void_cst >>>
  (struct shared_ptr &) &TARGET_EXPR <D.120865, <<< Unknown tree: aggr_init_expr
  6
  allocate_shared
  D.120865
  (const struct allocator &) (const struct allocator *) __a
  (long int (*<T105d2>) (int, int) &) (long int (*<T105d2>) (int, int) *) std::forward<long int (*)(int, int)> ((long int (*type) (int, int) &) (long int (*<T105d2>) (int, int) *) __fn)
  (const struct allocator &) (const struct allocator *) __a >>>> >>>>>>;
}


;; Function std::_Bind_simple<_Callable(_Args ...)>::result_type std::_Bind_simple<_Callable(_Args ...)>::operator()() [with _Callable = std::packaged_task<long int(int, int)>; _Args = {int, int}; std::_Bind_simple<_Callable(_Args ...)>::result_type = void] (null)
;; enabled by -tree-original


{
  typedef struct _Indices _Indices;

  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)>::_M_invoke<0ul, 1ul> (this, TARGET_EXPR <D.120893, {}>;, <<< Unknown tree: empty_class_expr >>>;) >>>>>;
  return;
}


;; Function static _Tp& std::_Sp_ebo_helper<_Nm, _Tp, true>::_S_get(std::_Sp_ebo_helper<_Nm, _Tp, true>&) [with int _Nm = 0; _Tp = std::allocator<std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> > >] (null)
;; enabled by -tree-original


return <retval> = (struct allocator &) (struct allocator *) (struct allocator &) (struct allocator *) (struct _Sp_ebo_helper *) __eboh;


;; Function void __gnu_cxx::new_allocator<_Tp>::destroy(_Up*) [with _Up = std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >; _Tp = std::thread::_Impl<std::_Bind_simple<std::packaged_task<long int(int, int)>(int, int)> >] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  OBJ_TYPE_REF(*NON_LVALUE_EXPR <NON_LVALUE_EXPR <__p>->D.103772._vptr._Impl_base>;(struct _Impl)NON_LVALUE_EXPR <__p>->0) (NON_LVALUE_EXPR <__p>) >>>>>;


;; Function static _Tp& std::_Sp_ebo_helper<_Nm, _Tp, true>::_S_get(std::_Sp_ebo_helper<_Nm, _Tp, true>&) [with int _Nm = 0; _Tp = std::allocator<int>] (null)
;; enabled by -tree-original


return <retval> = (struct allocator &) (struct allocator *) (struct allocator &) (struct allocator *) (struct _Sp_ebo_helper *) __eboh;


;; Function void __gnu_cxx::new_allocator<_Tp>::destroy(_Up*) [with _Up = std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>; _Tp = int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>::~_Task_state (NON_LVALUE_EXPR <__p>) >>>>>;


;; Function static _Tp& std::_Sp_ebo_helper<_Nm, _Tp, true>::_S_get(std::_Sp_ebo_helper<_Nm, _Tp, true>&) [with int _Nm = 0; _Tp = std::allocator<std::__future_base::_State_baseV2>] (null)
;; enabled by -tree-original


return <retval> = (struct allocator &) (struct allocator *) (struct allocator &) (struct allocator *) (struct _Sp_ebo_helper *) __eboh;


;; Function void __gnu_cxx::new_allocator<_Tp>::destroy(_Up*) [with _Up = std::__future_base::_State_baseV2; _Tp = std::__future_base::_State_baseV2] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  OBJ_TYPE_REF(*NON_LVALUE_EXPR <NON_LVALUE_EXPR <__p>->_vptr._State_baseV2>;(struct _State_baseV2)NON_LVALUE_EXPR <__p>->0) (NON_LVALUE_EXPR <__p>) >>>>>;


;; Function static _Tp& std::_Sp_ebo_helper<_Nm, _Tp, true>::_S_get(std::_Sp_ebo_helper<_Nm, _Tp, true>&) [with int _Nm = 0; _Tp = std::allocator<std::mutex>] (null)
;; enabled by -tree-original


return <retval> = (struct allocator &) (struct allocator *) (struct allocator &) (struct allocator *) (struct _Sp_ebo_helper *) __eboh;


;; Function void __gnu_cxx::new_allocator<_Tp>::destroy(_Up*) [with _Up = std::mutex; _Tp = std::mutex] (null)
;; enabled by -tree-original


<<< Unknown tree: expr_stmt
  (void) 0 >>>;


;; Function constexpr std::binary_function<int, int, long int>::binary_function() (null)
;; enabled by -tree-original


{
  
}


;; Function constexpr std::_Reference_wrapper_base<long int (*)(int, int)>::_Reference_wrapper_base() (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::binary_function<int, int, long int>::binary_function ((struct binary_function *) this) >>>>>;
}


;; Function std::reference_wrapper<_Tp>::reference_wrapper(_Tp&) [with _Tp = long int (*)(int, int)] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Reference_wrapper_base<long int (*)(int, int)>::_Reference_wrapper_base ((struct _Reference_wrapper_base *) this) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct reference_wrapper *) this)->_M_data = std::__addressof<long int (*)(int, int)> ((long int (*<T105d2>) (int, int) &) (long int (*<T105d2>) (int, int) *) __indata)) >>>>>;
  }
   >>>;


;; Function static _Tp&& std::_Maybe_wrap_member_pointer<_Tp>::__do_wrap(_Tp&&) [with _Tp = std::reference_wrapper<long int (*)(int, int)>] (null)
;; enabled by -tree-original


return <retval> = (struct reference_wrapper &) (struct reference_wrapper *) NON_LVALUE_EXPR <__x>;


;; Function constexpr std::_Tuple_impl<_Idx, _Head, _Tail ...>::_Tuple_impl(_UHead&&, _UTail&& ...) [with _UHead = int; _UTail = {int}; <template-parameter-2-3> = void; long unsigned int _Idx = 1ul; _Head = int; _Tail = {int}] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Tuple_impl<2ul, int>::_Tuple_impl<int> (&((struct _Tuple_impl *) this)->D.100819, (int &) (int *) std::forward<int> ((type &) (int *) __tail#0)) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Head_base<1ul, int, false>::_Head_base<int> (&((struct _Tuple_impl *) this)->D.100820, (int &) (int *) std::forward<int> ((type &) (int *) __head)) >>>>>;
}


;; Function constexpr std::_Tuple_impl<_Idx, _Head, _Tail ...>::_Tuple_impl(_UHead&&, _UTail&& ...) [with _UHead = std::reference_wrapper<long int (*)(int, int)>; _UTail = {int, int}; <template-parameter-2-3> = void; long unsigned int _Idx = 0ul; _Head = std::reference_wrapper<long int (*)(int, int)>; _Tail = {int, int}] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Tuple_impl<1ul, int, int>::_Tuple_impl<int, int, void> (&((struct _Tuple_impl *) this)->D.119317, (int &) (int *) std::forward<int> ((type &) (int *) __tail#0), (int &) (int *) std::forward<int> ((type &) (int *) __tail#1)) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Head_base<0ul, std::reference_wrapper<long int (*)(int, int)>, false>::_Head_base<std::reference_wrapper<long int (*)(int, int)> > (&((struct _Tuple_impl *) this)->D.119318, (struct reference_wrapper &) (struct reference_wrapper *) std::forward<std::reference_wrapper<long int (*)(int, int)> > ((struct type &) (struct reference_wrapper *) __head)) >>>>>;
}


;; Function constexpr std::tuple< <template-parameter-1-1> >::tuple(_UElements&& ...) [with _UElements = {std::reference_wrapper<long int (*)(int, int)>, int, int}; <template-parameter-2-2> = void; _Elements = {std::reference_wrapper<long int (*)(int, int)>, int, int}] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Tuple_impl<0ul, std::reference_wrapper<long int (*)(int, int)>, int, int>::_Tuple_impl<std::reference_wrapper<long int (*)(int, int)>, int, int, void> (&((struct tuple *) this)->D.119777, (struct reference_wrapper &) (struct reference_wrapper *) std::forward<std::reference_wrapper<long int (*)(int, int)> > ((struct type &) (struct reference_wrapper *) __elements#0), (int &) (int *) std::forward<int> ((type &) (int *) __elements#1), (int &) (int *) std::forward<int> ((type &) (int *) __elements#2)) >>>>>;
}


;; Function std::_Bind_simple<_Callable(_Args ...)>::_Bind_simple(_Tp&&, _Up&& ...) [with _Tp = std::reference_wrapper<long int (*)(int, int)>; _Up = {int, int}; _Callable = std::reference_wrapper<long int (*)(int, int)>; _Args = {int, int}] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::tuple<std::reference_wrapper<long int (*)(int, int)>, int, int>::tuple<std::reference_wrapper<long int (*)(int, int)>, int, int, void> (&((struct _Bind_simple *) this)->_M_bound, (struct reference_wrapper &) (struct reference_wrapper *) std::forward<std::reference_wrapper<long int (*)(int, int)> > ((struct type &) (struct reference_wrapper *) __f), (int &) (int *) std::forward<int> ((type &) (int *) __args#0), (int &) (int *) std::forward<int> ((type &) (int *) __args#1)) >>>>>;
}


;; Function _Tp* std::__addressof(_Tp&) [with _Tp = std::unique_ptr<std::__future_base::_Result<long int>, std::__future_base::_Result_base::_Deleter>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct unique_ptr *) __r
   >>>;


;; Function _Tp* std::__addressof(_Tp&) [with _Tp = std::_Bind_simple<std::reference_wrapper<long int (*)(int, int)>(int, int)>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct _Bind_simple *) __r
   >>>;


;; Function static bool std::_Function_base::_Base_manager<_Functor>::_M_not_empty_function(const _Tp&) [with _Tp = std::__future_base::_Task_setter<std::unique_ptr<std::__future_base::_Result<long int>, std::__future_base::_Result_base::_Deleter>, std::_Bind_simple<std::reference_wrapper<long int (*)(int, int)>(int, int)>, long int>; _Functor = std::__future_base::_Task_setter<std::unique_ptr<std::__future_base::_Result<long int>, std::__future_base::_Result_base::_Deleter>, std::_Bind_simple<std::reference_wrapper<long int (*)(int, int)>(int, int)>, long int>] (null)
;; enabled by -tree-original


return <retval> = 1;


;; Function static void std::_Function_base::_Base_manager<_Functor>::_M_init_functor(std::_Any_data&, _Functor&&) [with _Functor = std::__future_base::_Task_setter<std::unique_ptr<std::__future_base::_Result<long int>, std::__future_base::_Result_base::_Deleter>, std::_Bind_simple<std::reference_wrapper<long int (*)(int, int)>(int, int)>, long int>] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::_Function_base::_Base_manager<std::__future_base::_Task_setter<std::unique_ptr<std::__future_base::_Result<long int>, std::__future_base::_Result_base::_Deleter>, std::_Bind_simple<std::reference_wrapper<long int (*)(int, int)>(int, int)>, long int> >::_M_init_functor ((union _Any_data &) (union _Any_data *) __functor, (struct _Task_setter &) (struct type *) std::move<std::__future_base::_Task_setter<std::unique_ptr<std::__future_base::_Result<long int>, std::__future_base::_Result_base::_Deleter>, std::_Bind_simple<std::reference_wrapper<long int (*)(int, int)>(int, int)>, long int>&> ((struct _Task_setter &) (struct _Task_setter *) __f), TARGET_EXPR <D.120984, {}>;, <<< Unknown tree: empty_class_expr >>>;) >>>>>;


;; Function static _Res std::_Function_handler<_Res(_ArgTypes ...), _Functor>::_M_invoke(const std::_Any_data&, _ArgTypes&& ...) [with _Res = std::unique_ptr<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>; _Functor = std::__future_base::_Task_setter<std::unique_ptr<std::__future_base::_Result<long int>, std::__future_base::_Result_base::_Deleter>, std::_Bind_simple<std::reference_wrapper<long int (*)(int, int)>(int, int)>, long int>; _ArgTypes = {}] (null)
;; enabled by -tree-original


<<cleanup_point return *<retval> = TARGET_EXPR <D.120987, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.120987
  (struct unique_ptr *) <<< Unknown tree: void_cst >>>
  (struct unique_ptr &) &TARGET_EXPR <D.120986, <<< Unknown tree: aggr_init_expr
  4
  operator()
  D.120986
  std::_Function_base::_Base_manager<std::__future_base::_Task_setter<std::unique_ptr<std::__future_base::_Result<long int>, std::__future_base::_Result_base::_Deleter>, std::_Bind_simple<std::reference_wrapper<long int (*)(int, int)>(int, int)>, long int> >::_M_get_pointer ((const union _Any_data &) (const union _Any_data *) __functor) >>>> >>>>>>;


;; Function static bool std::_Function_base::_Base_manager<_Functor>::_M_manager(std::_Any_data&, const std::_Any_data&, std::_Manager_operation) [with _Functor = std::__future_base::_Task_setter<std::unique_ptr<std::__future_base::_Result<long int>, std::__future_base::_Result_base::_Deleter>, std::_Bind_simple<std::reference_wrapper<long int (*)(int, int)>(int, int)>, long int>] (null)
;; enabled by -tree-original


switch ((int) __op)
  {
    case 0:;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*std::_Any_data::_M_access<const std::type_info*> ((union _Any_data *) __dest) = (const struct type_info *) &_ZTINSt13__future_base12_Task_setterISt10unique_ptrINS_7_ResultIlEENS_12_Result_base8_DeleterEESt12_Bind_simpleIFSt17reference_wrapperIPFliiEEiiEElEE) >>>>>;
    goto <D.121000>;
    case 1:;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*std::_Any_data::_M_access<std::__future_base::_Task_setter<std::unique_ptr<std::__future_base::_Result<long int>, std::__future_base::_Result_base::_Deleter>, std::_Bind_simple<std::reference_wrapper<long int (*)(int, int)>(int, int)>, long int>*> ((union _Any_data *) __dest) = std::_Function_base::_Base_manager<std::__future_base::_Task_setter<std::unique_ptr<std::__future_base::_Result<long int>, std::__future_base::_Result_base::_Deleter>, std::_Bind_simple<std::reference_wrapper<long int (*)(int, int)>(int, int)>, long int> >::_M_get_pointer ((const union _Any_data &) (const union _Any_data *) __source)) >>>>>;
    goto <D.121000>;
    case 2:;
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Function_base::_Base_manager<std::__future_base::_Task_setter<std::unique_ptr<std::__future_base::_Result<long int>, std::__future_base::_Result_base::_Deleter>, std::_Bind_simple<std::reference_wrapper<long int (*)(int, int)>(int, int)>, long int> >::_M_clone ((union _Any_data &) (union _Any_data *) __dest, (const union _Any_data &) (const union _Any_data *) __source, TARGET_EXPR <D.120997, {}>;, <<< Unknown tree: empty_class_expr >>>;) >>>>>;
    goto <D.121000>;
    case 3:;
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Function_base::_Base_manager<std::__future_base::_Task_setter<std::unique_ptr<std::__future_base::_Result<long int>, std::__future_base::_Result_base::_Deleter>, std::_Bind_simple<std::reference_wrapper<long int (*)(int, int)>(int, int)>, long int> >::_M_destroy ((union _Any_data &) (union _Any_data *) __dest, TARGET_EXPR <D.120999, {}>;, <<< Unknown tree: empty_class_expr >>>;) >>>>>;
    goto <D.121000>;
  }
<D.121000>:;
return <retval> = 0;


;; Function std::shared_ptr<_Tp1> std::allocate_shared(const _Alloc&, _Args&& ...) [with _Tp = std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>; _Alloc = std::allocator<int>; _Args = {long int (*)(int, int), const std::allocator<int>&}] (null)
;; enabled by -tree-original


<<cleanup_point return *<retval> = TARGET_EXPR <D.121021, <<< Unknown tree: aggr_init_expr
  8
  __comp_ctor 
  D.121021
  (struct shared_ptr *) <<< Unknown tree: void_cst >>>
  TARGET_EXPR <D.121002, {}>;, <<< Unknown tree: empty_class_expr >>>;
  (const struct allocator &) (const struct allocator *) __a
  (long int (*<T105d2>) (int, int) &) (long int (*<T105d2>) (int, int) *) std::forward<long int (*)(int, int)> ((long int (*type) (int, int) &) (long int (*<T105d2>) (int, int) *) __args#0)
  (const struct allocator &) (const struct allocator *) std::forward<const std::allocator<int>&> ((const struct type &) (const struct allocator *) __args#1) >>>>>>;


;; Function constexpr _Head& std::__get_helper(std::_Tuple_impl<_Idx, _Head, _Tail ...>&) [with long unsigned int __i = 0ul; _Head = std::packaged_task<long int(int, int)>; _Tail = {int, int}] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct packaged_task &) (struct packaged_task *) std::_Tuple_impl<0ul, std::packaged_task<long int(int, int)>, int, int>::_M_head ((struct _Tuple_impl &) (struct _Tuple_impl *) __t)>>
   >>>;


;; Function constexpr std::__tuple_element_t<__i, std::tuple<_Elements ...> >& std::get(std::tuple<_Elements ...>&) [with long unsigned int __i = 0ul; _Elements = {std::packaged_task<long int(int, int)>, int, int}; std::__tuple_element_t<__i, std::tuple<_Elements ...> > = std::packaged_task<long int(int, int)>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct __tuple_element_t &) (struct packaged_task *) std::__get_helper<0ul, std::packaged_task<long int(int, int)>, int, int> ((struct _Tuple_impl &) &((struct tuple *) __t)->D.102039)>>
   >>>;


;; Function constexpr _Head& std::__get_helper(std::_Tuple_impl<_Idx, _Head, _Tail ...>&) [with long unsigned int __i = 1ul; _Head = int; _Tail = {int}] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (int &) (int *) std::_Tuple_impl<1ul, int, int>::_M_head ((struct _Tuple_impl &) (struct _Tuple_impl *) __t)>>
   >>>;


;; Function constexpr std::__tuple_element_t<__i, std::tuple<_Elements ...> >& std::get(std::tuple<_Elements ...>&) [with long unsigned int __i = 1ul; _Elements = {std::packaged_task<long int(int, int)>, int, int}; std::__tuple_element_t<__i, std::tuple<_Elements ...> > = int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (__tuple_element_t &) (int *) std::__get_helper<1ul, int, int> ((struct _Tuple_impl &) &((struct tuple *) __t)->D.102039.D.101575)>>
   >>>;


;; Function constexpr _Head& std::__get_helper(std::_Tuple_impl<_Idx, _Head, _Tail ...>&) [with long unsigned int __i = 2ul; _Head = int; _Tail = {}] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (int &) (int *) std::_Tuple_impl<2ul, int>::_M_head ((struct _Tuple_impl &) (struct _Tuple_impl *) __t)>>
   >>>;


;; Function constexpr std::__tuple_element_t<__i, std::tuple<_Elements ...> >& std::get(std::tuple<_Elements ...>&) [with long unsigned int __i = 2ul; _Elements = {std::packaged_task<long int(int, int)>, int, int}; std::__tuple_element_t<__i, std::tuple<_Elements ...> > = int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (__tuple_element_t &) (int *) std::__get_helper<2ul, int> ((struct _Tuple_impl &) &((struct tuple *) __t)->D.102039.D.101575.D.100819)>>
   >>>;


;; Function typename std::result_of<_Functor(_ArgTypes ...)>::type std::_Bind_simple<_Callable(_Args ...)>::_M_invoke(std::_Index_tuple<_Indices ...>) [with long unsigned int ..._Indices = {0ul, 1ul}; _Callable = std::packaged_task<long int(int, int)>; _Args = {int, int}; typename std::result_of<_Functor(_ArgTypes ...)>::type = void] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::packaged_task<long int(int, int)>::operator() ((struct packaged_task *) std::forward<std::packaged_task<long int(int, int)> > ((struct type &) (struct __tuple_element_t *) std::get<0ul, std::packaged_task<long int(int, int)>, int, int> ((struct tuple &) &((struct _Bind_simple *) this)->_M_bound)), *std::forward<int> ((type &) (__tuple_element_t *) std::get<1ul, std::packaged_task<long int(int, int)>, int, int> ((struct tuple &) &((struct _Bind_simple *) this)->_M_bound)), *std::forward<int> ((type &) (__tuple_element_t *) std::get<2ul, std::packaged_task<long int(int, int)>, int, int> ((struct tuple &) &((struct _Bind_simple *) this)->_M_bound))) >>>>>;
return;


;; Function _Tp* std::__addressof(_Tp&) [with _Tp = long int (*)(int, int)] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (long int (*<T105d2>) (int, int) *) __r
   >>>;


;; Function static void std::_Function_base::_Base_manager<_Functor>::_M_init_functor(std::_Any_data&, _Functor&&, std::true_type) [with _Functor = std::__future_base::_Task_setter<std::unique_ptr<std::__future_base::_Result<long int>, std::__future_base::_Result_base::_Deleter>, std::_Bind_simple<std::reference_wrapper<long int (*)(int, int)>(int, int)>, long int>; std::true_type = std::integral_constant<bool, true>] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (TARGET_EXPR <D.121086, (struct _Task_setter *) (struct _Task_setter &) (struct type *) std::move<std::__future_base::_Task_setter<std::unique_ptr<std::__future_base::_Result<long int>, std::__future_base::_Result_base::_Deleter>, std::_Bind_simple<std::reference_wrapper<long int (*)(int, int)>(int, int)>, long int>&> ((struct _Task_setter &) (struct _Task_setter *) __f)>;, TARGET_EXPR <D.121084, std::_Any_data::_M_access ((union _Any_data *) __functor)>;, TARGET_EXPR <D.121085, operator new (16, NON_LVALUE_EXPR <D.121084>)>;;, (struct _Task_setter *) D.121085 != 0B ? try
    {
      *(struct _Task_setter *) D.121085 = *NON_LVALUE_EXPR <(struct _Task_setter &) NON_LVALUE_EXPR <D.121086>>;
    }
  catch
    {
      operator delete (D.121085, NON_LVALUE_EXPR <D.121084>);
    }, (struct _Task_setter *) D.121085; : (struct _Task_setter *) D.121085;) >>>>>;


;; Function static _Functor* std::_Function_base::_Base_manager<_Functor>::_M_get_pointer(const std::_Any_data&) [with _Functor = std::__future_base::_Task_setter<std::unique_ptr<std::__future_base::_Result<long int>, std::__future_base::_Result_base::_Deleter>, std::_Bind_simple<std::reference_wrapper<long int (*)(int, int)>(int, int)>, long int>] (null)
;; enabled by -tree-original


{
  const struct _Task_setter * __ptr;

    const struct _Task_setter * __ptr;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__ptr = std::__addressof<const std::__future_base::_Task_setter<std::unique_ptr<std::__future_base::_Result<long int>, std::__future_base::_Result_base::_Deleter>, std::_Bind_simple<std::reference_wrapper<long int (*)(int, int)>(int, int)>, long int> > ((const struct _Task_setter &) (const struct _Task_setter *) std::_Any_data::_M_access<std::__future_base::_Task_setter<std::unique_ptr<std::__future_base::_Result<long int>, std::__future_base::_Result_base::_Deleter>, std::_Bind_simple<std::reference_wrapper<long int (*)(int, int)>(int, int)>, long int> > ((const union _Any_data *) __source))) >>>>>;
  return <retval> = (struct _Task_setter *) __ptr;
}


;; Function _Ptr_type std::__future_base::_Task_setter<_Res_ptr, _Fn, _Res>::operator()() const [with _Ptr_type = std::unique_ptr<std::__future_base::_Result<long int>, std::__future_base::_Result_base::_Deleter>; _Fn = std::_Bind_simple<std::reference_wrapper<long int (*)(int, int)>(int, int)>; _Res = long int] (null)
;; enabled by -tree-original


{
  <<< Unknown tree: try_block
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__future_base::_Result<long int>::_M_set (std::unique_ptr<std::__future_base::_Result<long int>, std::__future_base::_Result_base::_Deleter>::operator-> ((struct unique_ptr *) ((const struct _Task_setter *) this)->_M_result), (long int &) &TARGET_EXPR <D.121096, std::_Bind_simple<std::reference_wrapper<long int (*)(int, int)>(int, int)>::operator() ((struct _Bind_simple *) ((const struct _Task_setter *) this)->_M_fn)>) >>>>>
  <<< Unknown tree: handler
  
  {
    const struct __forced_unwind & D.121097 = (const struct __forced_unwind &) (const struct __forced_unwind *) (const struct __forced_unwind &) D.121098;

    try
      {
                register struct __forced_unwind * D.121098;
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (D.121098 = (struct __forced_unwind *) __cxa_begin_catch (__builtin_eh_pointer (0))) >>>>>;
                const struct __forced_unwind & D.121097 = (const struct __forced_unwind &) (const struct __forced_unwind *) (const struct __forced_unwind &) D.121098;
        <<cleanup_point <<< Unknown tree: expr_stmt
  <<< Unknown tree: throw_expr
  __cxa_rethrow () >>> >>>>>;
      }
    finally
      {
        __cxa_end_catch ();
      }
  } >>>;
  <<< Unknown tree: handler
  
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) __cxa_begin_catch (__builtin_eh_pointer (0)) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::__exception_ptr::exception_ptr::operator= (&std::unique_ptr<std::__future_base::_Result<long int>, std::__future_base::_Result_base::_Deleter>::operator-> ((struct unique_ptr *) ((const struct _Task_setter *) this)->_M_result)->D.98954._M_error, (struct exception_ptr &) &TARGET_EXPR <D.121099, <<< Unknown tree: aggr_init_expr
  3
  current_exception
  D.121099 >>>>) >>>>>;
    }
  finally
    {
      __cxa_end_catch ();
    } >>>; >>>;
  <<cleanup_point return *<retval> = TARGET_EXPR <D.121100, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.121100
  (struct unique_ptr *) <<< Unknown tree: void_cst >>>
  (struct unique_ptr &) (struct type *) std::move<std::unique_ptr<std::__future_base::_Result<long int>, std::__future_base::_Result_base::_Deleter>&> ((struct unique_ptr &) (struct unique_ptr *) ((const struct _Task_setter *) this)->_M_result) >>>>>>;
}


;; Function _Tp& std::_Any_data::_M_access() [with _Tp = std::__future_base::_Task_setter<std::unique_ptr<std::__future_base::_Result<long int>, std::__future_base::_Result_base::_Deleter>, std::_Bind_simple<std::reference_wrapper<long int (*)(int, int)>(int, int)>, long int>*] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (struct _Task_setter * &) (struct _Task_setter * *) std::_Any_data::_M_access (this)>>;


;; Function static void std::_Function_base::_Base_manager<_Functor>::_M_clone(std::_Any_data&, const std::_Any_data&, std::true_type) [with _Functor = std::__future_base::_Task_setter<std::unique_ptr<std::__future_base::_Result<long int>, std::__future_base::_Result_base::_Deleter>, std::_Bind_simple<std::reference_wrapper<long int (*)(int, int)>(int, int)>, long int>; std::true_type = std::integral_constant<bool, true>] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (TARGET_EXPR <D.121105, (const struct _Task_setter *) (const struct _Task_setter &) (const struct _Task_setter *) std::_Any_data::_M_access<std::__future_base::_Task_setter<std::unique_ptr<std::__future_base::_Result<long int>, std::__future_base::_Result_base::_Deleter>, std::_Bind_simple<std::reference_wrapper<long int (*)(int, int)>(int, int)>, long int> > ((const union _Any_data *) __source)>;, TARGET_EXPR <D.121103, std::_Any_data::_M_access ((union _Any_data *) __dest)>;, TARGET_EXPR <D.121104, operator new (16, NON_LVALUE_EXPR <D.121103>)>;;, (struct _Task_setter *) D.121104 != 0B ? try
    {
      *(struct _Task_setter *) D.121104 = *D.121105;
    }
  catch
    {
      operator delete (D.121104, NON_LVALUE_EXPR <D.121103>);
    }, (struct _Task_setter *) D.121104; : (struct _Task_setter *) D.121104;) >>>>>;


;; Function static void std::_Function_base::_Base_manager<_Functor>::_M_destroy(std::_Any_data&, std::true_type) [with _Functor = std::__future_base::_Task_setter<std::unique_ptr<std::__future_base::_Result<long int>, std::__future_base::_Result_base::_Deleter>, std::_Bind_simple<std::reference_wrapper<long int (*)(int, int)>(int, int)>, long int>; std::true_type = std::integral_constant<bool, true>] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::_Any_data::_M_access<std::__future_base::_Task_setter<std::unique_ptr<std::__future_base::_Result<long int>, std::__future_base::_Result_base::_Deleter>, std::_Bind_simple<std::reference_wrapper<long int (*)(int, int)>(int, int)>, long int> > ((union _Any_data *) __victim) >>>>>;


;; Function std::shared_ptr<_Tp>::shared_ptr(std::_Sp_make_shared_tag, const _Alloc&, _Args&& ...) [with _Alloc = std::allocator<int>; _Args = {long int (*)(int, int), const std::allocator<int>&}; _Tp = std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__shared_ptr<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, (__gnu_cxx::_Lock_policy)2u>::__shared_ptr<std::allocator<int>, long int (*)(int, int), const std::allocator<int>&> (&((struct shared_ptr *) this)->D.109703, TARGET_EXPR <D.121126, __tag>;, <<< Unknown tree: empty_class_expr >>>;, (const struct allocator &) (const struct allocator *) __a, (long int (*<T105d2>) (int, int) &) (long int (*<T105d2>) (int, int) *) std::forward<long int (*)(int, int)> ((long int (*type) (int, int) &) (long int (*<T105d2>) (int, int) *) __args#0), (const struct allocator &) (const struct allocator *) std::forward<const std::allocator<int>&> ((const struct type &) (const struct allocator *) __args#1)) >>>>>;
  try
    {
      
    }
  catch
    {
      std::__shared_ptr<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, (__gnu_cxx::_Lock_policy)2u>::~__shared_ptr (&((struct shared_ptr *) this)->D.109703);
    }
}


;; Function void std::packaged_task<_Res(_ArgTypes ...)>::operator()(_ArgTypes ...) [with _Res = long int; _ArgTypes = {int, int}] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::__future_base::_State_baseV2::_S_check<std::__future_base::_Task_state_base<long int(int, int)> > ((const struct shared_ptr &) (const struct shared_ptr *) &((struct packaged_task *) this)->_M_state) >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  OBJ_TYPE_REF(*(SAVE_EXPR <std::__shared_ptr<std::__future_base::_Task_state_base<long int(int, int)>, (__gnu_cxx::_Lock_policy)2u>::operator-> (&((struct packaged_task *) this)->_M_state.D.82011)>->D.98645._vptr._State_baseV2 + 32);(struct _Task_state_base)SAVE_EXPR <std::__shared_ptr<std::__future_base::_Task_state_base<long int(int, int)>, (__gnu_cxx::_Lock_policy)2u>::operator-> (&((struct packaged_task *) this)->_M_state.D.82011)>->4) (SAVE_EXPR <std::__shared_ptr<std::__future_base::_Task_state_base<long int(int, int)>, (__gnu_cxx::_Lock_policy)2u>::operator-> (&((struct packaged_task *) this)->_M_state.D.82011)>, (int &) (int *) std::forward<int> ((type &) &__args#0), (int &) (int *) std::forward<int> ((type &) &__args#1)) >>>>>;


;; Function const _Tp& std::_Any_data::_M_access() const [with _Tp = std::__future_base::_Task_setter<std::unique_ptr<std::__future_base::_Result<long int>, std::__future_base::_Result_base::_Deleter>, std::_Bind_simple<std::reference_wrapper<long int (*)(int, int)>(int, int)>, long int>] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (const struct _Task_setter &) (const struct _Task_setter *) std::_Any_data::_M_access (this)>>;


;; Function _Tp* std::__addressof(_Tp&) [with _Tp = const std::__future_base::_Task_setter<std::unique_ptr<std::__future_base::_Result<long int>, std::__future_base::_Result_base::_Deleter>, std::_Bind_simple<std::reference_wrapper<long int (*)(int, int)>(int, int)>, long int>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (const struct _Task_setter *) __r
   >>>;


;; Function const _Tp& std::_Any_data::_M_access() const [with _Tp = std::__future_base::_Task_setter<std::unique_ptr<std::__future_base::_Result<long int>, std::__future_base::_Result_base::_Deleter>, std::_Bind_simple<std::reference_wrapper<long int (*)(int, int)>(int, int)>, long int>*] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (struct _Task_setter * const &) (struct _Task_setter * const *) std::_Any_data::_M_access (this)>>;


;; Function std::unique_ptr<_Tp, _Dp>::pointer std::unique_ptr<_Tp, _Dp>::operator->() const [with _Tp = std::__future_base::_Result<long int>; _Dp = std::__future_base::_Result_base::_Deleter; std::unique_ptr<_Tp, _Dp>::pointer = std::__future_base::_Result<long int>*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::unique_ptr<std::__future_base::_Result<long int>, std::__future_base::_Result_base::_Deleter>::get (this)>>
   >>>;


;; Function std::_Bind_simple<_Callable(_Args ...)>::result_type std::_Bind_simple<_Callable(_Args ...)>::operator()() [with _Callable = std::reference_wrapper<long int (*)(int, int)>; _Args = {int, int}; std::_Bind_simple<_Callable(_Args ...)>::result_type = long int] (null)
;; enabled by -tree-original


{
  typedef struct _Indices _Indices;

  <<cleanup_point return <retval> = std::_Bind_simple<std::reference_wrapper<long int (*)(int, int)>(int, int)>::_M_invoke<0ul, 1ul> (this, TARGET_EXPR <D.121139, {}>;, <<< Unknown tree: empty_class_expr >>>;)>>;
}


;; Function void std::__future_base::_Result<_Res>::_M_set(_Res&&) [with _Res = long int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (TARGET_EXPR <D.121146, *std::move<long int&> ((long int &) (long int *) __res)>;, TARGET_EXPR <D.121144, __gnu_cxx::__aligned_buffer<long int>::_M_addr (&((struct _Result *) this)->_M_storage)>;, TARGET_EXPR <D.121145, operator new (8, NON_LVALUE_EXPR <D.121144>)>;;, (long int *) D.121145 != 0B ? try
    {
      *(long int *) D.121145 = NON_LVALUE_EXPR <D.121146>;
    }
  catch
    {
      operator delete (D.121145, NON_LVALUE_EXPR <D.121144>);
    }, (long int *) D.121145; : (long int *) D.121145;) >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Result *) this)->_M_initialized = 1) >>>>>;


;; Function _Tp& std::_Any_data::_M_access() [with _Tp = std::__future_base::_Task_setter<std::unique_ptr<std::__future_base::_Result<long int>, std::__future_base::_Result_base::_Deleter>, std::_Bind_simple<std::reference_wrapper<long int (*)(int, int)>(int, int)>, long int>] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (struct _Task_setter &) (struct _Task_setter *) std::_Any_data::_M_access (this)>>;


;; Function std::__shared_ptr<_Tp, _Lp>::__shared_ptr(std::_Sp_make_shared_tag, const _Alloc&, _Args&& ...) [with _Alloc = std::allocator<int>; _Args = {long int (*)(int, int), const std::allocator<int>&}; _Tp = std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __shared_ptr *) this)->_M_ptr = 0B) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__shared_count<>::__shared_count<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, std::allocator<int>, long int (*)(int, int), const std::allocator<int>&> (&((struct __shared_ptr *) this)->_M_refcount, TARGET_EXPR <D.121170, __tag>;, <<< Unknown tree: empty_class_expr >>>;, 0B, (const struct allocator &) (const struct allocator *) __a, (long int (*<T105d2>) (int, int) &) (long int (*<T105d2>) (int, int) *) std::forward<long int (*)(int, int)> ((long int (*type) (int, int) &) (long int (*<T105d2>) (int, int) *) __args#0), (const struct allocator &) (const struct allocator *) std::forward<const std::allocator<int>&> ((const struct type &) (const struct allocator *) __args#1)) >>>>>;
  try
    {
      {
        void * __p;

                void * __p;
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__p = std::__shared_count<>::_M_get_deleter (&((struct __shared_ptr *) this)->_M_refcount, (const struct type_info &) (const struct type_info *) &_ZTISt19_Sp_make_shared_tag)) >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __shared_ptr *) this)->_M_ptr = (struct _Task_state *) __p) >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  std::__enable_shared_from_this_helper<(__gnu_cxx::_Lock_policy)2u> ((const struct __shared_count &) (const struct __shared_count *) &((struct __shared_ptr *) this)->_M_refcount, ((struct __shared_ptr *) this)->_M_ptr, ((struct __shared_ptr *) this)->_M_ptr) >>>>>;
      }
    }
  catch
    {
      std::__shared_count<>::~__shared_count (&((struct __shared_ptr *) this)->_M_refcount);
    }
}


;; Function static void std::__future_base::_State_baseV2::_S_check(const std::shared_ptr<_Tp1>&) [with _Tp = std::__future_base::_Task_state_base<long int(int, int)>] (null)
;; enabled by -tree-original


if (<<cleanup_point !std::__shared_ptr<std::__future_base::_Task_state_base<long int(int, int)>, (__gnu_cxx::_Lock_policy)2u>::operator bool (&((const struct shared_ptr *) __p)->D.82011)>>)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_future_error (3) >>>>>;
  }


;; Function constexpr _Head& std::__get_helper(std::_Tuple_impl<_Idx, _Head, _Tail ...>&) [with long unsigned int __i = 0ul; _Head = std::reference_wrapper<long int (*)(int, int)>; _Tail = {int, int}] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct reference_wrapper &) (struct reference_wrapper *) std::_Tuple_impl<0ul, std::reference_wrapper<long int (*)(int, int)>, int, int>::_M_head ((struct _Tuple_impl &) (struct _Tuple_impl *) __t)>>
   >>>;


;; Function constexpr std::__tuple_element_t<__i, std::tuple<_Elements ...> >& std::get(std::tuple<_Elements ...>&) [with long unsigned int __i = 0ul; _Elements = {std::reference_wrapper<long int (*)(int, int)>, int, int}; std::__tuple_element_t<__i, std::tuple<_Elements ...> > = std::reference_wrapper<long int (*)(int, int)>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (struct __tuple_element_t &) (struct reference_wrapper *) std::__get_helper<0ul, std::reference_wrapper<long int (*)(int, int)>, int, int> ((struct _Tuple_impl &) &((struct tuple *) __t)->D.119777)>>
   >>>;


;; Function constexpr std::__tuple_element_t<__i, std::tuple<_Elements ...> >& std::get(std::tuple<_Elements ...>&) [with long unsigned int __i = 1ul; _Elements = {std::reference_wrapper<long int (*)(int, int)>, int, int}; std::__tuple_element_t<__i, std::tuple<_Elements ...> > = int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (__tuple_element_t &) (int *) std::__get_helper<1ul, int, int> ((struct _Tuple_impl &) &((struct tuple *) __t)->D.119777.D.119317)>>
   >>>;


;; Function constexpr std::__tuple_element_t<__i, std::tuple<_Elements ...> >& std::get(std::tuple<_Elements ...>&) [with long unsigned int __i = 2ul; _Elements = {std::reference_wrapper<long int (*)(int, int)>, int, int}; std::__tuple_element_t<__i, std::tuple<_Elements ...> > = int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (__tuple_element_t &) (int *) std::__get_helper<2ul, int> ((struct _Tuple_impl &) &((struct tuple *) __t)->D.119777.D.119317.D.100819)>>
   >>>;


;; Function typename std::result_of<_Functor(_ArgTypes ...)>::type std::_Bind_simple<_Callable(_Args ...)>::_M_invoke(std::_Index_tuple<_Indices ...>) [with long unsigned int ..._Indices = {0ul, 1ul}; _Callable = std::reference_wrapper<long int (*)(int, int)>; _Args = {int, int}; typename std::result_of<_Functor(_ArgTypes ...)>::type = long int] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = std::reference_wrapper<long int (*)(int, int)>::operator()<int, int> ((struct reference_wrapper *) std::forward<std::reference_wrapper<long int (*)(int, int)> > ((struct type &) (struct __tuple_element_t *) std::get<0ul, std::reference_wrapper<long int (*)(int, int)>, int, int> ((struct tuple &) &((struct _Bind_simple *) this)->_M_bound)), (int &) (int *) std::forward<int> ((type &) (__tuple_element_t *) std::get<1ul, std::reference_wrapper<long int (*)(int, int)>, int, int> ((struct tuple &) &((struct _Bind_simple *) this)->_M_bound)), (int &) (int *) std::forward<int> ((type &) (__tuple_element_t *) std::get<2ul, std::reference_wrapper<long int (*)(int, int)>, int, int> ((struct tuple &) &((struct _Bind_simple *) this)->_M_bound)))>>;


;; Function std::__shared_count<_Lp>::__shared_count(std::_Sp_make_shared_tag, _Tp*, const _Alloc&, _Args&& ...) [with _Tp = std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>; _Alloc = std::allocator<int>; _Args = {long int (*)(int, int), const std::allocator<int>&}; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __shared_count *) this)->_M_pi = 0B) >>>>>;
  {
    typedef struct _Sp_cp_type _Sp_cp_type;
    struct __allocator_type __a2;
    struct __allocated_ptr __guard;
    struct _Sp_cp_type * __mem;

        struct __allocator_type __a2;
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator<std::_Sp_counted_ptr_inplace<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, std::allocator<int>, (__gnu_cxx::_Lock_policy)2u> >::allocator<int> (&__a2, (const struct allocator &) (const struct allocator *) __a) >>>>>;
    try
      {
                struct __allocated_ptr __guard;
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__guard = <<< Unknown tree: aggr_init_expr
  4
  __allocate_guarded
  D.121220
  (struct allocator &) &__a2 >>>) >>>>>;
        try
          {
                        struct _Sp_cp_type * __mem;
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__mem = std::__allocated_ptr<std::allocator<std::_Sp_counted_ptr_inplace<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, std::allocator<int>, (__gnu_cxx::_Lock_policy)2u> > >::get (&__guard)) >>>>>;
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (TARGET_EXPR <D.121241, &TARGET_EXPR <D.121240, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.121240
  (struct allocator *) <<< Unknown tree: void_cst >>>
  (const struct allocator &) (const struct type *) std::move<const std::allocator<int>&> ((const struct allocator &) (const struct allocator *) __a) >>>>>;, TARGET_EXPR <D.121242, (long int (*<T105d2>) (int, int) &) (long int (*<T105d2>) (int, int) *) std::forward<long int (*)(int, int)> ((long int (*type) (int, int) &) (long int (*<T105d2>) (int, int) *) __args#0)>;;, TARGET_EXPR <D.121243, (const struct allocator &) (const struct allocator *) std::forward<const std::allocator<int>&> ((const struct type &) (const struct allocator *) __args#1)>;;, TARGET_EXPR <D.121224, (void *) TARGET_EXPR <D.121222, __mem>>;, TARGET_EXPR <D.121223, operator new (64, NON_LVALUE_EXPR <D.121224>)>;;, (struct _Sp_cp_type *) D.121223 != 0B ? try
    {
      std::_Sp_counted_ptr_inplace<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, std::allocator<int>, (__gnu_cxx::_Lock_policy)2u>::_Sp_counted_ptr_inplace<long int (*)(int, int), const std::allocator<int>&> ((struct _Sp_cp_type *) D.121223, NON_LVALUE_EXPR <D.121241>, NON_LVALUE_EXPR <D.121242>, NON_LVALUE_EXPR <D.121243>);
    }
  catch
    {
      operator delete (D.121223, NON_LVALUE_EXPR <D.121224>);
    }, (struct _Sp_cp_type *) D.121223; : (struct _Sp_cp_type *) D.121223;) >>>>>;
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __shared_count *) this)->_M_pi = (struct _Sp_counted_base *) __mem) >>>>>;
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::__allocated_ptr<std::allocator<std::_Sp_counted_ptr_inplace<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, std::allocator<int>, (__gnu_cxx::_Lock_policy)2u> > >::operator= (&__guard, 0) >>>>>;
          }
        finally
          {
            std::__allocated_ptr<std::allocator<std::_Sp_counted_ptr_inplace<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, std::allocator<int>, (__gnu_cxx::_Lock_policy)2u> > >::~__allocated_ptr (&__guard);
          }
      }
    finally
      {
        std::allocator<std::_Sp_counted_ptr_inplace<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, std::allocator<int>, (__gnu_cxx::_Lock_policy)2u> >::~allocator (&__a2);
      }
  }
}


;; Function typename std::result_of<_Tp&(_Args&& ...)>::type std::reference_wrapper<_Tp>::operator()(_Args&& ...) const [with _Args = {int, int}; _Tp = long int (*)(int, int); typename std::result_of<_Tp&(_Args&& ...)>::type = long int] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = std::__invoke<long int (*)(int, int), int, int> (*std::reference_wrapper<long int (*)(int, int)>::get (this), (int &) (int *) std::forward<int> ((type &) (int *) __args#0), (int &) (int *) std::forward<int> ((type &) (int *) __args#1))>>;


;; Function std::_Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp>::_Sp_counted_ptr_inplace(_Alloc, _Args&& ...) [with _Args = {long int (*)(int, int), const std::allocator<int>&}; _Tp = std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>; _Alloc = std::allocator<int>; __gnu_cxx::_Lock_policy _Lp = (__gnu_cxx::_Lock_policy)2u] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2u>::_Sp_counted_base (&((struct _Sp_counted_ptr_inplace *) this)->D.115717) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Sp_counted_ptr_inplace *) this)->D.115717._vptr._Sp_counted_base = &_ZTVSt23_Sp_counted_ptr_inplaceINSt13__future_base11_Task_stateIPFliiESaIiES2_EES4_LN9__gnu_cxx12_Lock_policyE2EE + 16) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Sp_counted_ptr_inplace<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, std::allocator<int>, (__gnu_cxx::_Lock_policy)2u>::_Impl::_Impl (&((struct _Sp_counted_ptr_inplace *) this)->_M_impl, &TARGET_EXPR <D.121341, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.121341
  (struct allocator *) <<< Unknown tree: void_cst >>>
  (const struct allocator &) (const struct allocator *) (struct allocator *) __a >>>>) >>>>>;
      try
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator_traits<std::allocator<int> >::construct<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, long int (*)(int, int), const std::allocator<int>&> ((struct allocator_type &) (struct allocator *) __a, std::_Sp_counted_ptr_inplace<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, std::allocator<int>, (__gnu_cxx::_Lock_policy)2u>::_M_ptr (this), (long int (*<T105d2>) (int, int) &) (long int (*<T105d2>) (int, int) *) std::forward<long int (*)(int, int)> ((long int (*type) (int, int) &) (long int (*<T105d2>) (int, int) *) __args#0), (const struct allocator &) (const struct allocator *) std::forward<const std::allocator<int>&> ((const struct type &) (const struct allocator *) __args#1)) >>>>>;
        }
      catch
        {
          std::_Sp_counted_ptr_inplace<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, std::allocator<int>, (__gnu_cxx::_Lock_policy)2u>::_Impl::~_Impl (&((struct _Sp_counted_ptr_inplace *) this)->_M_impl);
        }
    }
  catch
    {
      std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2u>::~_Sp_counted_base (&((struct _Sp_counted_ptr_inplace *) this)->D.115717);
    }
}


;; Function _Tp& std::reference_wrapper<_Tp>::get() const [with _Tp = long int (*)(int, int)] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (long int (*<T105d2>) (int, int) &) (long int (*<T105d2>) (int, int) *) ((const struct reference_wrapper *) this)->_M_data
   >>>;


;; Function typename std::enable_if<(std::is_pointer<_Tp>::value && std::is_function<typename std::remove_pointer<_Tp>::type>::value), typename std::result_of<_Functor(_Args&& ...)>::type>::type std::__invoke(_Functor, _Args&& ...) [with _Functor = long int (*)(int, int); _Args = {int, int}; typename std::enable_if<(std::is_pointer<_Tp>::value && std::is_function<typename std::remove_pointer<_Tp>::type>::value), typename std::result_of<_Functor(_Args&& ...)>::type>::type = long int] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __f (*std::forward<int> ((type &) (int *) __args#0), *std::forward<int> ((type &) (int *) __args#1))>>;


;; Function static void std::allocator_traits<std::allocator<_CharT> >::construct(std::allocator_traits<std::allocator<_CharT> >::allocator_type&, _Up*, _Args&& ...) [with _Up = std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>; _Args = {long int (*)(int, int), const std::allocator<int>&}; _Tp = int; std::allocator_traits<std::allocator<_CharT> >::allocator_type = std::allocator<int>] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<int>::construct<std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>, long int (*)(int, int), const std::allocator<int>&> ((struct new_allocator *) (struct allocator_type *) __a, __p, (long int (*<T105d2>) (int, int) &) (long int (*<T105d2>) (int, int) *) std::forward<long int (*)(int, int)> ((long int (*type) (int, int) &) (long int (*<T105d2>) (int, int) *) __args#0), (const struct allocator &) (const struct allocator *) std::forward<const std::allocator<int>&> ((const struct type &) (const struct allocator *) __args#1)) >>>>>;


;; Function void __gnu_cxx::new_allocator<_Tp>::construct(_Up*, _Args&& ...) [with _Up = std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>; _Args = {long int (*)(int, int), const std::allocator<int>&}; _Tp = int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (TARGET_EXPR <D.121373, (long int (*<T105d2>) (int, int) &) (long int (*<T105d2>) (int, int) *) std::forward<long int (*)(int, int)> ((long int (*type) (int, int) &) (long int (*<T105d2>) (int, int) *) __args#0)>;, TARGET_EXPR <D.121374, (const struct allocator &) (const struct allocator *) std::forward<const std::allocator<int>&> ((const struct type &) (const struct allocator *) __args#1)>;;, TARGET_EXPR <D.121359, (void *) __p>;, TARGET_EXPR <D.121360, operator new (48, NON_LVALUE_EXPR <D.121359>)>;;, (struct _Task_state *) D.121360 != 0B ? try
    {
      std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>::_Task_state<long int (*)(int, int)> ((struct _Task_state *) D.121360, NON_LVALUE_EXPR <D.121373>, NON_LVALUE_EXPR <D.121374>);
    }
  catch
    {
      operator delete (D.121360, NON_LVALUE_EXPR <D.121359>);
    }, (struct _Task_state *) D.121360; : (struct _Task_state *) D.121360;) >>>>>;


;; Function std::__future_base::_Task_state<_Fn, _Alloc, _Res(_Args ...)>::_Task_state(_Fn2&&, const _Alloc&) [with _Fn2 = long int (*)(int, int); _Fn = long int (*)(int, int); _Alloc = std::allocator<int>; _Res = long int; _Args = {int, int}] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__future_base::_Task_state_base<long int(int, int)>::_Task_state_base<std::allocator<int> > (&((struct _Task_state *) this)->D.109886, (const struct allocator &) (const struct allocator *) __a) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Task_state *) this)->D.109886.D.98645._vptr._State_baseV2 = &_ZTVNSt13__future_base11_Task_stateIPFliiESaIiES1_EE + 16) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>::_Impl::_Impl<long int (*)(int, int)> (&((struct _Task_state *) this)->_M_impl, (long int (*<T105d2>) (int, int) &) (long int (*<T105d2>) (int, int) *) std::forward<long int (*)(int, int)> ((long int (*type) (int, int) &) (long int (*<T105d2>) (int, int) *) __fn), (const struct allocator &) (const struct allocator *) __a) >>>>>;
      try
        {
          
        }
      catch
        {
          std::__future_base::_Task_state<long int (*)(int, int), std::allocator<int>, long int(int, int)>::_Impl::~_Impl (&((struct _Task_state *) this)->_M_impl);
        }
    }
  catch
    {
      std::__future_base::_Task_state_base<long int(int, int)>::~_Task_state_base (&((struct _Task_state *) this)->D.109886);
    }
}


;; Function std::__future_base::_Task_state<_Fn, _Alloc, _Res(_Args ...)>::_Impl::_Impl(_Fn2&&, const _Alloc&) [with _Fn2 = long int (*)(int, int); _Fn = long int (*)(int, int); _Alloc = std::allocator<int>; _Res = long int; _Args = {int, int}] (null)
;; enabled by -tree-original


{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator<int>::allocator ((struct allocator *) this, (const struct allocator &) (const struct allocator *) __a) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Impl *) this)->_M_fn = *std::forward<long int (*)(int, int)> ((long int (*type) (int, int) &) (long int (*<T105d2>) (int, int) *) __fn)) >>>>>;
    }
  catch
    {
      std::allocator<int>::~allocator ((struct allocator *) this);
    }
}


;; Function (static initializers for atrshmlogtest03.C) (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  __static_initialization_and_destruction_0 (1, 65535) >>>>>;

